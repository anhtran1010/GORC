[{"prompt": "\n#include \"npb-C.h\"\n\nint main(int argc, char **argv) {\n    \n  int niter, step;\n  double mflops, tmax;\n  int nthreads = 1;\n  boolean verified;\n  char class;\n  FILE *fp;\n\n\n  printf(\"\\n\\n NAS Parallel Benchmarks 3.0 structured OpenMP C version\"\n\t \" - SP Benchmark\\n\\n\");\n\n  fp = fopen(\"inputsp.data\", \"r\");\n  if (fp != NULL) {\n      printf(\" Reading from input file inputsp.data\\n\");\n      fscanf(fp, \"%d\", &niter);\n      while (fgetc(fp) != '\\n');\n      fscanf(fp, \"%lf\", &dt);\n      while (fgetc(fp) != '\\n');\n      fscanf(fp, \"%d%d%d\",\n\t     &grid_points[0], &grid_points[1], &grid_points[2]);\n      fclose(fp);\n  } else {\n      printf(\" No input file inputsp.data. Using compiled defaults\");\n\n      niter = NITER_DEFAULT;\n      dt = DT_DEFAULT;\n      grid_points[0] = PROBLEM_SIZE;\n      grid_points[1] = PROBLEM_SIZE;\n      grid_points[2] = PROBLEM_SIZE;\n  }\n\n  printf(\" Size: %3dx%3dx%3d\\n\",\n\t grid_points[0], grid_points[1], grid_points[2]);\n  printf(\" Iterations: %3d   dt: %10.6f\\n\", niter, dt);\n  \n  if ( (grid_points[0] > IMAX) ||\n       (grid_points[1] > JMAX) ||\n       (grid_points[2] > KMAX) ) {\n    printf(\"%d, %d, %d\\n\", grid_points[0], grid_points[1], grid_points[2]);\n    printf(\" Problem size too big for compiled array sizes\\n\");\n    exit(1);\n  }\n\n  set_constants();\n\n  initialize();\n\n  lhsinit();\n\n  exact_rhs();\n  \n\n\n    adi();\n\n  \n  initialize();\n\n  timer_clear(1);\n  timer_start(1);\n\n  for (step = 1; step <= niter; step++) {\n    if (step % 20 == 0 || step == 1) {\n\n      printf(\" Time step %4d\\n\", step);\n    }\n    adi();\n  }\n#pragma omp parallel\n  {    \n#if defined(_OPENMP)\n#pragma omp master\n  nthreads = omp_get_num_threads();\n#endif /* _OPENMP */  \n#endif /* _OPENMP */  \n  } /* end parallel */\n  } /* end parallel */\n\n  timer_stop(1);\n  tmax = timer_read(1);\n\n  verify(niter, &class, &verified);\n\n  if (tmax != 0) {\n    mflops = ( 881.174 * pow((double)PROBLEM_SIZE, 3.0)\n\t       - 4683.91 * pow2((double)PROBLEM_SIZE)\n\t       + 11484.5 * (double)PROBLEM_SIZE\n\t       - 19272.4) * (double)niter / (tmax*1000000.0);\n  } else {\n    mflops = 0.0;\n  }\n  \n  c_print_results(\"SP\", class, grid_points[0],\n\t\t  grid_points[1], grid_points[2], niter, nthreads,\n\t\t  tmax, mflops, \"          floating point\", \n\t\t  verified, NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, \n\t\t  CS6, \"(none)\");\n}\n\n\nstatic void add(void) {\n  int i, j, k, m;\n\n\n#pragma omp for\n  for (m = 0; m < 5; m++) {\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tfor (k = 1; k <= grid_points[2]-2; k++) {\n\t  u[m][i][j][k] = u[m][i][j][k] + rhs[m][i][j][k];\n\t}\n      }\n    }\n  }\n}\n\n\nstatic void adi(void) {\n\n  compute_rhs();\n\n  txinvr();\n\n  x_solve();\n\n  y_solve();\n\n  z_solve();\n\n  add();\n\n}\n\n\nstatic void error_norm(double rms[5]) {\n\n\n\n  int i, j, k, m, d;\n  double xi, eta, zeta, u_exact[5], add;\n\n  for (m = 0; m < 5; m++) {\n    rms[m] = 0.0;\n  }\n\n  for (i = 0; i <= grid_points[0]-1; i++) {\n    xi = (double)i * dnxm1;\n    for (j = 0; j <= grid_points[1]-1; j++) {\n      eta = (double)j * dnym1;\n      for (k = 0; k <= grid_points[2]-1; k++) {\n\tzeta = (double)k * dnzm1;\n\texact_solution(xi, eta, zeta, u_exact);\n\tfor (m = 0; m < 5; m++) {\n\t  add = u[m][i][j][k] - u_exact[m];\n\t  rms[m] = rms[m] + add*add;\n\t}\n      }\n    }\n  }\n\n  for (m = 0; m < 5; m++) {\n    for (d = 0; d < 3; d++) {\n      rms[m] = rms[m] / (double)(grid_points[d]-2);\n    }\n    rms[m] = sqrt(rms[m]);\n  }\n}\n\n\nstatic void rhs_norm(double rms[5]) {\n\n\n  int i, j, k, d, m;\n  double add;\n\n  for (m = 0; m < 5; m++) {\n    rms[m] = 0.0;\n  }\n\n  for (i = 0; i <= grid_points[0]-2; i++) {\n    for (j = 0; j <= grid_points[1]-2; j++) {\n      for (k = 0; k <= grid_points[2]-2; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  add = rhs[m][i][j][k];\n\t  rms[m] = rms[m] + add*add;\n\t}\n      }\n    }\n  }\n\n  for (m = 0; m < 5; m++) {\n    for (d = 0; d < 3; d++) {\n      rms[m] = rms[m] / (double)(grid_points[d]-2);\n    }\n    rms[m] = sqrt(rms[m]);\n  }\n}\n\n\nstatic void exact_rhs(void) {\n\n\n\n  double dtemp[5], xi, eta, zeta, dtpp;\n  int m, i, j, k, ip1, im1, jp1, jm1, km1, kp1;\n\n  for (m = 0; m < 5; m++) {\n    for (i = 0; i <= grid_points[0]-1; i++) {\n      for (j = 0; j <= grid_points[1]-1; j++) {\n\tfor (k= 0; k <= grid_points[2]-1; k++) {\n\t  forcing[m][i][j][k] = 0.0;\n\t}\n      }\n    }\n  }\n\n  for (k = 1; k <= grid_points[2]-2; k++) {\n    zeta = (double)k * dnzm1;\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      eta = (double)j * dnym1;\n\n      for (i = 0; i <= grid_points[0]-1; i++) {\n\txi = (double)i * dnxm1;\n\n\texact_solution(xi, eta, zeta, dtemp);\n\tfor (m = 0; m < 5; m++) {\n\t  ue[m][i] = dtemp[m];\n\t}\n\n\tdtpp = 1.0 / dtemp[0];\n\n\tfor (m = 1; m < 5; m++) {\n\t  buf[m][i] = dtpp * dtemp[m];\n\t}\n\n\tcuf[i] = buf[1][i] * buf[1][i];\n\tbuf[0][i] = cuf[i] + buf[2][i] * buf[2][i] + buf[3][i] * buf[3][i];\n\tq[i] = 0.5 * (buf[1][i]*ue[1][i] + buf[2][i]*ue[2][i]\n\t\t      + buf[3][i]*ue[3][i]);\n      }\n \n      for (i = 1; i <= grid_points[0]-2; i++) {\n\tim1 = i-1;\n\tip1 = i+1;\n\n\tforcing[0][i][j][k] = forcing[0][i][j][k] -\n\t  tx2*( ue[1][ip1]-ue[1][im1] )+\n\t  dx1tx1*(ue[0][ip1]-2.0*ue[0][i]+ue[0][im1]);\n\n\tforcing[1][i][j][k] = forcing[1][i][j][k]\n\t  - tx2 * ((ue[1][ip1]*buf[1][ip1]+c2*(ue[4][ip1]-q[ip1]))-\n                   (ue[1][im1]*buf[1][im1]+c2*(ue[4][im1]-q[im1])))+\n\t  xxcon1*(buf[1][ip1]-2.0*buf[1][i]+buf[1][im1])+\n\t  dx2tx1*( ue[1][ip1]-2.0* ue[1][i]+ue[1][im1]);\n\n\tforcing[2][i][j][k] = forcing[2][i][j][k]\n\t  - tx2 * (ue[2][ip1]*buf[1][ip1]-ue[2][im1]*buf[1][im1])+\n\t  xxcon2*(buf[2][ip1]-2.0*buf[2][i]+buf[2][im1])+\n\t  dx3tx1*( ue[2][ip1]-2.0*ue[2][i] +ue[2][im1]);\n                  \n\tforcing[3][i][j][k] = forcing[3][i][j][k]\n\t  - tx2*(ue[3][ip1]*buf[1][ip1]-ue[3][im1]*buf[1][im1])+\n\t  xxcon2*(buf[3][ip1]-2.0*buf[3][i]+buf[3][im1])+\n\t  dx4tx1*( ue[3][ip1]-2.0* ue[3][i]+ ue[3][im1]);\n\n\tforcing[4][i][j][k] = forcing[4][i][j][k]\n\t  - tx2*(buf[1][ip1]*(c1*ue[4][ip1]-c2*q[ip1])-\n\t\t buf[1][im1]*(c1*ue[4][im1]-c2*q[im1]))+\n\t  0.5*xxcon3*(buf[0][ip1]-2.0*buf[0][i]+\n\t\t      buf[0][im1])+\n\t  xxcon4*(cuf[ip1]-2.0*cuf[i]+cuf[im1])+\n\t  xxcon5*(buf[4][ip1]-2.0*buf[4][i]+buf[4][im1])+\n\t  dx5tx1*( ue[4][ip1]-2.0* ue[4][i]+ ue[4][im1]);\n      }\n\n      for (m = 0; m < 5; m++) {\n\ti = 1;\n\tforcing[m][i][j][k] = forcing[m][i][j][k] - dssp *\n\t  (5.0*ue[m][i] - 4.0*ue[m][i+1] +ue[m][i+2]);\n\ti = 2;\n\tforcing[m][i][j][k] = forcing[m][i][j][k] - dssp *\n\t  (-4.0*ue[m][i-1] + 6.0*ue[m][i] -\n \t    4.0*ue[m][i+1] +     ue[m][i+2]);\n      }\n\n      for (m = 0; m < 5; m++) {\n\tfor (i = 3; i <= grid_points[0]-4; i++) {\n\t  forcing[m][i][j][k] = forcing[m][i][j][k] - dssp*\n\t    (ue[m][i-2] - 4.0*ue[m][i-1] +\n\t     6.0*ue[m][i] - 4.0*ue[m][i+1] + ue[m][i+2]);\n\t}\n      }\n\n      for (m = 0; m < 5; m++) {\n\ti = grid_points[0]-3;\n\tforcing[m][i][j][k] = forcing[m][i][j][k] - dssp *\n\t  (ue[m][i-2] - 4.0*ue[m][i-1] +\n\t   6.0*ue[m][i] - 4.0*ue[m][i+1]);\n\ti = grid_points[0]-2;\n\tforcing[m][i][j][k] = forcing[m][i][j][k] - dssp *\n\t  (ue[m][i-2] - 4.0*ue[m][i-1] + 5.0*ue[m][i]);\n      }\n    }\n  }\n\n  for (k = 1; k <= grid_points[2]-2; k++) {\n    zeta = (double)k * dnzm1;\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      xi = (double)i * dnxm1;\n\n      for (j = 0; j <= grid_points[1]-1; j++) {\n\teta = (double)j * dnym1;\n\n\texact_solution(xi, eta, zeta, dtemp);\n\tfor (m = 0; m < 5; m++) {\n\t  ue[m][j] = dtemp[m];\n\t}\n\tdtpp = 1.0/dtemp[0];\n\n\tfor (m = 1; m < 5; m++) {\n\t  buf[m][j] = dtpp * dtemp[m];\n\t}\n\n\tcuf[j]   = buf[2][j] * buf[2][j];\n\tbuf[0][j] = cuf[j] + buf[1][j] * buf[1][j] + \n\t  buf[3][j] * buf[3][j];\n\tq[j] = 0.5*(buf[1][j]*ue[1][j] + buf[2][j]*ue[2][j] +\n\t\t    buf[3][j]*ue[3][j]);\n      }\n\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tjm1 = j-1;\n\tjp1 = j+1;\n                  \n\tforcing[0][i][j][k] = forcing[0][i][j][k] -\n\t  ty2*( ue[2][jp1]-ue[2][jm1] )+\n\t  dy1ty1*(ue[0][jp1]-2.0*ue[0][j]+ue[0][jm1]);\n\n\tforcing[1][i][j][k] = forcing[1][i][j][k]\n\t  - ty2*(ue[1][jp1]*buf[2][jp1]-ue[1][jm1]*buf[2][jm1])+\n\t  yycon2*(buf[1][jp1]-2.0*buf[1][j]+buf[1][jm1])+\n\t  dy2ty1*( ue[1][jp1]-2.0* ue[1][j]+ ue[1][jm1]);\n\n\tforcing[2][i][j][k] = forcing[2][i][j][k]\n\t  - ty2*((ue[2][jp1]*buf[2][jp1]+c2*(ue[4][jp1]-q[jp1]))-\n\t\t (ue[2][jm1]*buf[2][jm1]+c2*(ue[4][jm1]-q[jm1])))+\n\t  yycon1*(buf[2][jp1]-2.0*buf[2][j]+buf[2][jm1])+\n\t  dy3ty1*( ue[2][jp1]-2.0*ue[2][j] +ue[2][jm1]);\n\n\tforcing[3][i][j][k] = forcing[3][i][j][k]\n\t  - ty2*(ue[3][jp1]*buf[2][jp1]-ue[3][jm1]*buf[2][jm1])+\n\t  yycon2*(buf[3][jp1]-2.0*buf[3][j]+buf[3][jm1])+\n\t  dy4ty1*( ue[3][jp1]-2.0*ue[3][j]+ ue[3][jm1]);\n\n\tforcing[4][i][j][k] = forcing[4][i][j][k]\n\t  - ty2*(buf[2][jp1]*(c1*ue[4][jp1]-c2*q[jp1])-\n\t\t buf[2][jm1]*(c1*ue[4][jm1]-c2*q[jm1]))+\n\t  0.5*yycon3*(buf[0][jp1]-2.0*buf[0][j]+\n\t\t      buf[0][jm1])+\n\t  yycon4*(cuf[jp1]-2.0*cuf[j]+cuf[jm1])+\n\t  yycon5*(buf[4][jp1]-2.0*buf[4][j]+buf[4][jm1])+\n\t  dy5ty1*(ue[4][jp1]-2.0*ue[4][j]+ue[4][jm1]);\n      }\n\n      for (m = 0; m < 5; m++) {\n\tj = 1;\n\tforcing[m][i][j][k] = forcing[m][i][j][k] - dssp *\n\t  (5.0*ue[m][j] - 4.0*ue[m][j+1] +ue[m][j+2]);\n\tj = 2;\n\tforcing[m][i][j][k] = forcing[m][i][j][k] - dssp *\n\t  (-4.0*ue[m][j-1] + 6.0*ue[m][j] -\n\t   4.0*ue[m][j+1] +       ue[m][j+2]);\n      }\n\n      for (m = 0; m < 5; m++) {\n\tfor (j = 3; j <= grid_points[1]-4; j++) {\n\t  forcing[m][i][j][k] = forcing[m][i][j][k] - dssp*\n\t    (ue[m][j-2] - 4.0*ue[m][j-1] +\n\t     6.0*ue[m][j] - 4.0*ue[m][j+1] + ue[m][j+2]);\n\t}\n      }\n\n      for (m = 0; m < 5; m++) {\n\tj = grid_points[1]-3;\n\tforcing[m][i][j][k] = forcing[m][i][j][k] - dssp *\n\t  (ue[m][j-2] - 4.0*ue[m][j-1] +\n\t   6.0*ue[m][j] - 4.0*ue[m][j+1]);\n\tj = grid_points[1]-2;\n\tforcing[m][i][j][k] = forcing[m][i][j][k] - dssp *\n\t  (ue[m][j-2] - 4.0*ue[m][j-1] + 5.0*ue[m][j]);\n\n      }\n    }\n  }\n\n  for (j = 1; j <= grid_points[1]-2; j++) {\n    eta = (double)j * dnym1;\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      xi = (double)i * dnxm1;\n\n      for (k = 0; k <= grid_points[2]-1; k++) {\n\tzeta = (double)k * dnzm1;\n\n\texact_solution(xi, eta, zeta, dtemp);\n\tfor (m = 0; m < 5; m++) {\n\t  ue[m][k] = dtemp[m];\n\t}\n\n\tdtpp = 1.0/dtemp[0];\n\n\tfor (m = 1; m < 5; m++) {\n\t  buf[m][k] = dtpp * dtemp[m];\n\t}\n\n\tcuf[k] = buf[3][k] * buf[3][k];\n\tbuf[0][k] = cuf[k] + buf[1][k] * buf[1][k] + \n\t  buf[2][k] * buf[2][k];\n\tq[k] = 0.5*(buf[1][k]*ue[1][k] + buf[2][k]*ue[2][k] +\n\t\t    buf[3][k]*ue[3][k]);\n      }\n\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tkm1 = k-1;\n\tkp1 = k+1;\n                  \n\tforcing[0][i][j][k] = forcing[0][i][j][k] -\n\t  tz2*( ue[3][kp1]-ue[3][km1] )+\n\t  dz1tz1*(ue[0][kp1]-2.0*ue[0][k]+ue[0][km1]);\n\n\tforcing[1][i][j][k] = forcing[1][i][j][k]\n\t  - tz2 * (ue[1][kp1]*buf[3][kp1]-ue[1][km1]*buf[3][km1])+\n\t  zzcon2*(buf[1][kp1]-2.0*buf[1][k]+buf[1][km1])+\n\t  dz2tz1*( ue[1][kp1]-2.0* ue[1][k]+ ue[1][km1]);\n\n\tforcing[2][i][j][k] = forcing[2][i][j][k]\n\t  - tz2 * (ue[2][kp1]*buf[3][kp1]-ue[2][km1]*buf[3][km1])+\n\t  zzcon2*(buf[2][kp1]-2.0*buf[2][k]+buf[2][km1])+\n\t  dz3tz1*(ue[2][kp1]-2.0*ue[2][k]+ue[2][km1]);\n\n\tforcing[3][i][j][k] = forcing[3][i][j][k]\n\t  - tz2 * ((ue[3][kp1]*buf[3][kp1]+c2*(ue[4][kp1]-q[kp1]))-\n\t\t   (ue[3][km1]*buf[3][km1]+c2*(ue[4][km1]-q[km1])))+\n\t  zzcon1*(buf[3][kp1]-2.0*buf[3][k]+buf[3][km1])+\n\t  dz4tz1*( ue[3][kp1]-2.0*ue[3][k] +ue[3][km1]);\n\n\tforcing[4][i][j][k] = forcing[4][i][j][k]\n\t  - tz2 * (buf[3][kp1]*(c1*ue[4][kp1]-c2*q[kp1])-\n\t\t   buf[3][km1]*(c1*ue[4][km1]-c2*q[km1]))+\n\t  0.5*zzcon3*(buf[0][kp1]-2.0*buf[0][k]\n\t\t      +buf[0][km1])+\n\t  zzcon4*(cuf[kp1]-2.0*cuf[k]+cuf[km1])+\n\t  zzcon5*(buf[4][kp1]-2.0*buf[4][k]+buf[4][km1])+\n\t  dz5tz1*( ue[4][kp1]-2.0*ue[4][k]+ ue[4][km1]);\n      }\n\n      for (m = 0; m < 5; m++) {\n\tk = 1;\n\tforcing[m][i][j][k] = forcing[m][i][j][k] - dssp *\n\t  (5.0*ue[m][k] - 4.0*ue[m][k+1] +ue[m][k+2]);\n\tk = 2;\n\tforcing[m][i][j][k] = forcing[m][i][j][k] - dssp *\n\t  (-4.0*ue[m][k-1] + 6.0*ue[m][k] -\n\t   4.0*ue[m][k+1] +       ue[m][k+2]);\n      }\n\n      for (m = 0; m < 5; m++) {\n\tfor (k = 3; k <= grid_points[2]-4; k++) {\n\t  forcing[m][i][j][k] = forcing[m][i][j][k] - dssp*\n\t    (ue[m][k-2] - 4.0*ue[m][k-1] +\n\t     6.0*ue[m][k] - 4.0*ue[m][k+1] + ue[m][k+2]);\n\t}\n      }\n\n      for (m = 0; m < 5; m++) {\n\tk = grid_points[2]-3;\n\tforcing[m][i][j][k] = forcing[m][i][j][k] - dssp *\n\t  (ue[m][k-2] - 4.0*ue[m][k-1] +\n\t   6.0*ue[m][k] - 4.0*ue[m][k+1]);\n\tk = grid_points[2]-2;\n\tforcing[m][i][j][k] = forcing[m][i][j][k] - dssp *\n\t  (ue[m][k-2] - 4.0*ue[m][k-1] + 5.0*ue[m][k]);\n      }\n    }\n  }\n\n  for (m = 0; m < 5; m++) {\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tfor (k = 1; k <= grid_points[2]-2; k++) {\n\t  forcing[m][i][j][k] = -1.0 * forcing[m][i][j][k];\n\t}\n      }\n    }\n  }\n}\n\n\nstatic void exact_solution(double xi, double eta, double zeta,\n\t\t\t   double dtemp[5]) {\n\n\n\n  int m;\n\n  for (m = 0; m < 5; m++) {\n    dtemp[m] =  ce[0][m] +\n      xi*(ce[1][m] + xi*(ce[4][m] + \n\t\t\t     xi*(ce[7][m] + xi*ce[10][m]))) +\n      eta*(ce[2][m] + eta*(ce[5][m] + \n\t\t\t       eta*(ce[8][m] + eta*ce[11][m])))+\n      zeta*(ce[3][m] + zeta*(ce[6][m] +\n\t\t\t\t zeta*(ce[9][m] + \n\t\t\t\t       zeta*ce[12][m])));\n  }\n}\n\n\nstatic void initialize(void) {\n\n\n\n  int i, j, k, m, ix, iy, iz;\n  double xi, eta, zeta, Pface[2][3][5], Pxi, Peta, Pzeta, temp[5];\n\n\n  for (i = 0; i <= IMAX-1; i++) {\n    for (j = 0; j <= IMAX-1; j++) {\n      for (k = 0; k <= IMAX-1; k++) {\n\tu[0][i][j][k] = 1.0;\n\tu[1][i][j][k] = 0.0;\n\tu[2][i][j][k] = 0.0;\n\tu[3][i][j][k] = 0.0;\n\tu[4][i][j][k] = 1.0;\n      }\n    }\n  }\n\n\n  for (i = 0; i <= grid_points[0]-1; i++) {\n    xi = (double)i * dnxm1;\n    for (j = 0; j <= grid_points[1]-1; j++) {\n      eta = (double)j * dnym1;\n      for (k = 0; k <= grid_points[2]-1; k++) {\n\tzeta = (double)k * dnzm1;\n                  \n\tfor (ix = 0; ix < 2; ix++) {\n\t  exact_solution((double)ix, eta, zeta, \n\t\t\t &Pface[ix][0][0]);\n\t}\n\n\tfor (iy = 0; iy < 2; iy++) {\n\t  exact_solution(xi, (double)iy , zeta, \n\t\t\t &Pface[iy][1][0]);\n\t}\n\n\tfor (iz = 0; iz < 2; iz++) {\n\t  exact_solution(xi, eta, (double)iz,   \n\t\t\t &Pface[iz][2][0]);\n\t}\n\n\tfor (m = 0; m < 5; m++) {\n\t  Pxi   = xi   * Pface[1][0][m] + \n\t    (1.0-xi)   * Pface[0][0][m];\n\t  Peta  = eta  * Pface[1][1][m] + \n\t    (1.0-eta)  * Pface[0][1][m];\n\t  Pzeta = zeta * Pface[1][2][m] + \n\t    (1.0-zeta) * Pface[0][2][m];\n \n\t  u[m][i][j][k] = Pxi + Peta + Pzeta - \n\t    Pxi*Peta - Pxi*Pzeta - Peta*Pzeta + \n\t    Pxi*Peta*Pzeta;\n\n\t}\n      }\n    }\n  }\n\n\n\n  xi = 0.0;\n  i  = 0;\n  for (j = 0; j < grid_points[1]; j++) {\n    eta = (double)j * dnym1;\n    for (k = 0; k < grid_points[2]; k++) {\n      zeta = (double)k * dnzm1;\n      exact_solution(xi, eta, zeta, temp);\n      for (m = 0; m < 5; m++) {\n\tu[m][i][j][k] = temp[m];\n      }\n    }\n  }\n\n\n  xi = 1.0;\n  i  = grid_points[0]-1;\n  for (j = 0; j < grid_points[1]; j++) {\n    eta = (double)j * dnym1;\n    for (k = 0; k < grid_points[2]; k++) {\n      zeta = (double)k * dnzm1;\n      exact_solution(xi, eta, zeta, temp);\n      for (m = 0; m < 5; m++) {\n\tu[m][i][j][k] = temp[m];\n      }\n    }\n  }\n\n\n  eta = 0.0;\n  j   = 0;\n  for (i = 0; i < grid_points[0]; i++) {\n    xi = (double)i * dnxm1;\n    for (k = 0; k < grid_points[2]; k++) {\n      zeta = (double)k * dnzm1;\n      exact_solution(xi, eta, zeta, temp);\n      for (m = 0; m < 5; m++) {\n\tu[m][i][j][k] = temp[m];\n      }\n    }\n  }\n\n\n  eta = 1.0;\n  j   = grid_points[1]-1;\n  for (i = 0; i < grid_points[0]; i++) {\n    xi = (double)i * dnxm1;\n    for (k = 0; k < grid_points[2]; k++) {\n      zeta = (double)k * dnzm1;\n      exact_solution(xi, eta, zeta, temp);\n      for (m = 0; m < 5; m++) {\n\tu[m][i][j][k] = temp[m];\n      }\n    }\n  }\n\n\n  zeta = 0.0;\n  k    = 0;\n  for (i = 0; i < grid_points[0]; i++) {\n    xi = (double)i *dnxm1;\n    for (j = 0; j < grid_points[1]; j++) {\n      eta = (double)j * dnym1;\n      exact_solution(xi, eta, zeta, temp);\n      for (m = 0; m < 5; m++) {\n\tu[m][i][j][k] = temp[m];\n      }\n    }\n  }\n\n\n  zeta = 1.0;\n  k    = grid_points[2]-1;\n  for (i = 0; i < grid_points[0]; i++) {\n    xi = (double)i * dnxm1;\n    for (j = 0; j < grid_points[1]; j++) {\n      eta = (double)j * dnym1;\n      exact_solution(xi, eta, zeta, temp);\n      for (m = 0; m < 5; m++) {\n\tu[m][i][j][k] = temp[m];\n      }\n    }\n  }\n}\n\n\n\nstatic void lhsinit(void) {\n\n\n  int i, j, k, n;\n\n  for (n = 0; n < 15; n++) {\n#pragma omp for nowait\n    for (i = 0; i < grid_points[0]; i++) {\n      for (j = 0; j < grid_points[1]; j++) {\n\tfor (k = 0; k < grid_points[2]; k++) {\n\t  lhs[n][i][j][k] = 0.0;\n\t}\n      }\n    }\n  }\n#pragma omp barrier  \n\n  for (n = 0; n < 3; n++) {\n#pragma omp for    \n    for (i = 0; i < grid_points[0]; i++) {\n      for (j = 0; j < grid_points[1]; j++) {\n\tfor (k = 0; k < grid_points[2]; k++) {\n\t  lhs[5*n+2][i][j][k] = 1.0;\n\t}\n      }\n    }\n  }\n}\n\t \n\nstatic void lhsx(void) {\n\n\n\n  double ru1;\n  int i, j, k;\n\n  for (j = 1; j <= grid_points[1]-2; j++) {\n    for (k = 1; k <= grid_points[2]-2; k++) {\n#pragma omp for  \n      for (i = 0; i <= grid_points[0]-1; i++) {\n\tru1 = c3c4*rho_i[i][j][k];\n\tcv[i] = us[i][j][k];\n\trhon[i] = max(dx2+con43*ru1, \n\t\t      max(dx5+c1c5*ru1,\n\t\t\t  max(dxmax+ru1,\n\t\t\t      dx1)));\n      }\n\n#pragma omp for  \n      for (i = 1; i <= grid_points[0]-2; i++) {\n\tlhs[0][i][j][k] =   0.0;\n\tlhs[1][i][j][k] = - dttx2 * cv[i-1] - dttx1 * rhon[i-1];\n\tlhs[2][i][j][k] =   1.0 + c2dttx1 * rhon[i];\n\tlhs[3][i][j][k] =   dttx2 * cv[i+1] - dttx1 * rhon[i+1];\n\tlhs[4][i][j][k] =   0.0;\n      }\n    }\n  }\n\n\n  i = 1;\n#pragma omp for nowait\n  for (j = 1; j <= grid_points[1]-2; j++) {\n    for (k = 1; k <= grid_points[2]-2; k++) {\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz5;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n      lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n      lhs[1][i+1][j][k] = lhs[1][i+1][j][k] - comz4;\n      lhs[2][i+1][j][k] = lhs[2][i+1][j][k] + comz6;\n      lhs[3][i+1][j][k] = lhs[3][i+1][j][k] - comz4;\n      lhs[4][i+1][j][k] = lhs[4][i+1][j][k] + comz1;\n    }\n  }\n\n#pragma omp for nowait\n  for (i = 3; i <= grid_points[0]-4; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tlhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n\tlhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n\tlhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n\tlhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n\tlhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n      }\n    }\n  }\n\n  i = grid_points[0]-3;\n#pragma omp for  \n  for (j = 1; j <= grid_points[1]-2; j++) {\n    for (k = 1; k <= grid_points[2]-2; k++) {\n      lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n      lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n\n      lhs[0][i+1][j][k] = lhs[0][i+1][j][k] + comz1;\n      lhs[1][i+1][j][k] = lhs[1][i+1][j][k] - comz4;\n      lhs[2][i+1][j][k] = lhs[2][i+1][j][k] + comz5;\n    }\n  }\n\n#pragma omp for  \n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tlhs[0+5][i][j][k]  = lhs[0][i][j][k];\n\tlhs[1+5][i][j][k]  = lhs[1][i][j][k] - \n\t  dttx2 * speed[i-1][j][k];\n\tlhs[2+5][i][j][k]  = lhs[2][i][j][k];\n\tlhs[3+5][i][j][k]  = lhs[3][i][j][k] + \n\t  dttx2 * speed[i+1][j][k];\n\tlhs[4+5][i][j][k]  = lhs[4][i][j][k];\n\tlhs[0+10][i][j][k] = lhs[0][i][j][k];\n\tlhs[1+10][i][j][k] = lhs[1][i][j][k] + \n\t  dttx2 * speed[i-1][j][k];\n\tlhs[2+10][i][j][k] = lhs[2][i][j][k];\n\tlhs[3+10][i][j][k] = lhs[3][i][j][k] - \n\t  dttx2 * speed[i+1][j][k];\n\tlhs[4+10][i][j][k] = lhs[4][i][j][k];\n      }\n    }\n  }\n}\n\n\nstatic void lhsy(void) {\n\n\n\n  double ru1;\n  int i, j, k;\n\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (k = 1; k <= grid_points[2]-2; k++) {\n#pragma omp for  \n      for (j = 0; j <= grid_points[1]-1; j++) {\n\tru1 = c3c4*rho_i[i][j][k];\n\tcv[j] = vs[i][j][k];\n\trhoq[j] = max(dy3 + con43 * ru1,\n\t\t      max(dy5 + c1c5*ru1,\n\t\t\t  max(dymax + ru1,\n\t\t\t      dy1)));\n      }\n            \n#pragma omp for  \n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tlhs[0][i][j][k] =  0.0;\n\tlhs[1][i][j][k] = -dtty2 * cv[j-1] - dtty1 * rhoq[j-1];\n\tlhs[2][i][j][k] =  1.0 + c2dtty1 * rhoq[j];\n\tlhs[3][i][j][k] =  dtty2 * cv[j+1] - dtty1 * rhoq[j+1];\n\tlhs[4][i][j][k] =  0.0;\n      }\n    }\n  }\n\n\n  j = 1;\n#pragma omp for nowait\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (k = 1; k <= grid_points[2]-2; k++) {\n\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz5;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n      lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n       \n      lhs[1][i][j+1][k] = lhs[1][i][j+1][k] - comz4;\n      lhs[2][i][j+1][k] = lhs[2][i][j+1][k] + comz6;\n      lhs[3][i][j+1][k] = lhs[3][i][j+1][k] - comz4;\n      lhs[4][i][j+1][k] = lhs[4][i][j+1][k] + comz1;\n    }\n  }\n\n#pragma omp for nowait\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 3; j <= grid_points[1]-4; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tlhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n\tlhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n\tlhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n\tlhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n\tlhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n      }\n    }\n  }\n\n  j = grid_points[1]-3;\n#pragma omp for  \n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (k = 1; k <= grid_points[2]-2; k++) {\n      lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n      lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n\n      lhs[0][i][j+1][k] = lhs[0][i][j+1][k] + comz1;\n      lhs[1][i][j+1][k] = lhs[1][i][j+1][k] - comz4;\n      lhs[2][i][j+1][k] = lhs[2][i][j+1][k] + comz5;\n    }\n  }\n\n#pragma omp for  \n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tlhs[0+5][i][j][k]  = lhs[0][i][j][k];\n\tlhs[1+5][i][j][k]  = lhs[1][i][j][k] - \n\t  dtty2 * speed[i][j-1][k];\n\tlhs[2+5][i][j][k]  = lhs[2][i][j][k];\n\tlhs[3+5][i][j][k]  = lhs[3][i][j][k] + \n\t  dtty2 * speed[i][j+1][k];\n\tlhs[4+5][i][j][k] = lhs[4][i][j][k];\n\tlhs[0+10][i][j][k] = lhs[0][i][j][k];\n\tlhs[1+10][i][j][k] = lhs[1][i][j][k] + \n\t  dtty2 * speed[i][j-1][k];\n\tlhs[2+10][i][j][k] = lhs[2][i][j][k];\n\tlhs[3+10][i][j][k] = lhs[3][i][j][k] - \n\t  dtty2 * speed[i][j+1][k];\n\tlhs[4+10][i][j][k] = lhs[4][i][j][k];\n      }\n    }\n  }\n}\n\n\nstatic void lhsz(void) {\n\n\n\n  double ru1;\n  int i, j, k;\n\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n#pragma omp for  \n      for (k = 0; k <= grid_points[2]-1; k++) {\n\tru1 = c3c4*rho_i[i][j][k];\n\tcv[k] = ws[i][j][k];\n\trhos[k] = max(dz4 + con43 * ru1,\n\t\t      max(dz5 + c1c5 * ru1,\n\t\t\t  max(dzmax + ru1,\n\t\t\t      dz1)));\n      }\n\n#pragma omp for  \n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tlhs[0][i][j][k] =  0.0;\n\tlhs[1][i][j][k] = -dttz2 * cv[k-1] - dttz1 * rhos[k-1];\n\tlhs[2][i][j][k] =  1.0 + c2dttz1 * rhos[k];\n\tlhs[3][i][j][k] =  dttz2 * cv[k+1] - dttz1 * rhos[k+1];\n\tlhs[4][i][j][k] =  0.0;\n      }\n    }\n  }\n\n\n  k = 1;\n#pragma omp for nowait\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz5;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n      lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n\n      lhs[1][i][j][k+1] = lhs[1][i][j][k+1] - comz4;\n      lhs[2][i][j][k+1] = lhs[2][i][j][k+1] + comz6;\n      lhs[3][i][j][k+1] = lhs[3][i][j][k+1] - comz4;\n      lhs[4][i][j][k+1] = lhs[4][i][j][k+1] + comz1;\n    }\n  }\n\n#pragma omp for nowait\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 3; k <= grid_points[2]-4; k++) {\n\tlhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n\tlhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n\tlhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n\tlhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n\tlhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n      }\n    }\n  }\n\n  k = grid_points[2]-3;\n#pragma omp for  \n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n      lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n\n      lhs[0][i][j][k+1] = lhs[0][i][j][k+1] + comz1;\n      lhs[1][i][j][k+1] = lhs[1][i][j][k+1] - comz4;\n      lhs[2][i][j][k+1] = lhs[2][i][j][k+1] + comz5;\n    }\n  }\n\n#pragma omp for  \n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tlhs[0+5][i][j][k]  = lhs[0][i][j][k];\n\tlhs[1+5][i][j][k]  = lhs[1][i][j][k] - \n\t  dttz2 * speed[i][j][k-1];\n\tlhs[2+5][i][j][k]  = lhs[2][i][j][k];\n\tlhs[3+5][i][j][k]  = lhs[3][i][j][k] + \n\t  dttz2 * speed[i][j][k+1];\n\tlhs[4+5][i][j][k]  = lhs[4][i][j][k];\n\tlhs[0+10][i][j][k] = lhs[0][i][j][k];\n\tlhs[1+10][i][j][k] = lhs[1][i][j][k] + \n\t  dttz2 * speed[i][j][k-1];\n\tlhs[2+10][i][j][k] = lhs[2][i][j][k];\n\tlhs[3+10][i][j][k] = lhs[3][i][j][k] - \n\t  dttz2 * speed[i][j][k+1];\n\tlhs[4+10][i][j][k] = lhs[4][i][j][k];\n      }\n    }\n  }\n}\n\n\nstatic void ninvr(void) {\n\n\n\n  int i, j, k;\n  double r1, r2, r3, r4, r5, t1, t2;\n#pragma omp parallel for default(shared) private(i,j,k,r1,r2,r3,r4,r5,t1,t2)\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\n\tr1 = rhs[0][i][j][k];\n\tr2 = rhs[1][i][j][k];\n\tr3 = rhs[2][i][j][k];\n\tr4 = rhs[3][i][j][k];\n\tr5 = rhs[4][i][j][k];\n               \n\tt1 = bt * r3;\n\tt2 = 0.5 * ( r4 + r5 );\n\n\trhs[0][i][j][k] = -r2;\n\trhs[1][i][j][k] =  r1;\n\trhs[2][i][j][k] = bt * ( r4 - r5 );\n\trhs[3][i][j][k] = -t1 + t2;\n\trhs[4][i][j][k] =  t1 + t2;\n      }\n    }\n  }\n}\n\n\nstatic void pinvr(void) {\n\n\n\n  int i, j, k;\n  double r1, r2, r3, r4, r5, t1, t2;\n\n#pragma omp parallel for default(shared) private(i,j,k,r1,r2,r3,r4,r5,t1,t2)\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\n\tr1 = rhs[0][i][j][k];\n\tr2 = rhs[1][i][j][k];\n\tr3 = rhs[2][i][j][k];\n\tr4 = rhs[3][i][j][k];\n\tr5 = rhs[4][i][j][k];\n\n\tt1 = bt * r1;\n\tt2 = 0.5 * ( r4 + r5 );\n\n\trhs[0][i][j][k] =  bt * ( r4 - r5 );\n\trhs[1][i][j][k] = -r3;\n\trhs[2][i][j][k] =  r2;\n\trhs[3][i][j][k] = -t1 + t2;\n\trhs[4][i][j][k] =  t1 + t2;\n      }\n    }\n  }\n}\n\n\nstatic void compute_rhs(void) {\n\n#pragma omp parallel\n{\n\n\n  int i, j, k, m;\n  double aux, rho_inv, uijk, up1, um1, vijk, vp1, vm1,\n    wijk, wp1, wm1;\n\n\n#pragma omp for nowait\n  for (i = 0; i <= grid_points[0]-1; i++) {\n    for (j = 0; j <= grid_points[1]-1; j++) {\n      for (k = 0; k <= grid_points[2]-1; k++) {\n\trho_inv = 1.0/u[0][i][j][k];\n\trho_i[i][j][k] = rho_inv;\n\tus[i][j][k] = u[1][i][j][k] * rho_inv;\n\tvs[i][j][k] = u[2][i][j][k] * rho_inv;\n\tws[i][j][k] = u[3][i][j][k] * rho_inv;\n\tsquare[i][j][k] = 0.5* (u[1][i][j][k]*u[1][i][j][k] + \n\t\t\t\tu[2][i][j][k]*u[2][i][j][k] +\n\t\t\t\tu[3][i][j][k]*u[3][i][j][k] ) * rho_inv;\n\tqs[i][j][k] = square[i][j][k] * rho_inv;\n\taux = c1c2*rho_inv* (u[4][i][j][k] - square[i][j][k]);\n\taux = sqrt(aux);\n\tspeed[i][j][k] = aux;\n\tainv[i][j][k]  = 1.0/aux;\n      }\n    }\n  }\n\n\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (i = 0; i <= grid_points[0]-1; i++) {\n      for (j = 0; j <= grid_points[1]-1; j++) {\n\tfor (k = 0; k <= grid_points[2]-1; k++) {\n\t  rhs[m][i][j][k] = forcing[m][i][j][k];\n\t}\n      }\n    }\n  }\n\n#pragma omp for\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tuijk = us[i][j][k];\n\tup1  = us[i+1][j][k];\n\tum1  = us[i-1][j][k];\n\n\trhs[0][i][j][k] = rhs[0][i][j][k] + dx1tx1 * \n\t  (u[0][i+1][j][k] - 2.0*u[0][i][j][k] + \n\t   u[0][i-1][j][k]) -\n\t  tx2 * (u[1][i+1][j][k] - u[1][i-1][j][k]);\n\trhs[1][i][j][k] = rhs[1][i][j][k] + dx2tx1 * \n\t  (u[1][i+1][j][k] - 2.0*u[1][i][j][k] + \n\t   u[1][i-1][j][k]) +\n\t  xxcon2*con43 * (up1 - 2.0*uijk + um1) -\n\t  tx2 * (u[1][i+1][j][k]*up1 - \n\t\t u[1][i-1][j][k]*um1 +\n\t\t (u[4][i+1][j][k]- square[i+1][j][k]-\n\t\t  u[4][i-1][j][k]+ square[i-1][j][k])*\n\t\t c2);\n\n\trhs[2][i][j][k] = rhs[2][i][j][k] + dx3tx1 * \n\t  (u[2][i+1][j][k] - 2.0*u[2][i][j][k] +\n\t   u[2][i-1][j][k]) +\n\t  xxcon2 * (vs[i+1][j][k] - 2.0*vs[i][j][k] +\n\t\t    vs[i-1][j][k]) -\n\t  tx2 * (u[2][i+1][j][k]*up1 - \n\t\t u[2][i-1][j][k]*um1);\n\n\trhs[3][i][j][k] = rhs[3][i][j][k] + dx4tx1 * \n\t  (u[3][i+1][j][k] - 2.0*u[3][i][j][k] +\n\t   u[3][i-1][j][k]) +\n\t  xxcon2 * (ws[i+1][j][k] - 2.0*ws[i][j][k] +\n\t\t    ws[i-1][j][k]) -\n\t  tx2 * (u[3][i+1][j][k]*up1 - \n\t\t u[3][i-1][j][k]*um1);\n\n\trhs[4][i][j][k] = rhs[4][i][j][k] + dx5tx1 * \n\t  (u[4][i+1][j][k] - 2.0*u[4][i][j][k] +\n\t   u[4][i-1][j][k]) +\n\t  xxcon3 * (qs[i+1][j][k] - 2.0*qs[i][j][k] +\n\t\t    qs[i-1][j][k]) +\n\t  xxcon4 * (up1*up1 -       2.0*uijk*uijk + \n\t\t    um1*um1) +\n\t  xxcon5 * (u[4][i+1][j][k]*rho_i[i+1][j][k] - \n\t\t    2.0*u[4][i][j][k]*rho_i[i][j][k] +\n\t\t    u[4][i-1][j][k]*rho_i[i-1][j][k]) -\n\t  tx2 * ( (c1*u[4][i+1][j][k] - \n\t\t   c2*square[i+1][j][k])*up1 -\n\t\t  (c1*u[4][i-1][j][k] - \n\t\t   c2*square[i-1][j][k])*um1 );\n      }\n    }\n  }\n\n\n  i = 1;\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k]- dssp * \n\t  ( 5.0*u[m][i][j][k] - 4.0*u[m][i+1][j][k] +\n\t    u[m][i+2][j][k]);\n      }\n    }\n  }\n  i = 2;\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k] - dssp * \n\t  (-4.0*u[m][i-1][j][k] + 6.0*u[m][i][j][k] -\n\t   4.0*u[m][i+1][j][k] + u[m][i+2][j][k]);\n      }\n    }\n  }\n\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (i = 3*1; i <= grid_points[0]-3*1-1; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tfor (k = 1; k <= grid_points[2]-2; k++) {\n\t  rhs[m][i][j][k] = rhs[m][i][j][k] - dssp * \n\t    (  u[m][i-2][j][k] - 4.0*u[m][i-1][j][k] + \n\t       6.0*u[m][i][j][k] - 4.0*u[m][i+1][j][k] + \n\t       u[m][i+2][j][k] );\n\t}\n      }\n    }\n  }\n\n  i = grid_points[0]-3;\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k] - dssp *\n\t  ( u[m][i-2][j][k] - 4.0*u[m][i-1][j][k] + \n\t    6.0*u[m][i][j][k] - 4.0*u[m][i+1][j][k] );\n      }\n    }\n  }\n\n  i = grid_points[0]-2;\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k] - dssp *\n\t  ( u[m][i-2][j][k] - 4.0*u[m][i-1][j][k] +\n\t    5.0*u[m][i][j][k] );\n      }\n    }\n  }\n#pragma omp barrier\n  \n#pragma omp for\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tvijk = vs[i][j][k];\n\tvp1  = vs[i][j+1][k];\n\tvm1  = vs[i][j-1][k];\n\trhs[0][i][j][k] = rhs[0][i][j][k] + dy1ty1 * \n\t  (u[0][i][j+1][k] - 2.0*u[0][i][j][k] + \n\t   u[0][i][j-1][k]) -\n\t  ty2 * (u[2][i][j+1][k] - u[2][i][j-1][k]);\n\trhs[1][i][j][k] = rhs[1][i][j][k] + dy2ty1 * \n\t  (u[1][i][j+1][k] - 2.0*u[1][i][j][k] + \n\t   u[1][i][j-1][k]) +\n\t  yycon2 * (us[i][j+1][k] - 2.0*us[i][j][k] + \n\t\t    us[i][j-1][k]) -\n\t  ty2 * (u[1][i][j+1][k]*vp1 - \n\t\t u[1][i][j-1][k]*vm1);\n\trhs[2][i][j][k] = rhs[2][i][j][k] + dy3ty1 * \n\t  (u[2][i][j+1][k] - 2.0*u[2][i][j][k] + \n\t   u[2][i][j-1][k]) +\n\t  yycon2*con43 * (vp1 - 2.0*vijk + vm1) -\n\t  ty2 * (u[2][i][j+1][k]*vp1 - \n\t\t u[2][i][j-1][k]*vm1 +\n\t\t (u[4][i][j+1][k] - square[i][j+1][k] - \n\t\t  u[4][i][j-1][k] + square[i][j-1][k])\n\t\t *c2);\n\trhs[3][i][j][k] = rhs[3][i][j][k] + dy4ty1 * \n\t  (u[3][i][j+1][k] - 2.0*u[3][i][j][k] + \n\t   u[3][i][j-1][k]) +\n\t  yycon2 * (ws[i][j+1][k] - 2.0*ws[i][j][k] + \n\t\t    ws[i][j-1][k]) -\n\t  ty2 * (u[3][i][j+1][k]*vp1 - \n\t\t u[3][i][j-1][k]*vm1);\n\trhs[4][i][j][k] = rhs[4][i][j][k] + dy5ty1 * \n\t  (u[4][i][j+1][k] - 2.0*u[4][i][j][k] + \n\t   u[4][i][j-1][k]) +\n\t  yycon3 * (qs[i][j+1][k] - 2.0*qs[i][j][k] + \n\t\t    qs[i][j-1][k]) +\n\t  yycon4 * (vp1*vp1       - 2.0*vijk*vijk + \n\t\t    vm1*vm1) +\n\t  yycon5 * (u[4][i][j+1][k]*rho_i[i][j+1][k] - \n\t\t    2.0*u[4][i][j][k]*rho_i[i][j][k] +\n\t\t    u[4][i][j-1][k]*rho_i[i][j-1][k]) -\n\t  ty2 * ((c1*u[4][i][j+1][k] - \n\t\t  c2*square[i][j+1][k]) * vp1 -\n\t\t (c1*u[4][i][j-1][k] - \n\t\t  c2*square[i][j-1][k]) * vm1);\n      }\n    }\n  }\n\n\n  j = 1;\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k]- dssp * \n\t  ( 5.0*u[m][i][j][k] - 4.0*u[m][i][j+1][k] +\n\t    u[m][i][j+2][k]);\n      }\n    }\n  }\n\n  j = 2;\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k] - dssp * \n\t  (-4.0*u[m][i][j-1][k] + 6.0*u[m][i][j][k] -\n\t   4.0*u[m][i][j+1][k] + u[m][i][j+2][k]);\n      }\n    }\n  }\n\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 3*1; j <= grid_points[1]-3*1-1; j++) {\n\tfor (k = 1; k <= grid_points[2]-2; k++) {\n\t  rhs[m][i][j][k] = rhs[m][i][j][k] - dssp * \n\t    (  u[m][i][j-2][k] - 4.0*u[m][i][j-1][k] + \n\t       6.0*u[m][i][j][k] - 4.0*u[m][i][j+1][k] + \n\t       u[m][i][j+2][k] );\n\t}\n      }\n    }\n  }\n \n  j = grid_points[1]-3;\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k] - dssp *\n\t  ( u[m][i][j-2][k] - 4.0*u[m][i][j-1][k] + \n\t    6.0*u[m][i][j][k] - 4.0*u[m][i][j+1][k] );\n      }\n    }\n  }\n\n  j = grid_points[1]-2;\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k] - dssp *\n\t  ( u[m][i][j-2][k] - 4.0*u[m][i][j-1][k] +\n\t    5.0*u[m][i][j][k] );\n      }\n    }\n  }\n#pragma omp barrier  \n\n#pragma omp for\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\twijk = ws[i][j][k];\n\twp1  = ws[i][j][k+1];\n\twm1  = ws[i][j][k-1];\n\n\trhs[0][i][j][k] = rhs[0][i][j][k] + dz1tz1 * \n\t  (u[0][i][j][k+1] - 2.0*u[0][i][j][k] + \n\t   u[0][i][j][k-1]) -\n\t  tz2 * (u[3][i][j][k+1] - u[3][i][j][k-1]);\n\trhs[1][i][j][k] = rhs[1][i][j][k] + dz2tz1 * \n\t  (u[1][i][j][k+1] - 2.0*u[1][i][j][k] + \n\t   u[1][i][j][k-1]) +\n\t  zzcon2 * (us[i][j][k+1] - 2.0*us[i][j][k] + \n\t\t    us[i][j][k-1]) -\n\t  tz2 * (u[1][i][j][k+1]*wp1 - \n\t\t u[1][i][j][k-1]*wm1);\n\trhs[2][i][j][k] = rhs[2][i][j][k] + dz3tz1 * \n\t  (u[2][i][j][k+1] - 2.0*u[2][i][j][k] + \n\t   u[2][i][j][k-1]) +\n\t  zzcon2 * (vs[i][j][k+1] - 2.0*vs[i][j][k] + \n\t\t    vs[i][j][k-1]) -\n\t  tz2 * (u[2][i][j][k+1]*wp1 - \n\t\t u[2][i][j][k-1]*wm1);\n\trhs[3][i][j][k] = rhs[3][i][j][k] + dz4tz1 * \n\t  (u[3][i][j][k+1] - 2.0*u[3][i][j][k] + \n\t   u[3][i][j][k-1]) +\n\t  zzcon2*con43 * (wp1 - 2.0*wijk + wm1) -\n\t  tz2 * (u[3][i][j][k+1]*wp1 - \n\t\t u[3][i][j][k-1]*wm1 +\n\t\t (u[4][i][j][k+1] - square[i][j][k+1] - \n\t\t  u[4][i][j][k-1] + square[i][j][k-1])\n\t\t *c2);\n\trhs[4][i][j][k] = rhs[4][i][j][k] + dz5tz1 * \n\t  (u[4][i][j][k+1] - 2.0*u[4][i][j][k] + \n\t   u[4][i][j][k-1]) +\n\t  zzcon3 * (qs[i][j][k+1] - 2.0*qs[i][j][k] + \n\t\t    qs[i][j][k-1]) +\n\t  zzcon4 * (wp1*wp1 - 2.0*wijk*wijk + \n\t\t    wm1*wm1) +\n\t  zzcon5 * (u[4][i][j][k+1]*rho_i[i][j][k+1] - \n\t\t    2.0*u[4][i][j][k]*rho_i[i][j][k] +\n\t\t    u[4][i][j][k-1]*rho_i[i][j][k-1]) -\n\t  tz2 * ( (c1*u[4][i][j][k+1] - \n\t\t   c2*square[i][j][k+1])*wp1 -\n\t\t  (c1*u[4][i][j][k-1] - \n\t\t   c2*square[i][j][k-1])*wm1);\n      }\n    }\n  }\n\n\n  k = 1;\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k]- dssp * \n\t  ( 5.0*u[m][i][j][k] - 4.0*u[m][i][j][k+1] +\n\t    u[m][i][j][k+2]);\n      }\n    }\n  }\n\n  k = 2;\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k] - dssp * \n\t  (-4.0*u[m][i][j][k-1] + 6.0*u[m][i][j][k] -\n\t   4.0*u[m][i][j][k+1] + u[m][i][j][k+2]);\n      }\n    }\n  }\n\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tfor (k = 3*1; k <= grid_points[2]-3*1-1; k++) {\n\t  rhs[m][i][j][k] = rhs[m][i][j][k] - dssp * \n\t    (  u[m][i][j][k-2] - 4.0*u[m][i][j][k-1] + \n\t       6.0*u[m][i][j][k] - 4.0*u[m][i][j][k+1] + \n\t       u[m][i][j][k+2] );\n\t}\n      }\n    }\n  }\n \n  k = grid_points[2]-3;\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k] - dssp *\n\t  ( u[m][i][j][k-2] - 4.0*u[m][i][j][k-1] + \n\t    6.0*u[m][i][j][k] - 4.0*u[m][i][j][k+1] );\n      }\n    }\n  }\n\n  k = grid_points[2]-2;\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k] - dssp *\n\t  ( u[m][i][j][k-2] - 4.0*u[m][i][j][k-1] +\n\t    5.0*u[m][i][j][k] );\n      }\n    }\n  }\n\n  for (m = 0; m < 5; m++) {\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tfor (k = 1; k <= grid_points[2]-2; k++) {\n\t  rhs[m][i][j][k] = rhs[m][i][j][k] * dt;\n\t}\n      }\n    }\n  }\n}    \n\n}\n\n\nstatic void set_constants(void) {\n\n\n  ce[0][0]  = 2.0;\n  ce[1][0]  = 0.0;\n  ce[2][0]  = 0.0;\n  ce[3][0]  = 4.0;\n  ce[4][0]  = 5.0;\n  ce[5][0]  = 3.0;\n  ce[6][0]  = 0.5;\n  ce[7][0]  = 0.02;\n  ce[8][0]  = 0.01;\n  ce[9][0] = 0.03;\n  ce[10][0] = 0.5;\n  ce[11][0] = 0.4;\n  ce[12][0] = 0.3;\n \n  ce[0][1]  = 1.0;\n  ce[1][1]  = 0.0;\n  ce[2][1]  = 0.0;\n  ce[3][1]  = 0.0;\n  ce[4][1]  = 1.0;\n  ce[5][1]  = 2.0;\n  ce[6][1]  = 3.0;\n  ce[7][1]  = 0.01;\n  ce[8][1]  = 0.03;\n  ce[9][1] = 0.02;\n  ce[10][1] = 0.4;\n  ce[11][1] = 0.3;\n  ce[12][1] = 0.5;\n\n  ce[0][2]  = 2.0;\n  ce[1][2]  = 2.0;\n  ce[2][2]  = 0.0;\n  ce[3][2]  = 0.0;\n  ce[4][2]  = 0.0;\n  ce[5][2]  = 2.0;\n  ce[6][2]  = 3.0;\n  ce[7][2]  = 0.04;\n  ce[8][2]  = 0.03;\n  ce[9][2] = 0.05;\n  ce[10][2] = 0.3;\n  ce[11][2] = 0.5;\n  ce[12][2] = 0.4;\n\n  ce[0][3]  = 2.0;\n  ce[1][3]  = 2.0;\n  ce[2][3]  = 0.0;\n  ce[3][3]  = 0.0;\n  ce[4][3]  = 0.0;\n  ce[5][3]  = 2.0;\n  ce[6][3]  = 3.0;\n  ce[7][3]  = 0.03;\n  ce[8][3]  = 0.05;\n  ce[9][3] = 0.04;\n  ce[10][3] = 0.2;\n  ce[11][3] = 0.1;\n  ce[12][3] = 0.3;\n\n  ce[0][4]  = 5.0;\n  ce[1][4]  = 4.0;\n  ce[2][4]  = 3.0;\n  ce[3][4]  = 2.0;\n  ce[4][4]  = 0.1;\n  ce[5][4]  = 0.4;\n  ce[6][4]  = 0.3;\n  ce[7][4]  = 0.05;\n  ce[8][4]  = 0.04;\n  ce[9][4] = 0.03;\n  ce[10][4] = 0.1;\n  ce[11][4] = 0.3;\n  ce[12][4] = 0.2;\n\n  c1 = 1.4;\n  c2 = 0.4;\n  c3 = 0.1;\n  c4 = 1.0;\n  c5 = 1.4;\n\n  bt = sqrt(0.5);\n\n  dnxm1 = 1.0 / (double)(grid_points[0]-1);\n  dnym1 = 1.0 / (double)(grid_points[1]-1);\n  dnzm1 = 1.0 / (double)(grid_points[2]-1);\n\n  c1c2 = c1 * c2;\n  c1c5 = c1 * c5;\n  c3c4 = c3 * c4;\n  c1345 = c1c5 * c3c4;\n\n  conz1 = (1.0-c1c5);\n\n  tx1 = 1.0 / (dnxm1 * dnxm1);\n  tx2 = 1.0 / (2.0 * dnxm1);\n  tx3 = 1.0 / dnxm1;\n\n  ty1 = 1.0 / (dnym1 * dnym1);\n  ty2 = 1.0 / (2.0 * dnym1);\n  ty3 = 1.0 / dnym1;\n \n  tz1 = 1.0 / (dnzm1 * dnzm1);\n  tz2 = 1.0 / (2.0 * dnzm1);\n  tz3 = 1.0 / dnzm1;\n\n  dx1 = 0.75;\n  dx2 = 0.75;\n  dx3 = 0.75;\n  dx4 = 0.75;\n  dx5 = 0.75;\n\n  dy1 = 0.75;\n  dy2 = 0.75;\n  dy3 = 0.75;\n  dy4 = 0.75;\n  dy5 = 0.75;\n\n  dz1 = 1.0;\n  dz2 = 1.0;\n  dz3 = 1.0;\n  dz4 = 1.0;\n  dz5 = 1.0;\n\n  dxmax = max(dx3, dx4);\n  dymax = max(dy2, dy4);\n  dzmax = max(dz2, dz3);\n\n  dssp = 0.25 * max(dx1, max(dy1, dz1) );\n\n  c4dssp = 4.0 * dssp;\n  c5dssp = 5.0 * dssp;\n\n  dttx1 = dt*tx1;\n  dttx2 = dt*tx2;\n  dtty1 = dt*ty1;\n  dtty2 = dt*ty2;\n  dttz1 = dt*tz1;\n  dttz2 = dt*tz2;\n\n  c2dttx1 = 2.0*dttx1;\n  c2dtty1 = 2.0*dtty1;\n  c2dttz1 = 2.0*dttz1;\n\n  dtdssp = dt*dssp;\n\n  comz1  = dtdssp;\n  comz4  = 4.0*dtdssp;\n  comz5  = 5.0*dtdssp;\n  comz6  = 6.0*dtdssp;\n\n  c3c4tx3 = c3c4*tx3;\n  c3c4ty3 = c3c4*ty3;\n  c3c4tz3 = c3c4*tz3;\n\n  dx1tx1 = dx1*tx1;\n  dx2tx1 = dx2*tx1;\n  dx3tx1 = dx3*tx1;\n  dx4tx1 = dx4*tx1;\n  dx5tx1 = dx5*tx1;\n        \n  dy1ty1 = dy1*ty1;\n  dy2ty1 = dy2*ty1;\n  dy3ty1 = dy3*ty1;\n  dy4ty1 = dy4*ty1;\n  dy5ty1 = dy5*ty1;\n        \n  dz1tz1 = dz1*tz1;\n  dz2tz1 = dz2*tz1;\n  dz3tz1 = dz3*tz1;\n  dz4tz1 = dz4*tz1;\n  dz5tz1 = dz5*tz1;\n\n  c2iv  = 2.5;\n  con43 = 4.0/3.0;\n  con16 = 1.0/6.0;\n        \n  xxcon1 = c3c4tx3*con43*tx3;\n  xxcon2 = c3c4tx3*tx3;\n  xxcon3 = c3c4tx3*conz1*tx3;\n  xxcon4 = c3c4tx3*con16*tx3;\n  xxcon5 = c3c4tx3*c1c5*tx3;\n\n  yycon1 = c3c4ty3*con43*ty3;\n  yycon2 = c3c4ty3*ty3;\n  yycon3 = c3c4ty3*conz1*ty3;\n  yycon4 = c3c4ty3*con16*ty3;\n  yycon5 = c3c4ty3*c1c5*ty3;\n\n  zzcon1 = c3c4tz3*con43*tz3;\n  zzcon2 = c3c4tz3*tz3;\n  zzcon3 = c3c4tz3*conz1*tz3;\n  zzcon4 = c3c4tz3*con16*tz3;\n  zzcon5 = c3c4tz3*c1c5*tz3;\n}\n\n\nstatic void txinvr(void) {\n\n\n\n  int i, j, k;\n  double t1, t2, t3, ac, ru1, uu, vv, ww, r1, r2, r3, \n    r4, r5, ac2inv;\n\n#pragma omp for  \n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\n\tru1 = rho_i[i][j][k];\n\tuu = us[i][j][k];\n\tvv = vs[i][j][k];\n\tww = ws[i][j][k];\n\tac = speed[i][j][k];\n\tac2inv = ainv[i][j][k]*ainv[i][j][k];\n\n\tr1 = rhs[0][i][j][k];\n\tr2 = rhs[1][i][j][k];\n\tr3 = rhs[2][i][j][k];\n\tr4 = rhs[3][i][j][k];\n\tr5 = rhs[4][i][j][k];\n\n\tt1 = c2 * ac2inv * ( qs[i][j][k]*r1 - uu*r2  - \n\t\t\t     vv*r3 - ww*r4 + r5 );\n\tt2 = bt * ru1 * ( uu * r1 - r2 );\n\tt3 = ( bt * ru1 * ac ) * t1;\n\n\trhs[0][i][j][k] = r1 - t1;\n\trhs[1][i][j][k] = - ru1 * ( ww*r1 - r4 );\n\trhs[2][i][j][k] =   ru1 * ( vv*r1 - r3 );\n\trhs[3][i][j][k] = - t2 + t3;\n\trhs[4][i][j][k] =   t2 + t3;\n      }\n    }\n  }\n}\n\n\nstatic void tzetar(void) {\n\n\n\n  int i, j, k;\n  double t1, t2, t3, ac, xvel, yvel, zvel, r1, r2, r3, \n    r4, r5, btuz, acinv, ac2u, uzik1;\n  \n#pragma omp for private(i,j,k,t1,t2,t3,ac,xvel,yvel,zvel,r1,r2,r3,r4,r5,btuz,ac2u,uzik1)\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\n\txvel = us[i][j][k];\n\tyvel = vs[i][j][k];\n\tzvel = ws[i][j][k];\n\tac   = speed[i][j][k];\n\tacinv = ainv[i][j][k];\n\n\tac2u = ac*ac;\n\n\tr1 = rhs[0][i][j][k];\n\tr2 = rhs[1][i][j][k];\n\tr3 = rhs[2][i][j][k];\n\tr4 = rhs[3][i][j][k];\n\tr5 = rhs[4][i][j][k];\n\n\tuzik1 = u[0][i][j][k];\n\tbtuz  = bt * uzik1;\n\n\tt1 = btuz*acinv * (r4 + r5);\n\tt2 = r3 + t1;\n\tt3 = btuz * (r4 - r5);\n\n\trhs[0][i][j][k] = t2;\n\trhs[1][i][j][k] = -uzik1*r2 + xvel*t2;\n\trhs[2][i][j][k] =  uzik1*r1 + yvel*t2;\n\trhs[3][i][j][k] =  zvel*t2  + t3;\n\trhs[4][i][j][k] =  uzik1*(-xvel*r2 + yvel*r1) + \n\t  qs[i][j][k]*t2 + c2iv*ac2u*t1 + zvel*t3;\n      }\n    }\n  }\n}\n\n\n\nstatic void verify(int no_time_steps, char *class, boolean *verified) {\n\n\n\n  double xcrref[5],xceref[5],xcrdif[5],xcedif[5], \n    epsilon, xce[5], xcr[5], dtref;\n  int m;\n\n  epsilon = 1.0e-08;\n\n\n  error_norm(xce);\n  compute_rhs();\n\n  rhs_norm(xcr);\n\n  for (m = 0; m < 5; m++) {\n    xcr[m] = xcr[m] / dt;\n  }\n\n  *class = 'U';\n  *verified = TRUE;\n\n  for (m = 0; m < 5; m++) {\n    xcrref[m] = 1.0;\n    xceref[m] = 1.0;\n  }\n\n  if ( grid_points[0] == 12 &&\n       grid_points[1] == 12 &&\n       grid_points[2] == 12 &&\n       no_time_steps == 100) {\n\n    *class = 'S';\n    dtref = 1.5e-2;\n\n    xcrref[0] = 2.7470315451339479e-02;\n    xcrref[1] = 1.0360746705285417e-02;\n    xcrref[2] = 1.6235745065095532e-02;\n    xcrref[3] = 1.5840557224455615e-02;\n    xcrref[4] = 3.4849040609362460e-02;\n\n    xceref[0] = 2.7289258557377227e-05;\n    xceref[1] = 1.0364446640837285e-05;\n    xceref[2] = 1.6154798287166471e-05;\n    xceref[3] = 1.5750704994480102e-05;\n    xceref[4] = 3.4177666183390531e-05;\n\n\n  } else if (grid_points[0] == 36 &&\n\t     grid_points[1] == 36 &&\n\t     grid_points[2] == 36 &&\n\t     no_time_steps == 400) {\n\n    *class = 'W';\n    dtref = 1.5e-3;\n\n    xcrref[0] = 0.1893253733584e-02;\n    xcrref[1] = 0.1717075447775e-03;\n    xcrref[2] = 0.2778153350936e-03;\n    xcrref[3] = 0.2887475409984e-03;\n    xcrref[4] = 0.3143611161242e-02;\n\n    xceref[0] = 0.7542088599534e-04;\n    xceref[1] = 0.6512852253086e-05;\n    xceref[2] = 0.1049092285688e-04;\n    xceref[3] = 0.1128838671535e-04;\n    xceref[4] = 0.1212845639773e-03;\n\n  } else if (grid_points[0] == 64 &&\n\t     grid_points[1] == 64 &&\n\t     grid_points[2] == 64 &&\n\t     no_time_steps == 400 ) {\n\n    *class = 'A';\n    dtref = 1.5e-3;\n\n    xcrref[0] = 2.4799822399300195;\n    xcrref[1] = 1.1276337964368832;\n    xcrref[2] = 1.5028977888770491;\n    xcrref[3] = 1.4217816211695179;\n    xcrref[4] = 2.1292113035138280;\n\n    xceref[0] = 1.0900140297820550e-04;\n    xceref[1] = 3.7343951769282091e-05;\n    xceref[2] = 5.0092785406541633e-05;\n    xceref[3] = 4.7671093939528255e-05;\n    xceref[4] = 1.3621613399213001e-04;\n\n  } else if (grid_points[0] == 102 &&\n\t     grid_points[1] == 102 &&\n\t     grid_points[2] == 102 &&\n\t     no_time_steps == 400) {\n\n    *class = 'B';\n    dtref = 1.0e-3;\n\n    xcrref[0] = 0.6903293579998e+02;\n    xcrref[1] = 0.3095134488084e+02;\n    xcrref[2] = 0.4103336647017e+02;\n    xcrref[3] = 0.3864769009604e+02;\n    xcrref[4] = 0.5643482272596e+02;\n\n    xceref[0] = 0.9810006190188e-02;\n    xceref[1] = 0.1022827905670e-02;\n    xceref[2] = 0.1720597911692e-02;\n    xceref[3] = 0.1694479428231e-02;\n    xceref[4] = 0.1847456263981e-01;\n\n\n  } else if (grid_points[0] == 162 &&\n\t     grid_points[1] == 162 &&\n\t     grid_points[2] == 162 &&\n\t     no_time_steps == 400) {\n\n    *class = 'C';\n    dtref = 0.67e-3;\n\n    xcrref[0] = 0.5881691581829e+03;\n    xcrref[1] = 0.2454417603569e+03;\n    xcrref[2] = 0.3293829191851e+03;\n    xcrref[3] = 0.3081924971891e+03;\n    xcrref[4] = 0.4597223799176e+03;\n\n    xceref[0] = 0.2598120500183e+00;\n    xceref[1] = 0.2590888922315e-01;\n    xceref[2] = 0.5132886416320e-01;\n    xceref[3] = 0.4806073419454e-01;\n    xceref[4] = 0.5483377491301e+00;\n    \n  } else {\n    *verified = FALSE;\n  }\n\n\n  for (m = 0; m < 5; m++) {\n           \n    xcrdif[m] = fabs((xcr[m]-xcrref[m])/xcrref[m]) ;\n    xcedif[m] = fabs((xce[m]-xceref[m])/xceref[m]);\n           \n  }\n\n\n  if (*class != 'U') {\n    printf(\" Verification being performed for class %1c\\n\", *class);\n    printf(\" accuracy setting for epsilon = %20.13e\\n\", epsilon);\n    \n    if (fabs(dt-dtref) > epsilon) {\n      *verified = FALSE;\n      *class = 'U';\n      printf(\" DT does not match the reference value of %15.8e\\n\", dtref);\n    }\n  } else {\n    printf(\" Unknown class\\n\");\n  }\n\n  if (*class != 'U') {\n    printf(\" Comparison of RMS-norms of residual\\n\");\n  } else {\n    printf(\" RMS-norms of residual\\n\");\n  }\n\n  for (m = 0; m < 5; m++) {\n    if (*class == 'U') {\n      printf(\"          %2d%20.13e\\n\", m, xcr[m]);\n    } else if (xcrdif[m] > epsilon) {\n      *verified = FALSE;\n      printf(\" FAILURE: %2d%20.13e%20.13e%20.13e\\n\",\n\t     m,xcr[m],xcrref[m],xcrdif[m]);\n    } else {\n      printf(\"          %2d%20.13e%20.13e%20.13e\\n\",\n\t     m,xcr[m],xcrref[m],xcrdif[m]);\n    }\n  }\n\n  if (*class != 'U') {\n    printf(\" Comparison of RMS-norms of solution error\\n\");\n  } else {\n    printf(\" RMS-norms of solution error\\n\");\n  }\n        \n  for (m = 0; m < 5; m++) {\n    if (*class == 'U') {\n      printf(\"          %2d%20.13e\\n\", m, xce[m]);\n    } else if (xcedif[m] > epsilon) {\n      *verified = FALSE;\n      printf(\" FAILURE: %2d%20.13e%20.13e%20.13e\\n\",\n\t     m,xce[m],xceref[m],xcedif[m]);\n    } else {\n      printf(\"          %2d%20.13e%20.13e%20.13e\\n\",\n\t     m,xce[m],xceref[m],xcedif[m]);\n    }\n  }\n        \n  if (*class == 'U') {\n    printf(\" No reference values provided\\n\");\n    printf(\" No verification performed\\n\");\n  } else if (*verified) {\n    printf(\" Verification Successful\\n\");\n  } else {\n    printf(\" Verification failed\\n\");\n  }\n}\n\n\nstatic void x_solve(void) {\n\n#pragma omp parallel\n{\n\n\n\n  int i, j, k, n, i1, i2, m;\n  double fac1, fac2;\n\n  lhsx();\n\n  n = 0;\n  for (i = 0; i <= grid_points[0]-3; i++) {\n    i1 = i  + 1;\n    i2 = i  + 2;\n#pragma omp for\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tfac1               = 1./lhs[n+2][i][j][k];\n\tlhs[n+3][i][j][k]   = fac1*lhs[n+3][i][j][k];\n\tlhs[n+4][i][j][k]   = fac1*lhs[n+4][i][j][k];\n\tfor (m = 0; m < 3; m++) {\n\t  rhs[m][i][j][k] = fac1*rhs[m][i][j][k];\n\t}\n\tlhs[n+2][i1][j][k] = lhs[n+2][i1][j][k] -\n\t  lhs[n+1][i1][j][k]*lhs[n+3][i][j][k];\n\tlhs[n+3][i1][j][k] = lhs[n+3][i1][j][k] -\n\t  lhs[n+1][i1][j][k]*lhs[n+4][i][j][k];\n\tfor (m = 0; m < 3; m++) {\n\t  rhs[m][i1][j][k] = rhs[m][i1][j][k] -\n\t    lhs[n+1][i1][j][k]*rhs[m][i][j][k];\n\t}\n\tlhs[n+1][i2][j][k] = lhs[n+1][i2][j][k] -\n\t  lhs[n+0][i2][j][k]*lhs[n+3][i][j][k];\n\tlhs[n+2][i2][j][k] = lhs[n+2][i2][j][k] -\n\t  lhs[n+0][i2][j][k]*lhs[n+4][i][j][k];\n\tfor (m = 0; m < 3; m++) {\n\t  rhs[m][i2][j][k] = rhs[m][i2][j][k] -\n\t    lhs[n+0][i2][j][k]*rhs[m][i][j][k];\n\t}\n      }\n    }\n  }\n\n\n  i  = grid_points[0]-2;\n  i1 = grid_points[0]-1;\n#pragma omp for\n  for (j = 1; j <= grid_points[1]-2; j++) {\n    for (k = 1; k <= grid_points[2]-2; k++) {\n      fac1               = 1.0/lhs[n+2][i][j][k];\n      lhs[n+3][i][j][k]   = fac1*lhs[n+3][i][j][k];\n      lhs[n+4][i][j][k]   = fac1*lhs[n+4][i][j][k];\n      for (m = 0; m < 3; m++) {\n\trhs[m][i][j][k] = fac1*rhs[m][i][j][k];\n      }\n      lhs[n+2][i1][j][k] = lhs[n+2][i1][j][k] -\n\tlhs[n+1][i1][j][k]*lhs[n+3][i][j][k];\n      lhs[n+3][i1][j][k] = lhs[n+3][i1][j][k] -\n\tlhs[n+1][i1][j][k]*lhs[n+4][i][j][k];\n      for (m = 0; m < 3; m++) {\n\trhs[m][i1][j][k] = rhs[m][i1][j][k] -\n\t  lhs[n+1][i1][j][k]*rhs[m][i][j][k];\n      }\n\n      fac2               = 1./lhs[n+2][i1][j][k];\n      for (m = 0; m < 3; m++) {\n\trhs[m][i1][j][k] = fac2*rhs[m][i1][j][k];\n      }\n    }\n  }\n\n\n  for (m = 3; m < 5; m++) {\n    n = (m-3+1)*5;\n    for (i = 0; i <= grid_points[0]-3; i++) {\n      i1 = i  + 1;\n      i2 = i  + 2;\n#pragma omp for\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tfor (k = 1; k <= grid_points[2]-2; k++) {\n\t  fac1               = 1./lhs[n+2][i][j][k];\n\t  lhs[n+3][i][j][k]   = fac1*lhs[n+3][i][j][k];\n\t  lhs[n+4][i][j][k]   = fac1*lhs[n+4][i][j][k];\n\t  rhs[m][i][j][k] = fac1*rhs[m][i][j][k];\n\t  lhs[n+2][i1][j][k] = lhs[n+2][i1][j][k] -\n\t    lhs[n+1][i1][j][k]*lhs[n+3][i][j][k];\n\t  lhs[n+3][i1][j][k] = lhs[n+3][i1][j][k] -\n\t    lhs[n+1][i1][j][k]*lhs[n+4][i][j][k];\n\t  rhs[m][i1][j][k] = rhs[m][i1][j][k] -\n\t    lhs[n+1][i1][j][k]*rhs[m][i][j][k];\n\t  lhs[n+1][i2][j][k] = lhs[n+1][i2][j][k] -\n\t    lhs[n+0][i2][j][k]*lhs[n+3][i][j][k];\n\t  lhs[n+2][i2][j][k] = lhs[n+2][i2][j][k] -\n\t    lhs[n+0][i2][j][k]*lhs[n+4][i][j][k];\n\t  rhs[m][i2][j][k] = rhs[m][i2][j][k] -\n\t    lhs[n+0][i2][j][k]*rhs[m][i][j][k];\n\t}\n      }\n    }\n\n    i  = grid_points[0]-2;\n    i1 = grid_points[0]-1;\n    \n#pragma omp for\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tfac1               = 1./lhs[n+2][i][j][k];\n\tlhs[n+3][i][j][k]   = fac1*lhs[n+3][i][j][k];\n\tlhs[n+4][i][j][k]   = fac1*lhs[n+4][i][j][k];\n\trhs[m][i][j][k]     = fac1*rhs[m][i][j][k];\n\tlhs[n+2][i1][j][k] = lhs[n+2][i1][j][k] -\n\t  lhs[n+1][i1][j][k]*lhs[n+3][i][j][k];\n\tlhs[n+3][i1][j][k] = lhs[n+3][i1][j][k] -\n\t  lhs[n+1][i1][j][k]*lhs[n+4][i][j][k];\n\trhs[m][i1][j][k]   = rhs[m][i1][j][k] -\n\t  lhs[n+1][i1][j][k]*rhs[m][i][j][k];\n\tfac2               = 1./lhs[n+2][i1][j][k];\n\trhs[m][i1][j][k]   = fac2*rhs[m][i1][j][k];\n\n      }\n    }\n  }\n\n\n  i  = grid_points[0]-2;\n  i1 = grid_points[0]-1;\n  n = 0;\n  for (m = 0; m < 3; m++) {\n#pragma omp for\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k] -\n\t  lhs[n+3][i][j][k]*rhs[m][i1][j][k];\n      }\n    }\n  }\n\n  for (m = 3; m < 5; m++) {\n#pragma omp for\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tn = (m-3+1)*5;\n\trhs[m][i][j][k] = rhs[m][i][j][k] -\n\t  lhs[n+3][i][j][k]*rhs[m][i1][j][k];\n      }\n    }\n  }\n\n  n = 0;\n  for (i = grid_points[0]-3; i >= 0; i--) {\n    i1 = i  + 1;\n    i2 = i  + 2;\n#pragma omp for\n    for (m = 0; m < 3; m++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tfor (k = 1; k <= grid_points[2]-2; k++) {\n\t  rhs[m][i][j][k] = rhs[m][i][j][k] - \n\t    lhs[n+3][i][j][k]*rhs[m][i1][j][k] -\n\t    lhs[n+4][i][j][k]*rhs[m][i2][j][k];\n\t}\n      }\n    }\n  }\n\n  for (m = 3; m < 5; m++) {\n    n = (m-3+1)*5;\n    for (i = grid_points[0]-3; i >= 0; i--) {\n      i1 = i  + 1;\n      i2 = i  + 2;\n#pragma omp for\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tfor (k = 1; k <= grid_points[2]-2; k++) {\n\t  rhs[m][i][j][k] = rhs[m][i][j][k] - \n\t    lhs[n+3][i][j][k]*rhs[m][i1][j][k] -\n\t    lhs[n+4][i][j][k]*rhs[m][i2][j][k];\n\t}\n      }\n    }\n  }\n\n}\n\n  ninvr();\n}\n\n\nstatic void y_solve(void) {\n\n#pragma omp parallel\n{\n\n\n\n  int i, j, k, n, j1, j2, m;\n  double fac1, fac2;\n\n  lhsy();\n\n  n = 0;\n\n  for (j = 0; j <= grid_points[1]-3; j++) {\n    j1 = j  + 1;\n    j2 = j  + 2;\n#pragma omp for      \n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tfac1               = 1./lhs[n+2][i][j][k];\n\tlhs[n+3][i][j][k]   = fac1*lhs[n+3][i][j][k];\n\tlhs[n+4][i][j][k]   = fac1*lhs[n+4][i][j][k];\n        for (m = 0; m < 3; m++) {\n\t  rhs[m][i][j][k] = fac1*rhs[m][i][j][k];\n\t}\n\tlhs[n+2][i][j1][k] = lhs[n+2][i][j1][k] -\n\t  lhs[n+1][i][j1][k]*lhs[n+3][i][j][k];\n\tlhs[n+3][i][j1][k] = lhs[n+3][i][j1][k] -\n\t  lhs[n+1][i][j1][k]*lhs[n+4][i][j][k];\n\tfor (m = 0; m < 3; m++) {\n\t  rhs[m][i][j1][k] = rhs[m][i][j1][k] -\n\t    lhs[n+1][i][j1][k]*rhs[m][i][j][k];\n\t}\n\tlhs[n+1][i][j2][k] = lhs[n+1][i][j2][k] -\n\t  lhs[n+0][i][j2][k]*lhs[n+3][i][j][k];\n\tlhs[n+2][i][j2][k] = lhs[n+2][i][j2][k] -\n\t  lhs[n+0][i][j2][k]*lhs[n+4][i][j][k];\n\tfor (m = 0; m < 3; m++) {\n\t  rhs[m][i][j2][k] = rhs[m][i][j2][k] -\n\t    lhs[n+0][i][j2][k]*rhs[m][i][j][k];\n\t}\n      }\n    }\n  }\n\n\n  j  = grid_points[1]-2;\n  j1 = grid_points[1]-1;\n#pragma omp for      \n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (k = 1; k <= grid_points[2]-2; k++) {\n      fac1               = 1./lhs[n+2][i][j][k];\n      lhs[n+3][i][j][k]   = fac1*lhs[n+3][i][j][k];\n      lhs[n+4][i][j][k]   = fac1*lhs[n+4][i][j][k];\n      for (m = 0; m < 3; m++) {\n\trhs[m][i][j][k] = fac1*rhs[m][i][j][k];\n      }\n      lhs[n+2][i][j1][k] = lhs[n+2][i][j1][k] -\n\tlhs[n+1][i][j1][k]*lhs[n+3][i][j][k];\n      lhs[n+3][i][j1][k] = lhs[n+3][i][j1][k] -\n\tlhs[n+1][i][j1][k]*lhs[n+4][i][j][k];\n      for (m = 0; m < 3; m++) {\n\trhs[m][i][j1][k] = rhs[m][i][j1][k] -\n\t  lhs[n+1][i][j1][k]*rhs[m][i][j][k];\n      }\n      fac2               = 1./lhs[n+2][i][j1][k];\n      for (m = 0; m < 3; m++) {\n\trhs[m][i][j1][k] = fac2*rhs[m][i][j1][k];\n      }\n    }\n  }\n\n  for (m = 3; m < 5; m++) {\n    n = (m-3+1)*5;\n    for (j = 0; j <= grid_points[1]-3; j++) {\n      j1 = j  + 1;\n      j2 = j  + 2;\n#pragma omp for      \n      for (i = 1; i <= grid_points[0]-2; i++) {\n\tfor (k = 1; k <= grid_points[2]-2; k++) {\n\t  fac1               = 1./lhs[n+2][i][j][k];\n\t  lhs[n+3][i][j][k]   = fac1*lhs[n+3][i][j][k];\n\t  lhs[n+4][i][j][k]   = fac1*lhs[n+4][i][j][k];\n\t  rhs[m][i][j][k] = fac1*rhs[m][i][j][k];\n\t  lhs[n+2][i][j1][k] = lhs[n+2][i][j1][k] -\n\t    lhs[n+1][i][j1][k]*lhs[n+3][i][j][k];\n\t  lhs[n+3][i][j1][k] = lhs[n+3][i][j1][k] -\n\t    lhs[n+1][i][j1][k]*lhs[n+4][i][j][k];\n\t  rhs[m][i][j1][k] = rhs[m][i][j1][k] -\n\t    lhs[n+1][i][j1][k]*rhs[m][i][j][k];\n\t  lhs[n+1][i][j2][k] = lhs[n+1][i][j2][k] -\n\t    lhs[n+0][i][j2][k]*lhs[n+3][i][j][k];\n\t  lhs[n+2][i][j2][k] = lhs[n+2][i][j2][k] -\n\t    lhs[n+0][i][j2][k]*lhs[n+4][i][j][k];\n\t  rhs[m][i][j2][k] = rhs[m][i][j2][k] -\n\t    lhs[n+0][i][j2][k]*rhs[m][i][j][k];\n\t}\n      }\n    }\n\n    j  = grid_points[1]-2;\n    j1 = grid_points[1]-1;\n#pragma omp for      \n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tfac1               = 1./lhs[n+2][i][j][k];\n\tlhs[n+3][i][j][k]   = fac1*lhs[n+3][i][j][k];\n\tlhs[n+4][i][j][k]   = fac1*lhs[n+4][i][j][k];\n\trhs[m][i][j][k]     = fac1*rhs[m][i][j][k];\n\tlhs[n+2][i][j1][k] = lhs[n+2][i][j1][k] -\n\t  lhs[n+1][i][j1][k]*lhs[n+3][i][j][k];\n\tlhs[n+3][i][j1][k] = lhs[n+3][i][j1][k] -\n\t  lhs[n+1][i][j1][k]*lhs[n+4][i][j][k];\n\trhs[m][i][j1][k]   = rhs[m][i][j1][k] -\n\t  lhs[n+1][i][j1][k]*rhs[m][i][j][k];\n\tfac2               = 1./lhs[n+2][i][j1][k];\n\trhs[m][i][j1][k]   = fac2*rhs[m][i][j1][k];\n      }\n    }\n  }\n\n\n  j  = grid_points[1]-2;\n  j1 = grid_points[1]-1;\n  n = 0;\n  for (m = 0; m < 3; m++) {\n#pragma omp for      \n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k] -\n\t  lhs[n+3][i][j][k]*rhs[m][i][j1][k];\n      }\n    }\n  }\n\n  for (m = 3; m < 5; m++) {\n#pragma omp for      \n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (k = 1; k <= grid_points[2]-2; k++) {\n\tn = (m-3+1)*5;\n\trhs[m][i][j][k] = rhs[m][i][j][k] -\n\t  lhs[n+3][i][j][k]*rhs[m][i][j1][k];\n      }\n    }\n  }\n\n  n = 0;\n  for (m = 0; m < 3; m++) {\n    for (j = grid_points[1]-3; j >= 0; j--) {\n      j1 = j  + 1;\n      j2 = j  + 2;\n#pragma omp for      \n      for (i = 1; i <= grid_points[0]-2; i++) {\n\tfor (k = 1; k <= grid_points[2]-2; k++) {\n\t  rhs[m][i][j][k] = rhs[m][i][j][k] - \n\t    lhs[n+3][i][j][k]*rhs[m][i][j1][k] -\n\t    lhs[n+4][i][j][k]*rhs[m][i][j2][k];\n\t}\n      }\n    }\n  }\n\n  for (m = 3; m < 5; m++) {\n    n = (m-3+1)*5;\n    for (j = grid_points[1]-3; j >= 0; j--) {\n      j1 = j  + 1;\n      j2 = j1 + 1;\n#pragma omp for      \n      for (i = 1; i <= grid_points[0]-2; i++) {\n\tfor (k = 1; k <= grid_points[2]-2; k++) {\n\t  rhs[m][i][j][k] = rhs[m][i][j][k] - \n\t    lhs[n+3][i][j][k]*rhs[m][i][j1][k] -\n\t    lhs[n+4][i][j][k]*rhs[m][i][j2][k];\n\t}\n      }\n    }\n  }\n\n}\n\n  pinvr();\n}\n\n\nstatic void z_solve(void) {\n\n#pragma omp parallel\n{\n\n\n\n  int i, j, k, n, k1, k2, m;\n  double fac1, fac2;\n\n\n  lhsz();\n\n  n = 0;\n\n#pragma omp for\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      for (k = 0; k <= grid_points[2]-3; k++) {\n\tk1 = k  + 1;\n\tk2 = k  + 2;\n\tfac1               = 1./lhs[n+2][i][j][k];\n\tlhs[n+3][i][j][k]   = fac1*lhs[n+3][i][j][k];\n\tlhs[n+4][i][j][k]   = fac1*lhs[n+4][i][j][k];\n\tfor (m = 0; m < 3; m++) {\n\t  rhs[m][i][j][k] = fac1*rhs[m][i][j][k];\n\t}\n\tlhs[n+2][i][j][k1] = lhs[n+2][i][j][k1] -\n\t  lhs[n+1][i][j][k1]*lhs[n+3][i][j][k];\n\tlhs[n+3][i][j][k1] = lhs[n+3][i][j][k1] -\n\t  lhs[n+1][i][j][k1]*lhs[n+4][i][j][k];\n\tfor (m = 0; m < 3; m++) {\n\t  rhs[m][i][j][k1] = rhs[m][i][j][k1] -\n\t    lhs[n+1][i][j][k1]*rhs[m][i][j][k];\n\t}\n\tlhs[n+1][i][j][k2] = lhs[n+1][i][j][k2] -\n\t  lhs[n+0][i][j][k2]*lhs[n+3][i][j][k];\n\tlhs[n+2][i][j][k2] = lhs[n+2][i][j][k2] -\n\t  lhs[n+0][i][j][k2]*lhs[n+4][i][j][k];\n\tfor (m = 0; m < 3; m++) {\n\t  rhs[m][i][j][k2] = rhs[m][i][j][k2] -\n\t    lhs[n+0][i][j][k2]*rhs[m][i][j][k];\n\t}\n      }\n    }\n  }\n\n  k  = grid_points[2]-2;\n  k1 = grid_points[2]-1;\n#pragma omp for\n  for (i = 1; i <= grid_points[0]-2; i++) {\n    for (j = 1; j <= grid_points[1]-2; j++) {\n      fac1               = 1./lhs[n+2][i][j][k];\n      lhs[n+3][i][j][k]   = fac1*lhs[n+3][i][j][k];\n      lhs[n+4][i][j][k]   = fac1*lhs[n+4][i][j][k];\n      for (m = 0; m < 3; m++) {\n\trhs[m][i][j][k] = fac1*rhs[m][i][j][k];\n      }\n      lhs[n+2][i][j][k1] = lhs[n+2][i][j][k1] -\n\tlhs[n+1][i][j][k1]*lhs[n+3][i][j][k];\n      lhs[n+3][i][j][k1] = lhs[n+3][i][j][k1] -\n\tlhs[n+1][i][j][k1]*lhs[n+4][i][j][k];\n      for (m = 0; m < 3; m++) {\n\trhs[m][i][j][k1] = rhs[m][i][j][k1] -\n\t  lhs[n+1][i][j][k1]*rhs[m][i][j][k];\n      }\n\n      fac2               = 1./lhs[n+2][i][j][k1];\n      for (m = 0; m < 3; m++) {\n\trhs[m][i][j][k1] = fac2*rhs[m][i][j][k1];\n      }\n    }\n  }\n\n  for (m = 3; m < 5; m++) {\n    n = (m-3+1)*5;\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tfor (k = 0; k <= grid_points[2]-3; k++) {\n\tk1 = k  + 1;\n\tk2 = k  + 2;\n\t  fac1               = 1./lhs[n+2][i][j][k];\n\t  lhs[n+3][i][j][k]   = fac1*lhs[n+3][i][j][k];\n\t  lhs[n+4][i][j][k]   = fac1*lhs[n+4][i][j][k];\n\t  rhs[m][i][j][k] = fac1*rhs[m][i][j][k];\n\t  lhs[n+2][i][j][k1] = lhs[n+2][i][j][k1] -\n\t    lhs[n+1][i][j][k1]*lhs[n+3][i][j][k];\n\t  lhs[n+3][i][j][k1] = lhs[n+3][i][j][k1] -\n\t    lhs[n+1][i][j][k1]*lhs[n+4][i][j][k];\n\t  rhs[m][i][j][k1] = rhs[m][i][j][k1] -\n\t    lhs[n+1][i][j][k1]*rhs[m][i][j][k];\n\t  lhs[n+1][i][j][k2] = lhs[n+1][i][j][k2] -\n\t    lhs[n+0][i][j][k2]*lhs[n+3][i][j][k];\n\t  lhs[n+2][i][j][k2] = lhs[n+2][i][j][k2] -\n\t    lhs[n+0][i][j][k2]*lhs[n+4][i][j][k];\n\t  rhs[m][i][j][k2] = rhs[m][i][j][k2] -\n\t    lhs[n+0][i][j][k2]*rhs[m][i][j][k];\n\t}\n      }\n    }\n\n    k  = grid_points[2]-2;\n    k1 = grid_points[2]-1;\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tfac1               = 1./lhs[n+2][i][j][k];\n\tlhs[n+3][i][j][k]   = fac1*lhs[n+3][i][j][k];\n\tlhs[n+4][i][j][k]   = fac1*lhs[n+4][i][j][k];\n\trhs[m][i][j][k]     = fac1*rhs[m][i][j][k];\n\tlhs[n+2][i][j][k1] = lhs[n+2][i][j][k1] -\n\t  lhs[n+1][i][j][k1]*lhs[n+3][i][j][k];\n\tlhs[n+3][i][j][k1] = lhs[n+3][i][j][k1] -\n\t  lhs[n+1][i][j][k1]*lhs[n+4][i][j][k];\n\trhs[m][i][j][k1]   = rhs[m][i][j][k1] -\n\t  lhs[n+1][i][j][k1]*rhs[m][i][j][k];\n\tfac2               = 1./lhs[n+2][i][j][k1];\n\trhs[m][i][j][k1]   = fac2*rhs[m][i][j][k1];\n\n      }\n    }\n  }\n\n\n  k  = grid_points[2]-2;\n  k1 = grid_points[2]-1;\n  n = 0;\n  for (m = 0; m < 3; m++) {\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k] -\n\t  lhs[n+3][i][j][k]*rhs[m][i][j][k1];\n      }\n    }\n  }\n\n  for (m = 3; m < 5; m++) {\n    n = (m-3+1)*5;\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\trhs[m][i][j][k] = rhs[m][i][j][k] -\n\t  lhs[n+3][i][j][k]*rhs[m][i][j][k1];\n      }\n    }\n  }\n\n\n  n = 0;\n  for (m = 0; m < 3; m++) {\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tfor (k = grid_points[2]-3; k >= 0; k--) {\n\t  k1 = k  + 1;\n\t  k2 = k  + 2;\n\t  rhs[m][i][j][k] = rhs[m][i][j][k] - \n\t    lhs[n+3][i][j][k]*rhs[m][i][j][k1] -\n\t    lhs[n+4][i][j][k]*rhs[m][i][j][k2];\n\t}\n      }\n    }\n  }\n\n  for (m = 3; m < 5; m++) {\n    n = (m-3+1)*5;\n#pragma omp for\n    for (i = 1; i <= grid_points[0]-2; i++) {\n      for (j = 1; j <= grid_points[1]-2; j++) {\n\tfor (k = grid_points[2]-3; k >= 0; k--) {\n\t  k1 = k  + 1;\n\t  k2 = k  + 2;\n\t  rhs[m][i][j][k] = rhs[m][i][j][k] - \n\t    lhs[n+3][i][j][k]*rhs[m][i][j][k1] -\n\t    lhs[n+4][i][j][k]*rhs[m][i][j][k2];\n\t}\n      }\n    }\n  }\n\n}\n\n  tzetar();\n}\n"}, {"prompt": "\n#include \"npb-C.h\"\n#include \"npbparams.h\"\n\nint main(int argc, char **argv) {\n\n    double Mops, t1, t2, t3, t4, x1, x2, sx, sy, tm, an, tt, gc;\n    double dum[3] = { 1.0, 1.0, 1.0 };\n    int np, ierr, node, no_nodes, i, ik, kk, l, k, nit, ierrcode,\n\tno_large_nodes, np_add, k_offset, j;\n    int nthreads = 1;\n    boolean verified;\n    char size[13+1];\t/* character*13 */\n    char size[13+1];\t/* character*13 */\n\n\n    printf(\"\\n\\n NAS Parallel Benchmarks 3.0 structured OpenMP C version\"\n\t   \" - EP Benchmark\\n\");\n    sprintf(size, \"%12.0f\", pow(2.0, M+1));\n    for (j = 13; j >= 1; j--) {\n\tif (size[j] == '.') size[j] = ' ';\n    }\n    printf(\" Number of random numbers generated: %13s\\n\", size);\n\n    verified = FALSE;\n\n    np = NN;\n\n    vranlc(0, &(dum[0]), dum[1], &(dum[2]));\n    dum[0] = randlc(&(dum[1]), dum[2]);\n    \n#pragma omp parallel for default(shared) private(i)\n    for (i = 0; i < 2*NK; i++) x[i] = -1.0e99;\n    \n    Mops = log(sqrt(fabs(max(1.0, 1.0))));\n\n    timer_clear(1);\n    timer_clear(2);\n    timer_clear(3);\n    timer_start(1);\n\n    vranlc(0, &t1, A, x);\n\n    k_offset = -1;\n\n#pragma omp parallel copyin(x)\n{\n    double t1, t2, t3, t4, x1, x2;\n    int kk, i, ik, l;\n    double qq[NQ];\t\t/* private copy of q[0:NQ-1] */\n    double qq[NQ];\t\t/* private copy of q[0:NQ-1] */\n\n    for (i = 0; i < NQ; i++) qq[i] = 0.0;\n\n#pragma omp for reduction(+:sx,sy) schedule(static)  \n    for (k = 1; k <= np; k++) {\n\tkk = k_offset + k;\n\tt1 = S;\n\tt2 = an;\n\n\tif (TIMERS_ENABLED == TRUE) timer_start(2);\n\n\tfor ( i = 0; i < NK; i++) {\n            x1 = 2.0 * x[2*i] - 1.0;\n            x2 = 2.0 * x[2*i+1] - 1.0;\n            t1 = pow2(x1) + pow2(x2);\n            if (t1 <= 1.0) {\n\t\tt2 = sqrt(-2.0 * log(t1) / t1);\n\t\tt3 = (x1 * t2);\t\t\t\t/* Xi */\n\t\tt3 = (x1 * t2);\t\t\t\t/* Xi */\n\t\tt4 = (x2 * t2);\t\t\t\t/* Yi */\n\t\tt4 = (x2 * t2);\t\t\t\t/* Yi */\n\t\tl = max(fabs(t3), fabs(t4));\n\t\tqq[l] += 1.0;\t\t\t\t/* counts */\n\t\tqq[l] += 1.0;\t\t\t\t/* counts */\n\t\tsx = sx + t3;\t\t\t\t/* sum of Xi */\n\t\tsx = sx + t3;\t\t\t\t/* sum of Xi */\n\t\tsy = sy + t4;\t\t\t\t/* sum of Yi */\n\t\tsy = sy + t4;\t\t\t\t/* sum of Yi */\n            }\n\t}\n\tif (TIMERS_ENABLED == TRUE) timer_stop(2);\n    }\n#pragma omp critical\n    {\n      for (i = 0; i <= NQ - 1; i++) q[i] += qq[i];\n    }\n#if defined(_OPENMP)\n#pragma omp master\n    nthreads = omp_get_num_threads();\n#endif /* _OPENMP */    \n#endif /* _OPENMP */    \n} /* end of parallel region */    \n} /* end of parallel region */    \n\n    for (i = 0; i <= NQ-1; i++) {\n        gc = gc + q[i];\n    }\n\n    timer_stop(1);\n    tm = timer_read(1);\n\n    nit = 0;\n    if (M == 24) {\n\tif((fabs((sx- (-3.247834652034740e3))/sx) <= EPSILON) &&\n\t   (fabs((sy- (-6.958407078382297e3))/sy) <= EPSILON)) {\n\t    verified = TRUE;\n\t}\n    } else if (M == 25) {\n\tif ((fabs((sx- (-2.863319731645753e3))/sx) <= EPSILON) &&\n\t    (fabs((sy- (-6.320053679109499e3))/sy) <= EPSILON)) {\n\t    verified = TRUE;\n\t}\n    } else if (M == 28) {\n\tif ((fabs((sx- (-4.295875165629892e3))/sx) <= EPSILON) &&\n\t    (fabs((sy- (-1.580732573678431e4))/sy) <= EPSILON)) {\n\t    verified = TRUE;\n\t}\n    } else if (M == 30) {\n\tif ((fabs((sx- (4.033815542441498e4))/sx) <= EPSILON) &&\n\t    (fabs((sy- (-2.660669192809235e4))/sy) <= EPSILON)) {\n\t    verified = TRUE;\n\t}\n    } else if (M == 32) {\n\tif ((fabs((sx- (4.764367927995374e4))/sx) <= EPSILON) &&\n\t    (fabs((sy- (-8.084072988043731e4))/sy) <= EPSILON)) {\n\t    verified = TRUE;\n\t}\n    }\n\n    Mops = pow(2.0, M+1)/tm/1000000.0;\n\n    printf(\"EP Benchmark Results: \\n\"\n\t   \"CPU Time = %10.4f\\n\"\n\t   \"N = 2^%5d\\n\"\n\t   \"No. Gaussian Pairs = %15.0f\\n\"\n\t   \"Sums = %25.15e %25.15e\\n\"\n\t   \"Counts:\\n\",\n\t   tm, M, gc, sx, sy);\n    for (i = 0; i  <= NQ-1; i++) {\n\tprintf(\"%3d %15.0f\\n\", i, q[i]);\n    }\n\t  \n    c_print_results(\"EP\", CLASS, M+1, 0, 0, nit, nthreads,\n\t\t  tm, Mops, \t\n\t\t  \"Random numbers generated\",\n\t\t  verified, NPBVERSION, COMPILETIME,\n\t\t  CS1, CS2, CS3, CS4, CS5, CS6, CS7);\n\n    if (TIMERS_ENABLED == TRUE) {\n\tprintf(\"Total time:     %f\", timer_read(1));\n\tprintf(\"Gaussian pairs: %f\", timer_read(2));\n\tprintf(\"Random numbers: %f\", timer_read(3));\n    }\n}\n"}, {"prompt": "\n#include \"npbparams.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#if defined(_OPENMP)\n#include <omp.h>\n#endif /* _OPENMP */\n#endif /* _OPENMP */\n\n\nINT_TYPE *key_buff_ptr_global;         /* used by full_verify to get */\nINT_TYPE *key_buff_ptr_global;         /* used by full_verify to get */\n                                       /* copies of rank info        */\n                                       /* copies of rank info        */\n\nint      passed_verification;\n                                 \n\n\n\n\n      T1 = R23 * *X;\n      j  = T1;\n      X1 = j;\n      X2 = *X - T23 * X1;\n      T1 = A1 * X2 + A2 * X1;\n      \n      j  = R23 * T1;\n      T2 = j;\n      Z = T1 - T23 * T2;\n      T3 = T23 * Z + A2 * X2;\n      j  = R46 * T3;\n      T4 = j;\n      *X = T3 - T46 * T4;\n      return(R46 * *X);\n} \n\n\n\n\n\n        prv_buff1[key_buff2[i]]++;  /* Now they have individual key   */\n        prv_buff1[key_buff2[i]]++;  /* Now they have individual key   */\n    }\n                                       /* population                     */\n                                       /* population                     */\n    for( i=0; i<MAX_KEY-1; i++ )   \n        prv_buff1[i+1] += prv_buff1[i];  \n\n\n#pragma omp critical\n    {\n\tfor( i=0; i<MAX_KEY; i++ )\n\t    key_buff1[i] += prv_buff1[i];\n    }\n\n\n#pragma omp barrier    \n#pragma omp master\n  {\n    \n        k = partial_verify_vals[i];          /* test vals were put here */\n        k = partial_verify_vals[i];          /* test vals were put here */\n        if( 0 <= k  &&  k <= NUM_KEYS-1 )\n            switch( CLASS )\n            {\n                case 'S':\n                    if( i <= 2 )\n                    {\n                        if( key_buff1[k-1] != test_rank_array[i]+iteration )\n                        {\n                            printf( \"Failed partial verification: \"\n                                  \"iteration %d, test key %d\\n\", \n                                   iteration, i );\n                        }\n                        else\n                            passed_verification++;\n                    }\n                    else\n                    {\n                        if( key_buff1[k-1] != test_rank_array[i]-iteration )\n                        {\n                            printf( \"Failed partial verification: \"\n                                  \"iteration %d, test key %d\\n\", \n                                   iteration, i );\n                        }\n                        else\n                            passed_verification++;\n                    }\n                    break;\n                case 'W':\n                    if( i < 2 )\n                    {\n                        if( key_buff1[k-1] != \n                                          test_rank_array[i]+(iteration-2) )\n                        {\n                            printf( \"Failed partial verification: \"\n                                  \"iteration %d, test key %d\\n\", \n                                   iteration, i );\n                        }\n                        else\n                            passed_verification++;\n                    }\n                    else\n                    {\n                        if( key_buff1[k-1] != test_rank_array[i]-iteration )\n                        {\n                            printf( \"Failed partial verification: \"\n                                  \"iteration %d, test key %d\\n\", \n                                   iteration, i );\n                        }\n                        else\n                            passed_verification++;\n                    }\n                    break;\n                case 'A':\n                    if( i <= 2 )\n        \t    {\n                        if( key_buff1[k-1] != \n                                          test_rank_array[i]+(iteration-1) )\n                        {\n                            printf( \"Failed partial verification: \"\n                                  \"iteration %d, test key %d\\n\", \n                                   iteration, i );\n                        }\n                        else\n                            passed_verification++;\n        \t    }\n                    else\n                    {\n                        if( key_buff1[k-1] != \n                                          test_rank_array[i]-(iteration-1) )\n                        {\n                            printf( \"Failed partial verification: \"\n                                  \"iteration %d, test key %d\\n\", \n                                   iteration, i );\n                        }\n                        else\n                            passed_verification++;\n                    }\n                    break;\n                case 'B':\n                    if( i == 1 || i == 2 || i == 4 )\n        \t    {\n                        if( key_buff1[k-1] != test_rank_array[i]+iteration )\n                        {\n                            printf( \"Failed partial verification: \"\n                                  \"iteration %d, test key %d\\n\", \n                                   iteration, i );\n                        }\n                        else\n                            passed_verification++;\n        \t    }\n                    else\n                    {\n                        if( key_buff1[k-1] != test_rank_array[i]-iteration )\n                        {\n                            printf( \"Failed partial verification: \"\n                                  \"iteration %d, test key %d\\n\", \n                                   iteration, i );\n                        }\n                        else\n                            passed_verification++;\n                    }\n                    break;\n                case 'C':\n                    if( i <= 2 )\n        \t    {\n                        if( key_buff1[k-1] != test_rank_array[i]+iteration )\n                        {\n                            printf( \"Failed partial verification: \"\n                                  \"iteration %d, test key %d\\n\", \n                                   iteration, i );\n                        }\n                        else\n                            passed_verification++;\n        \t    }\n                    else\n                    {\n                        if( key_buff1[k-1] != test_rank_array[i]-iteration )\n                        {\n                            printf( \"Failed partial verification: \"\n                                  \"iteration %d, test key %d\\n\", \n                                   iteration, i );\n                        }\n                        else\n                            passed_verification++;\n                    }\n                    break;\n            }        \n    }\n\n\n\n\n\n    if( iteration == MAX_ITERATIONS ) \n        key_buff_ptr_global = key_buff1;\n\n  } /* end master */\n  } /* end master */\n}      \n\n\n    create_seq( 314159265.00,                    /* Random number gen seed */\n    create_seq( 314159265.00,                    /* Random number gen seed */\n                1220703125.00 );                 /* Random number gen mult */\n                1220703125.00 );                 /* Random number gen mult */\n\n\n#pragma omp parallel    \n    rank( 1 );  \n\n#endif /* _OPENMP */\t\n#endif /* _OPENMP */\t\n    }\n\n    full_verify();\n\n\n\n         /**************************/\n         /**************************/\n}        /*  E N D  P R O G R A M  */\n}        /*  E N D  P R O G R A M  */\n         /**************************/\n         /**************************/\n\n\n\n\n"}, {"prompt": "\n\n#include \"npb-C.h\"\n#include \"npbparams.h\"\n\n#define\tNZ\tNA*(NONZER+1)*(NONZER+1)+NA*(NONZER+2)\n\nstatic int colidx[NZ+1];\t/* colidx[1:NZ] */\nstatic int colidx[NZ+1];\t/* colidx[1:NZ] */\nstatic int rowstr[NA+1+1];\t/* rowstr[1:NA+1] */\nstatic int rowstr[NA+1+1];\t/* rowstr[1:NA+1] */\nstatic int iv[2*NA+1+1];\t/* iv[1:2*NA+1] */\nstatic int iv[2*NA+1+1];\t/* iv[1:2*NA+1] */\nstatic int arow[NZ+1];\t\t/* arow[1:NZ] */\nstatic int arow[NZ+1];\t\t/* arow[1:NZ] */\nstatic int acol[NZ+1];\t\t/* acol[1:NZ] */\nstatic int acol[NZ+1];\t\t/* acol[1:NZ] */\n\nstatic double v[NA+1+1];\t/* v[1:NA+1] */\nstatic double v[NA+1+1];\t/* v[1:NA+1] */\nstatic double aelt[NZ+1];\t/* aelt[1:NZ] */\nstatic double aelt[NZ+1];\t/* aelt[1:NZ] */\nstatic double a[NZ+1];\t\t/* a[1:NZ] */\nstatic double a[NZ+1];\t\t/* a[1:NZ] */\nstatic double x[NA+2+1];\t/* x[1:NA+2] */\nstatic double x[NA+2+1];\t/* x[1:NA+2] */\nstatic double z[NA+2+1];\t/* z[1:NA+2] */\nstatic double z[NA+2+1];\t/* z[1:NA+2] */\nstatic double p[NA+2+1];\t/* p[1:NA+2] */\nstatic double p[NA+2+1];\t/* p[1:NA+2] */\nstatic double q[NA+2+1];\t/* q[1:NA+2] */\nstatic double q[NA+2+1];\t/* q[1:NA+2] */\nstatic double r[NA+2+1];\t/* r[1:NA+2] */\nstatic double r[NA+2+1];\t/* r[1:NA+2] */\n//static double w[NA+2+1];\t/* w[1:NA+2] */\n//static double w[NA+2+1];\t/* w[1:NA+2] */\n\n\nint main(int argc, char **argv) {\n    int\ti, j, k, it;\n    int nthreads = 1;\n    double zeta;\n    double rnorm;\n    double norm_temp11;\n    double norm_temp12;\n    double t, mflops;\n    char class;\n    boolean verified;\n    double zeta_verify_value, epsilon;\n\n    firstrow = 1;\n    lastrow  = NA;\n    firstcol = 1;\n    lastcol  = NA;\n\n    if (NA == 1400 && NONZER == 7 && NITER == 15 && SHIFT == 10.0) {\n\tclass = 'S';\n\tzeta_verify_value = 8.5971775078648;\n    } else if (NA == 7000 && NONZER == 8 && NITER == 15 && SHIFT == 12.0) {\n\tclass = 'W';\n\tzeta_verify_value = 10.362595087124;\n    } else if (NA == 14000 && NONZER == 11 && NITER == 15 && SHIFT == 20.0) {\n\tclass = 'A';\n\tzeta_verify_value = 17.130235054029;\n    } else if (NA == 75000 && NONZER == 13 && NITER == 75 && SHIFT == 60.0) {\n\tclass = 'B';\n\tzeta_verify_value = 22.712745482631;\n    } else if (NA == 150000 && NONZER == 15 && NITER == 75 && SHIFT == 110.0) {\n\tclass = 'C';\n\tzeta_verify_value = 28.973605592845;\n    } else {\n\tclass = 'U';\n    }\n\n    printf(\"\\n\\n NAS Parallel Benchmarks 3.0 structured OpenMP C version\"\n\t   \" - CG Benchmark\\n\");\n    printf(\" Size: %10d\\n\", NA);\n    printf(\" Iterations: %5d\\n\", NITER);\n\n    naa = NA;\n    nzz = NZ;\n\n    tran    = 314159265.0;\n    amult   = 1220703125.0;\n    zeta    = randlc( &tran, amult );\n\n    makea(naa, nzz, a, colidx, rowstr, NONZER,\n\t  firstrow, lastrow, firstcol, lastcol, \n\t  RCOND, arow, acol, aelt, v, iv, SHIFT);\n    \n#pragma omp parallel default(shared) private(i,j,k)\n{\t\n#pragma omp for nowait\n    for (j = 1; j <= lastrow - firstrow + 1; j++) {\n\tfor (k = rowstr[j]; k < rowstr[j+1]; k++) {\n            colidx[k] = colidx[k] - firstcol + 1;\n\t}\n    }\n\n#pragma omp for nowait\n    for (i = 1; i <= NA+1; i++) {\n\tx[i] = 1.0;\n    }\n#pragma omp for nowait\n      for (j = 1; j <= lastcol-firstcol+1; j++) {\n         q[j] = 0.0;\n         z[j] = 0.0;\n         r[j] = 0.0;\n         p[j] = 0.0;\n      }\n}// end omp parallel\n    zeta  = 0.0;\n\n\n    for (it = 1; it <= 1; it++) {\n\n\tconj_grad (colidx, rowstr, x, z, a, p, q, r,/* w,*/ &rnorm);\n\tconj_grad (colidx, rowstr, x, z, a, p, q, r,/* w,*/ &rnorm);\n\n\tnorm_temp11 = 0.0;\n\tnorm_temp12 = 0.0;\n#pragma omp parallel for default(shared) private(j) reduction(+:norm_temp11,norm_temp12)\n\tfor (j = 1; j <= lastcol-firstcol+1; j++) {\n            norm_temp11 = norm_temp11 + x[j]*z[j];\n            norm_temp12 = norm_temp12 + z[j]*z[j];\n\t}\n\tnorm_temp12 = 1.0 / sqrt( norm_temp12 );\n\n#pragma omp parallel for default(shared) private(j)\n\tfor (j = 1; j <= lastcol-firstcol+1; j++) {\n            x[j] = norm_temp12*z[j];\n\t}\n\t\n    } /* end of do one iteration untimed */\n    } /* end of do one iteration untimed */\n\n#pragma omp parallel for default(shared) private(i)\n    for (i = 1; i <= NA+1; i++) {\n         x[i] = 1.0;\n    }  \n    zeta  = 0.0;\n\n\n    timer_clear( 1 );\n    timer_start( 1 );\n\n\n    for (it = 1; it <= NITER; it++) {\n\n\tconj_grad(colidx, rowstr, x, z, a, p, q, r/*, w*/, &rnorm);\n\tconj_grad(colidx, rowstr, x, z, a, p, q, r/*, w*/, &rnorm);\n\n\tnorm_temp11 = 0.0;\n\tnorm_temp12 = 0.0;\n\n#pragma omp parallel for default(shared) private(j) reduction(+:norm_temp11,norm_temp12)\n\tfor (j = 1; j <= lastcol-firstcol+1; j++) {\n            norm_temp11 = norm_temp11 + x[j]*z[j];\n            norm_temp12 = norm_temp12 + z[j]*z[j];\n\t}\n\n\tnorm_temp12 = 1.0 / sqrt( norm_temp12 );\n\n\tzeta = SHIFT + 1.0 / norm_temp11;\n\n\tif( it == 1 ) {\n\t  printf(\"   iteration           ||r||                 zeta\\n\");\n\t}\n\tprintf(\"    %5d       %20.14e%20.13e\\n\", it, rnorm, zeta);\n\n#pragma omp parallel for default(shared) private(j)\n\tfor (j = 1; j <= lastcol-firstcol+1; j++) {\n            x[j] = norm_temp12*z[j];\n\t}\n    } /* end of main iter inv pow meth */\n    } /* end of main iter inv pow meth */\n#pragma omp parallel\n{\n#if defined(_OPENMP)\n#pragma omp master\n    nthreads = omp_get_num_threads();\n#endif /* _OPENMP */\n#endif /* _OPENMP */\n} /* end parallel */\n} /* end parallel */\n\n    timer_stop( 1 );\n\n\n    t = timer_read( 1 );\n\n    printf(\" Benchmark completed\\n\");\n\n    epsilon = 1.0e-10;\n    if (class != 'U') {\n\tif (fabs(zeta - zeta_verify_value) <= epsilon) {\n            verified = TRUE;\n\t    printf(\" VERIFICATION SUCCESSFUL\\n\");\n\t    printf(\" Zeta is    %20.12e\\n\", zeta);\n\t    printf(\" Error is   %20.12e\\n\", zeta - zeta_verify_value);\n\t} else {\n            verified = FALSE;\n\t    printf(\" VERIFICATION FAILED\\n\");\n\t    printf(\" Zeta                %20.12e\\n\", zeta);\n\t    printf(\" The correct zeta is %20.12e\\n\", zeta_verify_value);\n\t}\n    } else {\n\tverified = FALSE;\n\tprintf(\" Problem size unknown\\n\");\n\tprintf(\" NO VERIFICATION PERFORMED\\n\");\n    }\n\n    if ( t != 0.0 ) {\n\tmflops = (2.0*NITER*NA)\n\t    * (3.0+(NONZER*(NONZER+1)) + 25.0*(5.0+(NONZER*(NONZER+1))) + 3.0 )\n\t    / t / 1000000.0;\n    } else {\n\tmflops = 0.0;\n    }\n\n    c_print_results(\"CG\", class, NA, 0, 0, NITER, nthreads, t, \n\t\t    mflops, \"          floating point\", \n\t\t    verified, NPBVERSION, COMPILETIME,\n\t\t    CS1, CS2, CS3, CS4, CS5, CS6, CS7);\n}\n\nstatic void conj_grad (\n    int colidx[],\t/* colidx[1:nzz] */\n    int colidx[],\t/* colidx[1:nzz] */\n    int rowstr[],\t/* rowstr[1:naa+1] */\n    int rowstr[],\t/* rowstr[1:naa+1] */\n    double x[],\t\t/* x[*] */\n    double x[],\t\t/* x[*] */\n    double z[],\t\t/* z[*] */\n    double z[],\t\t/* z[*] */\n    double a[],\t\t/* a[1:nzz] */\n    double a[],\t\t/* a[1:nzz] */\n    double p[],\t\t/* p[*] */\n    double p[],\t\t/* p[*] */\n    double q[],\t\t/* q[*] */\n    double q[],\t\t/* q[*] */\n    double r[],\t\t/* r[*] */\n    double r[],\t\t/* r[*] */\n    //double w[],\t\t/* w[*] */\n    //double w[],\t\t/* w[*] */\n    double *rnorm )\n    \n{\n    static int callcount = 0;\n    double d, sum, rho, rho0, alpha, beta;\n    int i, j, k;\n    int cgit, cgitmax = 25;\n\n    rho = 0.0;\n#pragma omp parallel default(shared) private(j,sum) shared(rho,naa)\n    \n{\n#pragma omp for\n    for (j = 1; j <= naa+1; j++) {\n\tq[j] = 0.0;\n\tz[j] = 0.0;\n\tr[j] = x[j];\n\tp[j] = r[j];\n\t//w[j] = 0.0;\n    }\n\n#pragma omp for reduction(+:rho)\n    for (j = 1; j <= lastcol-firstcol+1; j++) {\n\trho = rho + r[j]*r[j];\n    }\n}/* end omp parallel */\n}/* end omp parallel */\n    for (cgit = 1; cgit <= cgitmax; cgit++) {\n      rho0 = rho;\n      d = 0.0;\n      rho = 0.0;\n#pragma omp parallel default(shared) private(j,k,sum,alpha,beta) shared(d,rho0,rho)\n{\n      \n\n#pragma omp for reduction(+:d)\n\tfor (j = 1; j <= lastcol-firstcol+1; j++) {\n            d = d + p[j]*q[j];\n\t}\n#pragma omp barrier\n//#pragma omp single\t\n\talpha = rho0 / d;\n\n\t/*\trho0 = rho;*/\n\t/*\trho0 = rho;*/\n\n#pragma omp for reduction(+:rho)\t\n\tfor (j = 1; j <= lastcol-firstcol+1; j++) {\n            z[j] = z[j] + alpha*p[j];\n            r[j] = r[j] - alpha*q[j];\n//\t}\n            \n            rho = rho + r[j]*r[j];\n\t}\n//#pragma omp barrier\n\n//#pragma omp single\t\n\tbeta = rho / rho0;\n\n#pragma omp for nowait\n\tfor (j = 1; j <= lastcol-firstcol+1; j++) {\n            p[j] = r[j] + beta*p[j];\n\t}\n    callcount++;\n    } /* end omp parallel */\n    } /* end omp parallel */\n    } /* end of do cgit=1,cgitmax */\n    } /* end of do cgit=1,cgitmax */\n\n    sum = 0.0;\n    \n#pragma omp parallel default(shared) private(j,d) shared(sum)\n{\n#pragma omp for //private(d, k)\n    for (j = 1; j <= lastrow-firstrow+1; j++) {\n\td = 0.0;\n\tfor (k = rowstr[j]; k <= rowstr[j+1]-1; k++) {\n            d = d + a[k]*z[colidx[k]];\n\t}\n\tr[j] = d;\n    }\n\n#pragma omp for reduction(+:sum)\n    for (j = 1; j <= lastcol-firstcol+1; j++) {\n\td = x[j] - r[j];\n\tsum = sum + d*d;\n    }\n} //end omp parallel\n    (*rnorm) = sqrt(sum);\n}\n\nstatic void makea(\n    int n,\n    int nz,\n    double a[],\t\t/* a[1:nz] */\n    double a[],\t\t/* a[1:nz] */\n    int colidx[],\t/* colidx[1:nz] */\n    int colidx[],\t/* colidx[1:nz] */\n    int rowstr[],\t/* rowstr[1:n+1] */\n    int rowstr[],\t/* rowstr[1:n+1] */\n    int nonzer,\n    int firstrow,\n    int lastrow,\n    int firstcol,\n    int lastcol,\n    double rcond,\n    int arow[],\t\t/* arow[1:nz] */\n    int arow[],\t\t/* arow[1:nz] */\n    int acol[],\t\t/* acol[1:nz] */\n    int acol[],\t\t/* acol[1:nz] */\n    double aelt[],\t/* aelt[1:nz] */\n    double aelt[],\t/* aelt[1:nz] */\n    double v[],\t\t/* v[1:n+1] */\n    double v[],\t\t/* v[1:n+1] */\n    int iv[],\t\t/* iv[1:2*n+1] */\n    int iv[],\t\t/* iv[1:2*n+1] */\n    double shift )\n{\n    int i, nnza, iouter, ivelt, ivelt1, irow, nzv;\n\n\n    double size, ratio, scale;\n    int jcol;\n\n    size = 1.0;\n    ratio = pow(rcond, (1.0 / (double)n));\n    nnza = 0;\n\n#pragma omp parallel for default(shared) private(i)\n    for (i = 1; i <= n; i++) {\n\tcolidx[n+i] = 0;\n    }\n    for (iouter = 1; iouter <= n; iouter++) {\n\tnzv = nonzer;\n\tsprnvc(n, nzv, v, iv, &(colidx[0]), &(colidx[n]));\n\tvecset(n, v, iv, &nzv, iouter, 0.5);\n\tfor (ivelt = 1; ivelt <= nzv; ivelt++) {\n\t    jcol = iv[ivelt];\n\t    if (jcol >= firstcol && jcol <= lastcol) {\n\t\tscale = size * v[ivelt];\n\t\tfor (ivelt1 = 1; ivelt1 <= nzv; ivelt1++) {\n\t            irow = iv[ivelt1];\n                    if (irow >= firstrow && irow <= lastrow) {\n\t\t\tnnza = nnza + 1;\n\t\t\tif (nnza > nz) {\n\t\t\t    printf(\"Space for matrix elements exceeded in\"\n\t\t\t\t   \" makea\\n\");\n\t\t\t    printf(\"nnza, nzmax = %d, %d\\n\", nnza, nz);\n\t\t\t    printf(\"iouter = %d\\n\", iouter);\n\t\t\t    exit(1);\n\t\t\t}\n\t\t\tacol[nnza] = jcol;\n\t\t\tarow[nnza] = irow;\n\t\t\taelt[nnza] = v[ivelt1] * scale;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tsize = size * ratio;\n    }\n\n    for (i = firstrow; i <= lastrow; i++) {\n\tif (i >= firstcol && i <= lastcol) {\n\t    iouter = n + i;\n\t    nnza = nnza + 1;\n\t    if (nnza > nz) {\n\t\tprintf(\"Space for matrix elements exceeded in makea\\n\");\n\t\tprintf(\"nnza, nzmax = %d, %d\\n\", nnza, nz);\n\t\tprintf(\"iouter = %d\\n\", iouter);\n\t\texit(1);\n\t    }\n\t    acol[nnza] = i;\n\t    arow[nnza] = i;\n\t    aelt[nnza] = rcond - shift;\n\t}\n    }\n\n    sparse(a, colidx, rowstr, n, arow, acol, aelt,\n\t   firstrow, lastrow, v, &(iv[0]), &(iv[n]), nnza);\n}\n\nstatic void sparse(\n    double a[],\t\t/* a[1:*] */\n    double a[],\t\t/* a[1:*] */\n    int colidx[],\t/* colidx[1:*] */\n    int colidx[],\t/* colidx[1:*] */\n    int rowstr[],\t/* rowstr[1:*] */\n    int rowstr[],\t/* rowstr[1:*] */\n    int n,\n    int arow[],\t\t/* arow[1:*] */\n    int arow[],\t\t/* arow[1:*] */\n    int acol[],\t\t/* acol[1:*] */\n    int acol[],\t\t/* acol[1:*] */\n    double aelt[],\t/* aelt[1:*] */\n    double aelt[],\t/* aelt[1:*] */\n    int firstrow,\n    int lastrow,\n    double x[],\t\t/* x[1:n] */\n    double x[],\t\t/* x[1:n] */\n    boolean mark[],\t/* mark[1:n] */\n    boolean mark[],\t/* mark[1:n] */\n    int nzloc[],\t/* nzloc[1:n] */\n    int nzloc[],\t/* nzloc[1:n] */\n    int nnza)\n{\n    int nrows;\n    int i, j, jajp1, nza, k, nzrow;\n    double xi;\n\n    nrows = lastrow - firstrow + 1;\n\n#pragma omp parallel for default(shared) private(j)\n    for (j = 1; j <= n; j++) {\n\trowstr[j] = 0;\n\tmark[j] = FALSE;\n    }\n    rowstr[n+1] = 0;\n    \n    for (nza = 1; nza <= nnza; nza++) {\n\tj = (arow[nza] - firstrow + 1) + 1;\n\trowstr[j] = rowstr[j] + 1;\n    }\n\n    rowstr[1] = 1;\n    for (j = 2; j <= nrows+1; j++) {\n\trowstr[j] = rowstr[j] + rowstr[j-1];\n    }\n\n    \n#pragma omp parallel for default(shared) private(k,j)\n      for(j = 0;j <= nrows-1;j++) {\n         for(k = rowstr[j];k <= rowstr[j+1]-1;k++)\n\t       a[k] = 0.0;\n      }\n    for (nza = 1; nza <= nnza; nza++) {\n\tj = arow[nza] - firstrow + 1;\n\tk = rowstr[j];\n\ta[k] = aelt[nza];\n\tcolidx[k] = acol[nza];\n\trowstr[j] = rowstr[j] + 1;\n    }\n\n    for (j = nrows; j >= 1; j--) {\n\trowstr[j+1] = rowstr[j];\n    }\n    rowstr[1] = 1;\n\n    nza = 0;\n#pragma omp parallel for default(shared) private(i)    \n    for (i = 1; i <= n; i++) {\n\tx[i] = 0.0;\n\tmark[i] = FALSE;\n    }\n\n    jajp1 = rowstr[1];\n    for (j = 1; j <= nrows; j++) {\n\tnzrow = 0;\n\t\n\tfor (k = jajp1; k < rowstr[j+1]; k++) {\n            i = colidx[k];\n            x[i] = x[i] + a[k];\n            if ( mark[i] == FALSE && x[i] != 0.0) {\n\t\tmark[i] = TRUE;\n\t\tnzrow = nzrow + 1;\n\t\tnzloc[nzrow] = i;\n\t    }\n\t}\n\n\tfor (k = 1; k <= nzrow; k++) {\n            i = nzloc[k];\n            mark[i] = FALSE;\n            xi = x[i];\n            x[i] = 0.0;\n            if (xi != 0.0) {\n\t\tnza = nza + 1;\n\t\ta[nza] = xi;\n\t\tcolidx[nza] = i;\n\t    }\n\t}\n\tjajp1 = rowstr[j+1];\n\trowstr[j+1] = nza + rowstr[1];\n    }\n}\n\nstatic void sprnvc(\n    int n,\n    int nz,\n    double v[],\t\t/* v[1:*] */\n    double v[],\t\t/* v[1:*] */\n    int iv[],\t\t/* iv[1:*] */\n    int iv[],\t\t/* iv[1:*] */\n    int nzloc[],\t/* nzloc[1:n] */\n    int nzloc[],\t/* nzloc[1:n] */\n    int mark[] ) \t/* mark[1:n] */\n    int mark[] ) \t/* mark[1:n] */\n{\n    int nn1;\n    int nzrow, nzv, ii, i;\n    double vecelt, vecloc;\n\n    nzv = 0;\n    nzrow = 0;\n    nn1 = 1;\n    do {\n\tnn1 = 2 * nn1;\n    } while (nn1 < n);\n\n\n    while (nzv < nz) {\n\tvecelt = randlc(&tran, amult);\n\n\tvecloc = randlc(&tran, amult);\n\ti = icnvrt(vecloc, nn1) + 1;\n\tif (i > n) continue;\n\n\tif (mark[i] == 0) {\n\t    mark[i] = 1;\n\t    nzrow = nzrow + 1;\n\t    nzloc[nzrow] = i;\n\t    nzv = nzv + 1;\n\t    v[nzv] = vecelt;\n\t    iv[nzv] = i;\n\t}\n    }\n\n    for (ii = 1; ii <= nzrow; ii++) {\n\ti = nzloc[ii];\n\tmark[i] = 0;\n    }\n}\n\nstatic int icnvrt(double x, int ipwr2) {\n    return ((int)(ipwr2 * x));\n}\n\nstatic void vecset(\n    int n,\n    double v[],\t/* v[1:*] */\n    double v[],\t/* v[1:*] */\n    int iv[],\t/* iv[1:*] */\n    int iv[],\t/* iv[1:*] */\n    int *nzv,\n    int i,\n    double val)\n{\n    int k;\n    boolean set;\n\n    set = FALSE;\n    for (k = 1; k <= *nzv; k++) {\n\tif (iv[k] == i) {\n            v[k] = val;\n            set  = TRUE;\n\t}\n    }\n    if (set == FALSE) {\n\t*nzv = *nzv + 1;\n\tv[*nzv] = val;\n\tiv[*nzv] = i;\n    }\n}\n"}, {"prompt": "\n#include \"npb-C.h\"\n\n#endif /* _OPENMP */\n#endif /* _OPENMP */\n\n\nint main(int argc, char **argv) {\n\n\n  char class;\n  boolean verified;\n  double mflops;\n  int nthreads = 1;\n\n  read_input();\n\n  domain();\n\n  setcoeff();\n\n  setbv();\n\n  setiv();\n\n  erhs();\n  \n#pragma omp parallel\n{  \n  \n#if defined(_OPENMP)  \n#pragma omp master\n  nthreads = omp_get_num_threads();\n#endif /* _OPENMP */  \n#endif /* _OPENMP */  \n}\n\n  ssor();\n\n  error();\n\n  pintgr();\n\n  verify ( rsdnm, errnm, frc, &class, &verified );\n  mflops = (double)itmax*(1984.77*(double)nx0\n\t\t\t *(double)ny0\n\t\t\t *(double)nz0\n\t\t\t -10923.3*pow2((double)( nx0+ny0+nz0 )/3.0)\n\t\t\t +27770.9* (double)( nx0+ny0+nz0 )/3.0\n\t\t\t -144010.0)\n    / (maxtime*1000000.0);\n\n  c_print_results(\"LU\", class, nx0,\n\t\t  ny0, nz0, itmax, nthreads,\n\t\t  maxtime, mflops, \"          floating point\", verified, \n\t\t  NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, \n\t\t  \"(none)\");\n}\n\n\nstatic void blts (int nx, int ny, int nz, int k,\n\t\t  double omega,\n\t\t  double v[ISIZ1][ISIZ2/2*2+1][ISIZ3/2*2+1][5],\n\t\t  double ldz[ISIZ1][ISIZ2][5][5],\n\t\t  double ldy[ISIZ1][ISIZ2][5][5],\n\t\t  double ldx[ISIZ1][ISIZ2][5][5],\n\t\t  double d[ISIZ1][ISIZ2][5][5],\n\t\t  int ist, int iend, int jst, int jend,\n\t\t  int nx0, int ny0 ) {\n\n  int i, j, m;\n  double tmp, tmp1;\n  double tmat[5][5];\n\n#pragma omp for nowait schedule(static)\n  for (i = ist; i <= iend; i++) {\n    for (j = jst; j <= jend; j++) {\n      for (m = 0; m < 5; m++) {\n\tv[i][j][k][m] = v[i][j][k][m]\n\t  - omega * (  ldz[i][j][m][0] * v[i][j][k-1][0]\n\t\t       + ldz[i][j][m][1] * v[i][j][k-1][1]\n\t\t       + ldz[i][j][m][2] * v[i][j][k-1][2]\n\t\t       + ldz[i][j][m][3] * v[i][j][k-1][3]\n\t\t       + ldz[i][j][m][4] * v[i][j][k-1][4]  );\n      }\n    }\n  }\n\n#pragma omp for nowait schedule(static)\n  for (i = ist; i <= iend; i++) {\n    \n#if defined(_OPENMP)      \n    if (i != ist) {\n\twhile (flag[i-1] == 0) {\n#pragma omp flush(flag)\n\t    ;\n\t}\n    }\n    if (i != iend) {\n\twhile (flag[i] == 1) {\n#pragma omp flush(flag)\n\t    ;\n\t}\n    }\n#endif /* _OPENMP */\n#endif /* _OPENMP */\n    \n    for (j = jst; j <= jend; j++) {\n      for (m = 0; m < 5; m++) {\n\n\tv[i][j][k][m] = v[i][j][k][m]\n\t  - omega * ( ldy[i][j][m][0] * v[i][j-1][k][0]\n\t\t      + ldx[i][j][m][0] * v[i-1][j][k][0]\n\t\t      + ldy[i][j][m][1] * v[i][j-1][k][1]\n\t\t      + ldx[i][j][m][1] * v[i-1][j][k][1]\n\t\t      + ldy[i][j][m][2] * v[i][j-1][k][2]\n\t\t      + ldx[i][j][m][2] * v[i-1][j][k][2]\n\t\t      + ldy[i][j][m][3] * v[i][j-1][k][3]\n\t\t      + ldx[i][j][m][3] * v[i-1][j][k][3]\n\t\t      + ldy[i][j][m][4] * v[i][j-1][k][4]\n\t\t      + ldx[i][j][m][4] * v[i-1][j][k][4] );\n      }\n       \n      for (m = 0; m < 5; m++) {\n\ttmat[m][0] = d[i][j][m][0];\n\ttmat[m][1] = d[i][j][m][1];\n\ttmat[m][2] = d[i][j][m][2];\n\ttmat[m][3] = d[i][j][m][3];\n\ttmat[m][4] = d[i][j][m][4];\n      }\n\n      tmp1 = 1.0 / tmat[0][0];\n      tmp = tmp1 * tmat[1][0];\n      tmat[1][1] =  tmat[1][1]\n\t- tmp * tmat[0][1];\n      tmat[1][2] =  tmat[1][2]\n\t- tmp * tmat[0][2];\n      tmat[1][3] =  tmat[1][3]\n\t- tmp * tmat[0][3];\n      tmat[1][4] =  tmat[1][4]\n\t- tmp * tmat[0][4];\n      v[i][j][k][1] = v[i][j][k][1]\n\t- v[i][j][k][0] * tmp;\n\n      tmp = tmp1 * tmat[2][0];\n      tmat[2][1] =  tmat[2][1]\n\t- tmp * tmat[0][1];\n      tmat[2][2] =  tmat[2][2]\n\t- tmp * tmat[0][2];\n      tmat[2][3] =  tmat[2][3]\n\t- tmp * tmat[0][3];\n      tmat[2][4] =  tmat[2][4]\n\t- tmp * tmat[0][4];\n      v[i][j][k][2] = v[i][j][k][2]\n\t- v[i][j][k][0] * tmp;\n\n      tmp = tmp1 * tmat[3][0];\n      tmat[3][1] =  tmat[3][1]\n\t- tmp * tmat[0][1];\n      tmat[3][2] =  tmat[3][2]\n\t- tmp * tmat[0][2];\n      tmat[3][3] =  tmat[3][3]\n\t- tmp * tmat[0][3];\n      tmat[3][4] =  tmat[3][4]\n\t- tmp * tmat[0][4];\n      v[i][j][k][3] = v[i][j][k][3]\n\t- v[i][j][k][0] * tmp;\n\n      tmp = tmp1 * tmat[4][0];\n      tmat[4][1] =  tmat[4][1]\n\t- tmp * tmat[0][1];\n      tmat[4][2] =  tmat[4][2]\n\t- tmp * tmat[0][2];\n      tmat[4][3] =  tmat[4][3]\n\t- tmp * tmat[0][3];\n      tmat[4][4] =  tmat[4][4]\n\t- tmp * tmat[0][4];\n      v[i][j][k][4] = v[i][j][k][4]\n\t- v[i][j][k][0] * tmp;\n\n      tmp1 = 1.0 / tmat[ 1][1];\n      tmp = tmp1 * tmat[ 2][1];\n      tmat[2][2] =  tmat[2][2]\n\t- tmp * tmat[1][2];\n      tmat[2][3] =  tmat[2][3]\n\t- tmp * tmat[1][3];\n      tmat[2][4] =  tmat[2][4]\n\t- tmp * tmat[1][4];\n      v[i][j][k][2] = v[i][j][k][2]\n\t- v[i][j][k][1] * tmp;\n\n      tmp = tmp1 * tmat[3][1];\n      tmat[3][2] =  tmat[3][2]\n\t- tmp * tmat[1][2];\n      tmat[3][3] =  tmat[3][3]\n\t- tmp * tmat[1][3];\n      tmat[3][4] =  tmat[3][4]\n\t- tmp * tmat[1][4];\n      v[i][j][k][3] = v[i][j][k][3]\n\t- v[i][j][k][1] * tmp;\n\n      tmp = tmp1 * tmat[4][1];\n      tmat[4][2] =  tmat[4][2]\n\t- tmp * tmat[1][2];\n      tmat[4][3] =  tmat[4][3]\n\t- tmp * tmat[1][3];\n      tmat[4][4] =  tmat[4][4]\n\t- tmp * tmat[1][4];\n      v[i][j][k][4] = v[i][j][k][4]\n\t- v[i][j][k][1] * tmp;\n\n      tmp1 = 1.0 / tmat[2][2];\n      tmp = tmp1 * tmat[3][2];\n      tmat[3][3] =  tmat[3][3]\n\t- tmp * tmat[2][3];\n      tmat[3][4] =  tmat[3][4]\n\t- tmp * tmat[2][4];\n      v[i][j][k][3] = v[i][j][k][3]\n        - v[i][j][k][2] * tmp;\n\n      tmp = tmp1 * tmat[4][2];\n      tmat[4][3] =  tmat[4][3]\n\t- tmp * tmat[2][3];\n      tmat[4][4] =  tmat[4][4]\n\t- tmp * tmat[2][4];\n      v[i][j][k][4] = v[i][j][k][4]\n\t- v[i][j][k][2] * tmp;\n\n      tmp1 = 1.0 / tmat[3][3];\n      tmp = tmp1 * tmat[4][3];\n      tmat[4][4] =  tmat[4][4]\n\t- tmp * tmat[3][4];\n      v[i][j][k][4] = v[i][j][k][4]\n\t- v[i][j][k][3] * tmp;\n\n      v[i][j][k][4] = v[i][j][k][4]\n\t/ tmat[4][4];\n\n      v[i][j][k][3] = v[i][j][k][3]\n\t- tmat[3][4] * v[i][j][k][4];\n      v[i][j][k][3] = v[i][j][k][3]\n\t/ tmat[3][3];\n\n      v[i][j][k][2] = v[i][j][k][2]\n\t- tmat[2][3] * v[i][j][k][3]\n\t- tmat[2][4] * v[i][j][k][4];\n      v[i][j][k][2] = v[i][j][k][2]\n\t/ tmat[2][2];\n\n      v[i][j][k][1] = v[i][j][k][1]\n\t- tmat[1][2] * v[i][j][k][2]\n\t- tmat[1][3] * v[i][j][k][3]\n\t- tmat[1][4] * v[i][j][k][4];\n      v[i][j][k][1] = v[i][j][k][1]\n\t/ tmat[1][1];\n\n      v[i][j][k][0] = v[i][j][k][0]\n\t- tmat[0][1] * v[i][j][k][1]\n\t- tmat[0][2] * v[i][j][k][2]\n\t- tmat[0][3] * v[i][j][k][3]\n\t- tmat[0][4] * v[i][j][k][4];\n      v[i][j][k][0] = v[i][j][k][0]\n\t/ tmat[0][0];\n    }\n    \n#if defined(_OPENMP)    \n    if (i != ist) flag[i-1] = 0;\n    if (i != iend) flag[i] = 1;\n#pragma omp flush(flag)    \n#endif /* _OPENMP */    \n#endif /* _OPENMP */    \n  }\n}\n\n\nstatic void buts(int nx, int ny, int nz, int k,\n\t\t double omega,\n\t\t double v[ISIZ1][ISIZ2/2*2+1][ISIZ3/2*2+1][5],\n\t\t double tv[ISIZ1][ISIZ2][5],\n\t\t double d[ISIZ1][ISIZ2][5][5],\n\t\t double udx[ISIZ1][ISIZ2][5][5],\n\t\t double udy[ISIZ1][ISIZ2][5][5],\n\t\t double udz[ISIZ1][ISIZ2][5][5],\n\t\t int ist, int iend, int jst, int jend,\n\t\t int nx0, int ny0 ) {\n\n  int i, j, m;\n  double tmp, tmp1;\n  double tmat[5][5];\n\n#pragma omp for nowait schedule(static)\n  for (i = iend; i >= ist; i--) {\n    for (j = jend; j >= jst; j--) {\n      for (m = 0; m < 5; m++) {\n\ttv[i][j][m] = \n\t  omega * (  udz[i][j][m][0] * v[i][j][k+1][0]\n\t\t     + udz[i][j][m][1] * v[i][j][k+1][1]\n\t\t     + udz[i][j][m][2] * v[i][j][k+1][2]\n\t\t     + udz[i][j][m][3] * v[i][j][k+1][3]\n\t\t     + udz[i][j][m][4] * v[i][j][k+1][4] );\n      }\n    }\n  }\n\n#pragma omp for nowait schedule(static)\n  for (i = iend; i >= ist; i--) {\n#if defined(_OPENMP)      \n    if (i != iend) {\n      while (flag[i+1] == 0) {\n#pragma omp flush(flag)\n\t;\n      }\n    }\n    if (i != ist) {\n      while (flag[i] == 1) {\n#pragma omp flush(flag)\n\t;\n      }\n    }\n#endif /* _OPENMP */\n#endif /* _OPENMP */\n    \n    for (j = jend; j >= jst; j--) {\n      for (m = 0; m < 5; m++) {\n\ttv[i][j][m] = tv[i][j][m]\n\t  + omega * ( udy[i][j][m][0] * v[i][j+1][k][0]\n\t\t      + udx[i][j][m][0] * v[i+1][j][k][0]\n\t\t      + udy[i][j][m][1] * v[i][j+1][k][1]\n\t\t      + udx[i][j][m][1] * v[i+1][j][k][1]\n\t\t      + udy[i][j][m][2] * v[i][j+1][k][2]\n\t\t      + udx[i][j][m][2] * v[i+1][j][k][2]\n\t\t      + udy[i][j][m][3] * v[i][j+1][k][3]\n\t\t      + udx[i][j][m][3] * v[i+1][j][k][3]\n\t\t      + udy[i][j][m][4] * v[i][j+1][k][4]\n\t\t      + udx[i][j][m][4] * v[i+1][j][k][4] );\n      }\n\n      for (m = 0; m < 5; m++) {\n\ttmat[m][0] = d[i][j][m][0];\n\ttmat[m][1] = d[i][j][m][1];\n\ttmat[m][2] = d[i][j][m][2];\n\ttmat[m][3] = d[i][j][m][3];\n\ttmat[m][4] = d[i][j][m][4];\n      }\n\n      tmp1 = 1.0 / tmat[0][0];\n      tmp = tmp1 * tmat[1][0];\n      tmat[1][1] =  tmat[1][1]\n\t- tmp * tmat[0][1];\n      tmat[1][2] =  tmat[1][2]\n\t- tmp * tmat[0][2];\n      tmat[1][3] =  tmat[1][3]\n\t- tmp * tmat[0][3];\n      tmat[1][4] =  tmat[1][4]\n\t- tmp * tmat[0][4];\n      tv[i][j][1] = tv[i][j][1]\n\t- tv[i][j][0] * tmp;\n\n      tmp = tmp1 * tmat[2][0];\n      tmat[2][1] =  tmat[2][1]\n\t- tmp * tmat[0][1];\n      tmat[2][2] =  tmat[2][2]\n\t- tmp * tmat[0][2];\n      tmat[2][3] =  tmat[2][3]\n\t- tmp * tmat[0][3];\n      tmat[2][4] =  tmat[2][4]\n\t- tmp * tmat[0][4];\n      tv[i][j][2] = tv[i][j][2]\n\t- tv[i][j][0] * tmp;\n\n      tmp = tmp1 * tmat[3][0];\n      tmat[3][1] =  tmat[3][1]\n\t- tmp * tmat[0][1];\n      tmat[3][2] =  tmat[3][2]\n\t- tmp * tmat[0][2];\n      tmat[3][3] =  tmat[3][3]\n\t- tmp * tmat[0][3];\n      tmat[3][4] =  tmat[3][4]\n\t- tmp * tmat[0][4];\n      tv[i][j][3] = tv[i][j][3]\n\t- tv[i][j][0] * tmp;\n\n      tmp = tmp1 * tmat[4][0];\n      tmat[4][1] =  tmat[4][1]\n\t- tmp * tmat[0][1];\n      tmat[4][2] =  tmat[4][2]\n\t- tmp * tmat[0][2];\n      tmat[4][3] =  tmat[4][3]\n\t- tmp * tmat[0][3];\n      tmat[4][4] =  tmat[4][4]\n\t- tmp * tmat[0][4];\n      tv[i][j][4] = tv[i][j][4]\n\t- tv[i][j][0] * tmp;\n\n      tmp1 = 1.0 / tmat[1][1];\n      tmp = tmp1 * tmat[2][1];\n      tmat[2][2] =  tmat[2][2]\n\t- tmp * tmat[1][2];\n      tmat[2][3] =  tmat[2][3]\n\t- tmp * tmat[1][3];\n      tmat[2][4] =  tmat[2][4]\n\t- tmp * tmat[1][4];\n      tv[i][j][2] = tv[i][j][2]\n\t- tv[i][j][1] * tmp;\n\n      tmp = tmp1 * tmat[3][1];\n      tmat[3][2] =  tmat[3][2]\n\t- tmp * tmat[1][2];\n      tmat[3][3] =  tmat[3][3]\n\t- tmp * tmat[1][3];\n      tmat[3][4] =  tmat[3][4]\n\t- tmp * tmat[1][4];\n      tv[i][j][3] = tv[i][j][3]\n\t- tv[i][j][1] * tmp;\n\n      tmp = tmp1 * tmat[4][1];\n      tmat[4][2] =  tmat[4][2]\n\t- tmp * tmat[1][2];\n      tmat[4][3] =  tmat[4][3]\n\t- tmp * tmat[1][3];\n      tmat[4][4] =  tmat[4][4]\n\t- tmp * tmat[1][4];\n      tv[i][j][4] = tv[i][j][4]\n\t- tv[i][j][1] * tmp;\n\n      tmp1 = 1.0 / tmat[2][2];\n      tmp = tmp1 * tmat[3][2];\n      tmat[3][3] =  tmat[3][3]\n\t- tmp * tmat[2][3];\n      tmat[3][4] =  tmat[3][4]\n\t- tmp * tmat[2][4];\n      tv[i][j][3] = tv[i][j][3]\n\t- tv[i][j][2] * tmp;\n\n      tmp = tmp1 * tmat[4][2];\n      tmat[4][3] =  tmat[4][3]\n\t- tmp * tmat[2][3];\n      tmat[4][4] =  tmat[4][4]\n\t- tmp * tmat[2][4];\n      tv[i][j][4] = tv[i][j][4]\n\t- tv[i][j][2] * tmp;\n\n      tmp1 = 1.0 / tmat[3][3];\n      tmp = tmp1 * tmat[4][3];\n      tmat[4][4] =  tmat[4][4]\n\t- tmp * tmat[3][4];\n      tv[i][j][4] = tv[i][j][4]\n\t- tv[i][j][3] * tmp;\n\n      tv[i][j][4] = tv[i][j][4]\n\t/ tmat[4][4];\n\n      tv[i][j][3] = tv[i][j][3]\n\t- tmat[3][4] * tv[i][j][4];\n      tv[i][j][3] = tv[i][j][3]\n\t/ tmat[3][3];\n\n      tv[i][j][2] = tv[i][j][2]\n\t- tmat[2][3] * tv[i][j][3]\n\t- tmat[2][4] * tv[i][j][4];\n      tv[i][j][2] = tv[i][j][2]\n\t/ tmat[2][2];\n\n      tv[i][j][1] = tv[i][j][1]\n\t- tmat[1][2] * tv[i][j][2]\n\t- tmat[1][3] * tv[i][j][3]\n\t- tmat[1][4] * tv[i][j][4];\n      tv[i][j][1] = tv[i][j][1]\n\t/ tmat[1][1];\n\n      tv[i][j][0] = tv[i][j][0]\n\t- tmat[0][1] * tv[i][j][1]\n\t- tmat[0][2] * tv[i][j][2]\n\t- tmat[0][3] * tv[i][j][3]\n\t- tmat[0][4] * tv[i][j][4];\n      tv[i][j][0] = tv[i][j][0]\n\t/ tmat[0][0];\n\n      v[i][j][k][0] = v[i][j][k][0] - tv[i][j][0];\n      v[i][j][k][1] = v[i][j][k][1] - tv[i][j][1];\n      v[i][j][k][2] = v[i][j][k][2] - tv[i][j][2];\n      v[i][j][k][3] = v[i][j][k][3] - tv[i][j][3];\n      v[i][j][k][4] = v[i][j][k][4] - tv[i][j][4];\n    }\n    \n#if defined(_OPENMP)    \n    if (i != iend) flag[i+1] = 0;\n    if (i != ist) flag[i] = 1;\n#pragma omp flush(flag)\n#endif /* _OPENMP */    \n#endif /* _OPENMP */    \n  }\n}\n\n\nstatic void domain(void) {\n\n\n  nx = nx0;\n  ny = ny0;\n  nz = nz0;\n\n  if ( nx < 4 || ny < 4 || nz < 4 ) {\n    printf(\"     SUBDOMAIN SIZE IS TOO SMALL - \\n\"\n\t   \"     ADJUST PROBLEM SIZE OR NUMBER OF PROCESSORS\\n\"\n\t   \"     SO THAT NX, NY AND NZ ARE GREATER THAN OR EQUAL\\n\"\n\t   \"     TO 4 THEY ARE CURRENTLY%3d%3d%3d\\n\", nx, ny, nz);\n    exit(1);\n  }\n\n  if ( nx > ISIZ1 || ny > ISIZ2 || nz > ISIZ3 ) {\n    printf(\"     SUBDOMAIN SIZE IS TOO LARGE - \\n\"\n\t   \"     ADJUST PROBLEM SIZE OR NUMBER OF PROCESSORS\\n\"\n\t   \"     SO THAT NX, NY AND NZ ARE LESS THAN OR EQUAL TO \\n\"\n\t   \"     ISIZ1, ISIZ2 AND ISIZ3 RESPECTIVELY.  THEY ARE\\n\"\n\t   \"     CURRENTLY%4d%4d%4d\\n\", nx, ny, nz);\n    exit(1);\n  }\n\n  ist = 1;\n  iend = nx - 2;\n\n  jst = 1;\n  jend = ny - 2;\n}\n\n\nstatic void erhs(void) {\n\n#pragma omp parallel\n{\n\n\n  int i, j, k, m;\n  int iglob, jglob;\n  int L1, L2;\n  int ist1, iend1;\n  int jst1, jend1;\n  double  dsspm;\n  double  xi, eta, zeta;\n  double  q;\n  double  u21, u31, u41;\n  double  tmp;\n  double  u21i, u31i, u41i, u51i;\n  double  u21j, u31j, u41j, u51j;\n  double  u21k, u31k, u41k, u51k;\n  double  u21im1, u31im1, u41im1, u51im1;\n  double  u21jm1, u31jm1, u41jm1, u51jm1;\n  double  u21km1, u31km1, u41km1, u51km1;\n\n  dsspm = dssp;\n\n#pragma omp for\n  for (i = 0; i < nx; i++) {\n    for (j = 0; j < ny; j++) {\n      for (k = 0; k < nz; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  frct[i][j][k][m] = 0.0;\n\t}\n      }\n    }\n  }\n\n#pragma omp for\n  for (i = 0; i < nx; i++) {\n    iglob = i;\n    xi = ( (double)(iglob) ) / ( nx0 - 1 );\n    for (j = 0; j < ny; j++) {\n      jglob = j;\n      eta = ( (double)(jglob) ) / ( ny0 - 1 );\n      for (k = 0; k < nz; k++) {\n\tzeta = ( (double)(k) ) / ( nz - 1 );\n\tfor (m = 0; m < 5; m++) {\n\t  rsd[i][j][k][m] =  ce[m][0]\n\t    + ce[m][1] * xi\n\t    + ce[m][2] * eta\n\t    + ce[m][3] * zeta\n\t    + ce[m][4] * xi * xi\n\t    + ce[m][5] * eta * eta\n\t    + ce[m][6] * zeta * zeta\n\t    + ce[m][7] * xi * xi * xi\n\t    + ce[m][8] * eta * eta * eta\n\t    + ce[m][9] * zeta * zeta * zeta\n\t    + ce[m][10] * xi * xi * xi * xi\n\t    + ce[m][11] * eta * eta * eta * eta\n\t    + ce[m][12] * zeta * zeta * zeta * zeta;\n\t}\n      }\n    }\n  }\n\n\n  L1 = 0;\n  L2 = nx-1;\n\n#pragma omp for\n  for (i = L1; i <= L2; i++) {\n    for (j = jst; j <= jend; j++) {\n      for (k = 1; k < nz - 1; k++) {\n\tflux[i][j][k][0] = rsd[i][j][k][1];\n\tu21 = rsd[i][j][k][1] / rsd[i][j][k][0];\n\tq = 0.50 * (  rsd[i][j][k][1] * rsd[i][j][k][1]\n\t\t      + rsd[i][j][k][2] * rsd[i][j][k][2]\n\t\t      + rsd[i][j][k][3] * rsd[i][j][k][3] )\n\t  / rsd[i][j][k][0];\n\tflux[i][j][k][1] = rsd[i][j][k][1] * u21 + C2 * \n\t  ( rsd[i][j][k][4] - q );\n\tflux[i][j][k][2] = rsd[i][j][k][2] * u21;\n\tflux[i][j][k][3] = rsd[i][j][k][3] * u21;\n\tflux[i][j][k][4] = ( C1 * rsd[i][j][k][4] - C2 * q ) * u21;\n      }\n    }\n  }\n\n#pragma omp for\n  for (j = jst; j <= jend; j++) {\n    for (k = 1; k <= nz - 2; k++) {\n      for (i = ist; i <= iend; i++) {\n\tfor (m = 0; m < 5; m++) {\n\t  frct[i][j][k][m] =  frct[i][j][k][m]\n\t    - tx2 * ( flux[i+1][j][k][m] - flux[i-1][j][k][m] );\n\t}\n      }\n      for (i = ist; i <= L2; i++) {\n\ttmp = 1.0 / rsd[i][j][k][0];\n\n\tu21i = tmp * rsd[i][j][k][1];\n\tu31i = tmp * rsd[i][j][k][2];\n\tu41i = tmp * rsd[i][j][k][3];\n\tu51i = tmp * rsd[i][j][k][4];\n\n\ttmp = 1.0 / rsd[i-1][j][k][0];\n\n\tu21im1 = tmp * rsd[i-1][j][k][1];\n\tu31im1 = tmp * rsd[i-1][j][k][2];\n\tu41im1 = tmp * rsd[i-1][j][k][3];\n\tu51im1 = tmp * rsd[i-1][j][k][4];\n\n\tflux[i][j][k][1] = (4.0/3.0) * tx3 * \n\t  ( u21i - u21im1 );\n\tflux[i][j][k][2] = tx3 * ( u31i - u31im1 );\n\tflux[i][j][k][3] = tx3 * ( u41i - u41im1 );\n\tflux[i][j][k][4] = 0.50 * ( 1.0 - C1*C5 )\n\t  * tx3 * ( ( u21i * u21i + u31i * u31i + u41i * u41i )\n\t\t    - ( u21im1*u21im1 + u31im1*u31im1 + u41im1*u41im1 ) )\n\t  + (1.0/6.0)\n\t  * tx3 * ( u21i*u21i - u21im1*u21im1 )\n\t  + C1 * C5 * tx3 * ( u51i - u51im1 );\n      }\n\n      for (i = ist; i <= iend; i++) {\n\tfrct[i][j][k][0] = frct[i][j][k][0]\n\t  + dx1 * tx1 * (            rsd[i-1][j][k][0]\n\t\t\t\t     - 2.0 * rsd[i][j][k][0]\n\t\t\t\t     +       \t    rsd[i+1][j][k][0] );\n\tfrct[i][j][k][1] = frct[i][j][k][1]\n\t  + tx3 * C3 * C4 * ( flux[i+1][j][k][1] - flux[i][j][k][1] )\n\t  + dx2 * tx1 * (            rsd[i-1][j][k][1]\n\t\t\t\t     - 2.0 * rsd[i][j][k][1]\n\t\t\t\t     +           rsd[i+1][j][k][1] );\n\tfrct[i][j][k][2] = frct[i][j][k][2]\n\t  + tx3 * C3 * C4 * ( flux[i+1][j][k][2] - flux[i][j][k][2] )\n\t  + dx3 * tx1 * (            rsd[i-1][j][k][2]\n\t\t\t\t     - 2.0 * rsd[i][j][k][2]\n\t\t\t\t     +           rsd[i+1][j][k][2] );\n\tfrct[i][j][k][3] = frct[i][j][k][3]\n\t  + tx3 * C3 * C4 * ( flux[i+1][j][k][3] - flux[i][j][k][3] )\n\t  + dx4 * tx1 * (            rsd[i-1][j][k][3]\n\t\t\t\t     - 2.0 * rsd[i][j][k][3]\n\t\t\t\t     +           rsd[i+1][j][k][3] );\n\tfrct[i][j][k][4] = frct[i][j][k][4]\n\t  + tx3 * C3 * C4 * ( flux[i+1][j][k][4] - flux[i][j][k][4] )\n\t  + dx5 * tx1 * (            rsd[i-1][j][k][4]\n\t\t\t\t     - 2.0 * rsd[i][j][k][4]\n\t\t\t\t     +           rsd[i+1][j][k][4] );\n      }\n\n      for (m = 0; m < 5; m++) {\n\tfrct[1][j][k][m] = frct[1][j][k][m]\n\t  - dsspm * ( + 5.0 * rsd[1][j][k][m]\n\t\t      - 4.0 * rsd[2][j][k][m]\n\t\t      +           rsd[3][j][k][m] );\n\tfrct[2][j][k][m] = frct[2][j][k][m]\n\t  - dsspm * ( - 4.0 * rsd[1][j][k][m]\n\t\t      + 6.0 * rsd[2][j][k][m]\n\t\t      - 4.0 * rsd[3][j][k][m]\n\t\t      +           rsd[4][j][k][m] );\n      }\n\n      ist1 = 3;\n      iend1 = nx - 4;\n      for (i = ist1; i <=iend1; i++) {\n\tfor (m = 0; m < 5; m++) {\n\t  frct[i][j][k][m] = frct[i][j][k][m]\n\t    - dsspm * (            rsd[i-2][j][k][m]\n\t\t\t\t   - 4.0 * rsd[i-1][j][k][m]\n\t\t\t\t   + 6.0 * rsd[i][j][k][m]\n\t\t\t\t   - 4.0 * rsd[i+1][j][k][m]\n\t\t\t\t   +           rsd[i+2][j][k][m] );\n\t}\n      }\n\n      for (m = 0; m < 5; m++) {\n\tfrct[nx-3][j][k][m] = frct[nx-3][j][k][m]\n\t  - dsspm * (             rsd[nx-5][j][k][m]\n\t\t\t\t  - 4.0 * rsd[nx-4][j][k][m]\n\t\t\t\t  + 6.0 * rsd[nx-3][j][k][m]\n\t\t\t\t  - 4.0 * rsd[nx-2][j][k][m]  );\n\tfrct[nx-2][j][k][m] = frct[nx-2][j][k][m]\n\t  - dsspm * (             rsd[nx-4][j][k][m]\n\t\t\t\t  - 4.0 * rsd[nx-3][j][k][m]\n\t\t\t\t  + 5.0 * rsd[nx-2][j][k][m] );\n      }\n    }\n  }\n\n\n  L1 = 0;\n  L2 = ny-1;\n\n#pragma omp for\n  for (i = ist; i <= iend; i++) {\n    for (j = L1; j <= L2; j++) {\n      for (k = 1; k <= nz - 2; k++) {\n\tflux[i][j][k][0] = rsd[i][j][k][2];\n\tu31 = rsd[i][j][k][2] / rsd[i][j][k][0];\n\tq = 0.50 * (  rsd[i][j][k][1] * rsd[i][j][k][1]\n\t\t      + rsd[i][j][k][2] * rsd[i][j][k][2]\n\t\t      + rsd[i][j][k][3] * rsd[i][j][k][3] )\n\t  / rsd[i][j][k][0];\n\tflux[i][j][k][1] = rsd[i][j][k][1] * u31;\n\tflux[i][j][k][2] = rsd[i][j][k][2] * u31 + C2 * \n\t  ( rsd[i][j][k][4] - q );\n\tflux[i][j][k][3] = rsd[i][j][k][3] * u31;\n\tflux[i][j][k][4] = ( C1 * rsd[i][j][k][4] - C2 * q ) * u31;\n      }\n    }\n  }\n\n#pragma omp for\n  for (i = ist; i <= iend; i++) {\n    for (k = 1; k <= nz - 2; k++) {\n      for (j = jst; j <= jend; j++) {\n\tfor (m = 0; m < 5; m++) {\n\t  frct[i][j][k][m] =  frct[i][j][k][m]\n\t    - ty2 * ( flux[i][j+1][k][m] - flux[i][j-1][k][m] );\n\t}\n      }\n      for (j = jst; j <= L2; j++) {\n\ttmp = 1.0 / rsd[i][j][k][0];\n\n\tu21j = tmp * rsd[i][j][k][1];\n\tu31j = tmp * rsd[i][j][k][2];\n\tu41j = tmp * rsd[i][j][k][3];\n\tu51j = tmp * rsd[i][j][k][4];\n\n\ttmp = 1.0 / rsd[i][j-1][k][0];\n\n\tu21jm1 = tmp * rsd[i][j-1][k][1];\n\tu31jm1 = tmp * rsd[i][j-1][k][2];\n\tu41jm1 = tmp * rsd[i][j-1][k][3];\n\tu51jm1 = tmp * rsd[i][j-1][k][4];\n\n\tflux[i][j][k][1] = ty3 * ( u21j - u21jm1 );\n\tflux[i][j][k][2] = (4.0/3.0) * ty3 * \n\t  ( u31j - u31jm1 );\n\tflux[i][j][k][3] = ty3 * ( u41j - u41jm1 );\n\tflux[i][j][k][4] = 0.50 * ( 1.0 - C1*C5 )\n\t  * ty3 * ( ( u21j  *u21j + u31j  *u31j + u41j  *u41j )\n\t\t    - ( u21jm1*u21jm1 + u31jm1*u31jm1 + u41jm1*u41jm1 ) )\n\t  + (1.0/6.0)\n\t  * ty3 * ( u31j*u31j - u31jm1*u31jm1 )\n\t  + C1 * C5 * ty3 * ( u51j - u51jm1 );\n      }\n\n      for (j = jst; j <= jend; j++) {\n\tfrct[i][j][k][0] = frct[i][j][k][0]\n\t  + dy1 * ty1 * (            rsd[i][j-1][k][0]\n\t\t\t\t     - 2.0 * rsd[i][j][k][0]\n\t\t\t\t     +           rsd[i][j+1][k][0] );\n\tfrct[i][j][k][1] = frct[i][j][k][1]\n\t  + ty3 * C3 * C4 * ( flux[i][j+1][k][1] - flux[i][j][k][1] )\n\t  + dy2 * ty1 * (            rsd[i][j-1][k][1]\n\t\t\t\t     - 2.0 * rsd[i][j][k][1]\n\t\t\t\t     +           rsd[i][j+1][k][1] );\n\tfrct[i][j][k][2] = frct[i][j][k][2]\n\t  + ty3 * C3 * C4 * ( flux[i][j+1][k][2] - flux[i][j][k][2] )\n\t  + dy3 * ty1 * (            rsd[i][j-1][k][2]\n\t\t\t\t     - 2.0 * rsd[i][j][k][2]\n\t\t\t\t     +           rsd[i][j+1][k][2] );\n\tfrct[i][j][k][3] = frct[i][j][k][3]\n\t  + ty3 * C3 * C4 * ( flux[i][j+1][k][3] - flux[i][j][k][3] )\n\t  + dy4 * ty1 * (            rsd[i][j-1][k][3]\n\t\t\t\t     - 2.0 * rsd[i][j][k][3]\n\t\t\t\t     +           rsd[i][j+1][k][3] );\n\tfrct[i][j][k][4] = frct[i][j][k][4]\n\t  + ty3 * C3 * C4 * ( flux[i][j+1][k][4] - flux[i][j][k][4] )\n\t  + dy5 * ty1 * (            rsd[i][j-1][k][4]\n\t\t\t\t     - 2.0 * rsd[i][j][k][4]\n\t\t\t\t     +           rsd[i][j+1][k][4] );\n      }\n\n      for (m = 0; m < 5; m++) {\n\tfrct[i][1][k][m] = frct[i][1][k][m]\n\t  - dsspm * ( + 5.0 * rsd[i][1][k][m]\n\t\t      - 4.0 * rsd[i][2][k][m]\n\t\t      +           rsd[i][3][k][m] );\n\tfrct[i][2][k][m] = frct[i][2][k][m]\n\t  - dsspm * ( - 4.0 * rsd[i][1][k][m]\n\t\t      + 6.0 * rsd[i][2][k][m]\n\t\t      - 4.0 * rsd[i][3][k][m]\n\t\t      +           rsd[i][4][k][m] );\n      }\n\n      jst1 = 3;\n      jend1 = ny - 4;\n\n      for (j = jst1; j <= jend1; j++) {\n\tfor (m = 0; m < 5; m++) {\n\t  frct[i][j][k][m] = frct[i][j][k][m]\n\t    - dsspm * (            rsd[i][j-2][k][m]\n\t\t\t\t   - 4.0 * rsd[i][j-1][k][m]\n\t\t\t\t   + 6.0 * rsd[i][j][k][m]\n\t\t\t\t   - 4.0 * rsd[i][j+1][k][m]\n\t\t\t\t   +           rsd[i][j+2][k][m] );\n\t}\n      }\n\n      for (m = 0; m < 5; m++) {\n\tfrct[i][ny-3][k][m] = frct[i][ny-3][k][m]\n\t  - dsspm * (             rsd[i][ny-5][k][m]\n\t\t\t\t  - 4.0 * rsd[i][ny-4][k][m]\n\t\t\t\t  + 6.0 * rsd[i][ny-3][k][m]\n\t\t\t\t  - 4.0 * rsd[i][ny-2][k][m]  );\n\tfrct[i][ny-2][k][m] = frct[i][ny-2][k][m]\n\t  - dsspm * (             rsd[i][ny-4][k][m]\n\t\t\t\t  - 4.0 * rsd[i][ny-3][k][m]\n\t\t\t\t  + 5.0 * rsd[i][ny-2][k][m]  );\n      }\n\n    }\n  }\n\n#pragma omp for\n  for (i = ist; i <= iend; i++) {\n    for (j = jst; j <= jend; j++) {\n      for (k = 0; k <= nz-1; k++) {\n\tflux[i][j][k][0] = rsd[i][j][k][3];\n\tu41 = rsd[i][j][k][3] / rsd[i][j][k][0];\n\tq = 0.50 * (  rsd[i][j][k][1] * rsd[i][j][k][1]\n\t\t      + rsd[i][j][k][2] * rsd[i][j][k][2]\n\t\t      + rsd[i][j][k][3] * rsd[i][j][k][3] )\n\t  / rsd[i][j][k][0];\n\tflux[i][j][k][1] = rsd[i][j][k][1] * u41;\n\tflux[i][j][k][2] = rsd[i][j][k][2] * u41;\n\tflux[i][j][k][3] = rsd[i][j][k][3] * u41 + C2 * \n\t  ( rsd[i][j][k][4] - q );\n\tflux[i][j][k][4] = ( C1 * rsd[i][j][k][4] - C2 * q ) * u41;\n      }\n\n      for (k = 1; k <= nz - 2; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  frct[i][j][k][m] =  frct[i][j][k][m]\n\t    - tz2 * ( flux[i][j][k+1][m] - flux[i][j][k-1][m] );\n\t}\n      }\n      for (k = 1; k <= nz-1; k++) {\n\ttmp = 1.0 / rsd[i][j][k][0];\n\n\tu21k = tmp * rsd[i][j][k][1];\n\tu31k = tmp * rsd[i][j][k][2];\n\tu41k = tmp * rsd[i][j][k][3];\n\tu51k = tmp * rsd[i][j][k][4];\n\n\ttmp = 1.0 / rsd[i][j][k-1][0];\n\n\tu21km1 = tmp * rsd[i][j][k-1][1];\n\tu31km1 = tmp * rsd[i][j][k-1][2];\n\tu41km1 = tmp * rsd[i][j][k-1][3];\n\tu51km1 = tmp * rsd[i][j][k-1][4];\n\n\tflux[i][j][k][1] = tz3 * ( u21k - u21km1 );\n\tflux[i][j][k][2] = tz3 * ( u31k - u31km1 );\n\tflux[i][j][k][3] = (4.0/3.0) * tz3 * ( u41k \n\t\t\t\t\t    - u41km1 );\n\tflux[i][j][k][4] = 0.50 * ( 1.0 - C1*C5 )\n\t  * tz3 * ( ( u21k  *u21k + u31k  *u31k + u41k  *u41k )\n\t\t    - ( u21km1*u21km1 + u31km1*u31km1 + u41km1*u41km1 ) )\n\t  + (1.0/6.0)\n\t  * tz3 * ( u41k*u41k - u41km1*u41km1 )\n\t  + C1 * C5 * tz3 * ( u51k - u51km1 );\n      }\n\n      for (k = 1; k <= nz - 2; k++) {\n\tfrct[i][j][k][0] = frct[i][j][k][0]\n\t  + dz1 * tz1 * (            rsd[i][j][k+1][0]\n\t\t\t\t     - 2.0 * rsd[i][j][k][0]\n\t\t\t\t     +           rsd[i][j][k-1][0] );\n\tfrct[i][j][k][1] = frct[i][j][k][1]\n\t  + tz3 * C3 * C4 * ( flux[i][j][k+1][1] - flux[i][j][k][1] )\n\t  + dz2 * tz1 * (            rsd[i][j][k+1][1]\n\t\t\t\t     - 2.0 * rsd[i][j][k][1]\n\t\t\t\t     +           rsd[i][j][k-1][1] );\n\tfrct[i][j][k][2] = frct[i][j][k][2]\n\t  + tz3 * C3 * C4 * ( flux[i][j][k+1][2] - flux[i][j][k][2] )\n\t  + dz3 * tz1 * (            rsd[i][j][k+1][2]\n\t\t\t\t     - 2.0 * rsd[i][j][k][2]\n\t\t\t\t     +           rsd[i][j][k-1][2] );\n\tfrct[i][j][k][3] = frct[i][j][k][3]\n\t  + tz3 * C3 * C4 * ( flux[i][j][k+1][3] - flux[i][j][k][3] )\n\t  + dz4 * tz1 * (            rsd[i][j][k+1][3]\n\t\t\t\t     - 2.0 * rsd[i][j][k][3]\n\t\t\t\t     +           rsd[i][j][k-1][3] );\n\tfrct[i][j][k][4] = frct[i][j][k][4]\n\t  + tz3 * C3 * C4 * ( flux[i][j][k+1][4] - flux[i][j][k][4] )\n\t  + dz5 * tz1 * (            rsd[i][j][k+1][4]\n\t\t\t\t     - 2.0 * rsd[i][j][k][4]\n\t\t\t\t     +           rsd[i][j][k-1][4] );\n      }\n\n      for (m = 0; m < 5; m++) {\n\tfrct[i][j][1][m] = frct[i][j][1][m]\n\t  - dsspm * ( + 5.0 * rsd[i][j][1][m]\n\t\t      - 4.0 * rsd[i][j][2][m]\n\t\t      +           rsd[i][j][3][m] );\n\tfrct[i][j][2][m] = frct[i][j][2][m]\n\t  - dsspm * (- 4.0 * rsd[i][j][1][m]\n\t\t     + 6.0 * rsd[i][j][2][m]\n\t\t     - 4.0 * rsd[i][j][3][m]\n\t\t     +           rsd[i][j][4][m] );\n      }\n\n      for (k = 3; k <= nz - 4; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  frct[i][j][k][m] = frct[i][j][k][m]\n\t    - dsspm * (           rsd[i][j][k-2][m]\n\t\t\t\t  - 4.0 * rsd[i][j][k-1][m]\n\t\t\t\t  + 6.0 * rsd[i][j][k][m]\n\t\t\t\t  - 4.0 * rsd[i][j][k+1][m]\n\t\t\t\t  +           rsd[i][j][k+2][m] );\n\t}\n      }\n\n      for (m = 0; m < 5; m++) {\n\tfrct[i][j][nz-3][m] = frct[i][j][nz-3][m]\n\t  - dsspm * (            rsd[i][j][nz-5][m]\n\t\t\t\t - 4.0 * rsd[i][j][nz-4][m]\n\t\t\t\t + 6.0 * rsd[i][j][nz-3][m]\n\t\t\t\t - 4.0 * rsd[i][j][nz-2][m]  );\n        frct[i][j][nz-2][m] = frct[i][j][nz-2][m]\n\t  - dsspm * (             rsd[i][j][nz-4][m]\n\t\t\t\t  - 4.0 * rsd[i][j][nz-3][m]\n\t\t\t\t  + 5.0 * rsd[i][j][nz-2][m]  );\n      }\n    }\n  }\n}\n}\n\nstatic void error(void) {\n\n\n  int i, j, k, m;\n  int iglob, jglob;\n  double  tmp;\n  double  u000ijk[5];\n\n  for (m = 0; m < 5; m++) {\n    errnm[m] = 0.0;\n  }\n  \n  for (i = ist; i <= iend; i++) {\n    iglob = i;\n    for (j = jst; j <= jend; j++) {\n      jglob = j;\n      for (k = 1; k <= nz-2; k++) {\n\texact( iglob, jglob, k, u000ijk );\n\tfor (m = 0; m < 5; m++) {\n\t  tmp = ( u000ijk[m] - u[i][j][k][m] );\n\t  errnm[m] = errnm[m] + tmp *tmp;\n\t}\n      }\n    }\n  }\n\n  for (m = 0; m < 5; m++) {\n    errnm[m] = sqrt ( errnm[m] / ( (nx0-2)*(ny0-2)*(nz0-2) ) );\n  }\n}\n\n\nstatic void exact( int i, int j, int k, double u000ijk[5] ) {\n\n\n  int m;\n  double xi, eta, zeta;\n\n  xi  = ((double)i) / (nx0 - 1);\n  eta  = ((double)j) / (ny0 - 1);\n  zeta = ((double)k) / (nz - 1);\n\n  for (m = 0; m < 5; m++) {\n    u000ijk[m] =  ce[m][0]\n      + ce[m][1] * xi\n      + ce[m][2] * eta\n      + ce[m][3] * zeta\n      + ce[m][4] * xi * xi\n      + ce[m][5] * eta * eta\n      + ce[m][6] * zeta * zeta\n      + ce[m][7] * xi * xi * xi\n      + ce[m][8] * eta * eta * eta\n      + ce[m][9] * zeta * zeta * zeta\n      + ce[m][10] * xi * xi * xi * xi\n      + ce[m][11] * eta * eta * eta * eta\n      + ce[m][12] * zeta * zeta * zeta * zeta;\n  }\n}\n\n\nstatic void jacld(int k) {\n\n\n  int i, j;\n  double  r43;\n  double  c1345;\n  double  c34;\n  double  tmp1, tmp2, tmp3;\n\n  r43 = ( 4.0 / 3.0 );\n  c1345 = C1 * C3 * C4 * C5;\n  c34 = C3 * C4;\n\n#pragma omp for nowait schedule(static)\n  for (i = ist; i <= iend; i++) {\n    for (j = jst; j <= jend; j++) {\n\n      tmp1 = 1.0 / u[i][j][k][0];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n\n      d[i][j][0][0] =  1.0\n\t+ dt * 2.0 * (   tx1 * dx1\n\t\t\t + ty1 * dy1\n\t\t\t + tz1 * dz1 );\n      d[i][j][0][1] =  0.0;\n      d[i][j][0][2] =  0.0;\n      d[i][j][0][3] =  0.0;\n      d[i][j][0][4] =  0.0;\n\n      d[i][j][1][0] =  dt * 2.0\n\t* (  tx1 * ( - r43 * c34 * tmp2 * u[i][j][k][1] )\n\t     + ty1 * ( -       c34 * tmp2 * u[i][j][k][1] )\n\t     + tz1 * ( -       c34 * tmp2 * u[i][j][k][1] ) );\n      d[i][j][1][1] =  1.0\n\t+ dt * 2.0 \n\t* (  tx1 * r43 * c34 * tmp1\n\t     + ty1 *       c34 * tmp1\n\t     + tz1 *       c34 * tmp1 )\n\t+ dt * 2.0 * (   tx1 * dx2\n\t\t\t + ty1 * dy2\n\t\t\t + tz1 * dz2  );\n      d[i][j][1][2] = 0.0;\n      d[i][j][1][3] = 0.0;\n      d[i][j][1][4] = 0.0;\n\n      d[i][j][2][0] = dt * 2.0\n\t* (  tx1 * ( -       c34 * tmp2 * u[i][j][k][2] )\n\t     + ty1 * ( - r43 * c34 * tmp2 * u[i][j][k][2] )\n\t     + tz1 * ( -       c34 * tmp2 * u[i][j][k][2] ) );\n      d[i][j][2][1] = 0.0;\n      d[i][j][2][2] = 1.0\n\t+ dt * 2.0\n\t* (  tx1 *       c34 * tmp1\n\t     + ty1 * r43 * c34 * tmp1\n\t     + tz1 *       c34 * tmp1 )\n\t+ dt * 2.0 * (  tx1 * dx3\n\t\t\t+ ty1 * dy3\n\t\t\t+ tz1 * dz3 );\n      d[i][j][2][3] = 0.0;\n      d[i][j][2][4] = 0.0;\n\n      d[i][j][3][0] = dt * 2.0\n\t* (  tx1 * ( -       c34 * tmp2 * u[i][j][k][3] )\n\t     + ty1 * ( -       c34 * tmp2 * u[i][j][k][3] )\n\t     + tz1 * ( - r43 * c34 * tmp2 * u[i][j][k][3] ) );\n      d[i][j][3][1] = 0.0;\n      d[i][j][3][2] = 0.0;\n      d[i][j][3][3] = 1.0\n\t+ dt * 2.0\n\t* (  tx1 *       c34 * tmp1\n\t     + ty1 *       c34 * tmp1\n\t     + tz1 * r43 * c34 * tmp1 )\n\t+ dt * 2.0 * (  tx1 * dx4\n\t\t\t+ ty1 * dy4\n\t\t\t+ tz1 * dz4 );\n      d[i][j][3][4] = 0.0;\n\n      d[i][j][4][0] = dt * 2.0\n\t* ( tx1 * ( - ( r43*c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][1]) )\n\t\t    - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][2]) )\n\t\t    - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][3]) )\n\t\t    - ( c1345 ) * tmp2 * u[i][j][k][4] )\n\t    + ty1 * ( - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][1]) )\n\t\t      - ( r43*c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][2]) )\n\t\t      - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][3]) )\n\t\t      - ( c1345 ) * tmp2 * u[i][j][k][4] )\n\t    + tz1 * ( - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][1]) )\n\t\t      - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][2]) )\n\t\t      - ( r43*c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][3]) )\n\t\t      - ( c1345 ) * tmp2 * u[i][j][k][4] ) );\n      d[i][j][4][1] = dt * 2.0\n\t* ( tx1 * ( r43*c34 - c1345 ) * tmp2 * u[i][j][k][1]\n\t    + ty1 * (     c34 - c1345 ) * tmp2 * u[i][j][k][1]\n\t    + tz1 * (     c34 - c1345 ) * tmp2 * u[i][j][k][1] );\n      d[i][j][4][2] = dt * 2.0\n\t* ( tx1 * ( c34 - c1345 ) * tmp2 * u[i][j][k][2]\n\t    + ty1 * ( r43*c34 -c1345 ) * tmp2 * u[i][j][k][2]\n\t    + tz1 * ( c34 - c1345 ) * tmp2 * u[i][j][k][2] );\n      d[i][j][4][3] = dt * 2.0\n\t* ( tx1 * ( c34 - c1345 ) * tmp2 * u[i][j][k][3]\n\t    + ty1 * ( c34 - c1345 ) * tmp2 * u[i][j][k][3]\n\t    + tz1 * ( r43*c34 - c1345 ) * tmp2 * u[i][j][k][3] );\n      d[i][j][4][4] = 1.0\n\t+ dt * 2.0 * ( tx1 * c1345 * tmp1\n\t\t       + ty1 * c1345 * tmp1\n\t\t       + tz1 * c1345 * tmp1 )\n        + dt * 2.0 * (  tx1 * dx5\n\t\t\t+  ty1 * dy5\n\t\t\t+  tz1 * dz5 );\n\n      tmp1 = 1.0 / u[i][j][k-1][0];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n\n      a[i][j][0][0] = - dt * tz1 * dz1;\n      a[i][j][0][1] =   0.0;\n      a[i][j][0][2] =   0.0;\n      a[i][j][0][3] = - dt * tz2;\n      a[i][j][0][4] =   0.0;\n\n      a[i][j][1][0] = - dt * tz2\n\t* ( - ( u[i][j][k-1][1]*u[i][j][k-1][3] ) * tmp2 )\n\t- dt * tz1 * ( - c34 * tmp2 * u[i][j][k-1][1] );\n      a[i][j][1][1] = - dt * tz2 * ( u[i][j][k-1][3] * tmp1 )\n\t- dt * tz1 * c34 * tmp1\n\t- dt * tz1 * dz2 ;\n      a[i][j][1][2] = 0.0;\n      a[i][j][1][3] = - dt * tz2 * ( u[i][j][k-1][1] * tmp1 );\n      a[i][j][1][4] = 0.0;\n\n      a[i][j][2][0] = - dt * tz2\n\t* ( - ( u[i][j][k-1][2]*u[i][j][k-1][3] ) * tmp2 )\n\t- dt * tz1 * ( - c34 * tmp2 * u[i][j][k-1][2] );\n      a[i][j][2][1] = 0.0;\n      a[i][j][2][2] = - dt * tz2 * ( u[i][j][k-1][3] * tmp1 )\n\t- dt * tz1 * ( c34 * tmp1 )\n\t- dt * tz1 * dz3;\n      a[i][j][2][3] = - dt * tz2 * ( u[i][j][k-1][2] * tmp1 );\n      a[i][j][2][4] = 0.0;\n\n      a[i][j][3][0] = - dt * tz2\n\t* ( - ( u[i][j][k-1][3] * tmp1 ) *( u[i][j][k-1][3] * tmp1 )\n\t    + 0.50 * C2\n\t    * ( ( u[i][j][k-1][1] * u[i][j][k-1][1]\n\t\t  + u[i][j][k-1][2] * u[i][j][k-1][2]\n\t\t  + u[i][j][k-1][3] * u[i][j][k-1][3] ) * tmp2 ) )\n\t- dt * tz1 * ( - r43 * c34 * tmp2 * u[i][j][k-1][3] );\n      a[i][j][3][1] = - dt * tz2\n\t* ( - C2 * ( u[i][j][k-1][1] * tmp1 ) );\n      a[i][j][3][2] = - dt * tz2\n\t* ( - C2 * ( u[i][j][k-1][2] * tmp1 ) );\n      a[i][j][3][3] = - dt * tz2 * ( 2.0 - C2 )\n\t* ( u[i][j][k-1][3] * tmp1 )\n\t- dt * tz1 * ( r43 * c34 * tmp1 )\n\t- dt * tz1 * dz4;\n      a[i][j][3][4] = - dt * tz2 * C2;\n\n      a[i][j][4][0] = - dt * tz2\n\t* ( ( C2 * (  u[i][j][k-1][1] * u[i][j][k-1][1]\n                      + u[i][j][k-1][2] * u[i][j][k-1][2]\n                      + u[i][j][k-1][3] * u[i][j][k-1][3] ) * tmp2\n\t      - C1 * ( u[i][j][k-1][4] * tmp1 ) )\n\t    * ( u[i][j][k-1][3] * tmp1 ) )\n\t- dt * tz1\n\t* ( - ( c34 - c1345 ) * tmp3 * (u[i][j][k-1][1]*u[i][j][k-1][1])\n\t    - ( c34 - c1345 ) * tmp3 * (u[i][j][k-1][2]*u[i][j][k-1][2])\n\t    - ( r43*c34 - c1345 )* tmp3 * (u[i][j][k-1][3]*u[i][j][k-1][3])\n\t    - c1345 * tmp2 * u[i][j][k-1][4] );\n      a[i][j][4][1] = - dt * tz2\n\t* ( - C2 * ( u[i][j][k-1][1]*u[i][j][k-1][3] ) * tmp2 )\n\t- dt * tz1 * ( c34 - c1345 ) * tmp2 * u[i][j][k-1][1];\n      a[i][j][4][2] = - dt * tz2\n\t* ( - C2 * ( u[i][j][k-1][2]*u[i][j][k-1][3] ) * tmp2 )\n\t- dt * tz1 * ( c34 - c1345 ) * tmp2 * u[i][j][k-1][2];\n      a[i][j][4][3] = - dt * tz2\n\t* ( C1 * ( u[i][j][k-1][4] * tmp1 )\n            - 0.50 * C2\n            * ( (  u[i][j][k-1][1]*u[i][j][k-1][1]\n\t\t   + u[i][j][k-1][2]*u[i][j][k-1][2]\n\t\t   + 3.0*u[i][j][k-1][3]*u[i][j][k-1][3] ) * tmp2 ) )\n\t- dt * tz1 * ( r43*c34 - c1345 ) * tmp2 * u[i][j][k-1][3];\n      a[i][j][4][4] = - dt * tz2\n\t* ( C1 * ( u[i][j][k-1][3] * tmp1 ) )\n\t- dt * tz1 * c1345 * tmp1\n\t- dt * tz1 * dz5;\n\n      tmp1 = 1.0 / u[i][j-1][k][0];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n\n      b[i][j][0][0] = - dt * ty1 * dy1;\n      b[i][j][0][1] =   0.0;\n      b[i][j][0][2] = - dt * ty2;\n      b[i][j][0][3] =   0.0;\n      b[i][j][0][4] =   0.0;\n\n      b[i][j][1][0] = - dt * ty2\n\t* ( - ( u[i][j-1][k][1]*u[i][j-1][k][2] ) * tmp2 )\n\t- dt * ty1 * ( - c34 * tmp2 * u[i][j-1][k][1] );\n      b[i][j][1][1] = - dt * ty2 * ( u[i][j-1][k][2] * tmp1 )\n\t- dt * ty1 * ( c34 * tmp1 )\n\t- dt * ty1 * dy2;\n      b[i][j][1][2] = - dt * ty2 * ( u[i][j-1][k][1] * tmp1 );\n      b[i][j][1][3] = 0.0;\n      b[i][j][1][4] = 0.0;\n\n      b[i][j][2][0] = - dt * ty2\n\t* ( - ( u[i][j-1][k][2] * tmp1 ) *( u[i][j-1][k][2] * tmp1 )\n\t    + 0.50 * C2 * ( (  u[i][j-1][k][1] * u[i][j-1][k][1]\n\t\t\t       + u[i][j-1][k][2] * u[i][j-1][k][2]\n\t\t\t       + u[i][j-1][k][3] * u[i][j-1][k][3] )\n\t\t\t    * tmp2 ) )\n\t- dt * ty1 * ( - r43 * c34 * tmp2 * u[i][j-1][k][2] );\n      b[i][j][2][1] = - dt * ty2\n\t* ( - C2 * ( u[i][j-1][k][1] * tmp1 ) );\n      b[i][j][2][2] = - dt * ty2 * ( ( 2.0 - C2 )\n\t\t\t\t  * ( u[i][j-1][k][2] * tmp1 ) )\n\t- dt * ty1 * ( r43 * c34 * tmp1 )\n\t- dt * ty1 * dy3;\n      b[i][j][2][3] = - dt * ty2\n\t* ( - C2 * ( u[i][j-1][k][3] * tmp1 ) );\n      b[i][j][2][4] = - dt * ty2 * C2;\n\n      b[i][j][3][0] = - dt * ty2\n\t* ( - ( u[i][j-1][k][2]*u[i][j-1][k][3] ) * tmp2 )\n\t- dt * ty1 * ( - c34 * tmp2 * u[i][j-1][k][3] );\n      b[i][j][3][1] = 0.0;\n      b[i][j][3][2] = - dt * ty2 * ( u[i][j-1][k][3] * tmp1 );\n      b[i][j][3][3] = - dt * ty2 * ( u[i][j-1][k][2] * tmp1 )\n\t- dt * ty1 * ( c34 * tmp1 )\n\t- dt * ty1 * dy4;\n      b[i][j][3][4] = 0.0;\n\n      b[i][j][4][0] = - dt * ty2\n\t* ( ( C2 * (  u[i][j-1][k][1] * u[i][j-1][k][1]\n\t\t      + u[i][j-1][k][2] * u[i][j-1][k][2]\n\t\t      + u[i][j-1][k][3] * u[i][j-1][k][3] ) * tmp2\n\t      - C1 * ( u[i][j-1][k][4] * tmp1 ) )\n\t    * ( u[i][j-1][k][2] * tmp1 ) )\n\t- dt * ty1\n\t* ( - (     c34 - c1345 )*tmp3*(pow2(u[i][j-1][k][1]))\n\t    - ( r43*c34 - c1345 )*tmp3*(pow2(u[i][j-1][k][2]))\n\t    - (     c34 - c1345 )*tmp3*(pow2(u[i][j-1][k][3]))\n\t    - c1345*tmp2*u[i][j-1][k][4] );\n      b[i][j][4][1] = - dt * ty2\n\t* ( - C2 * ( u[i][j-1][k][1]*u[i][j-1][k][2] ) * tmp2 )\n\t- dt * ty1\n\t* ( c34 - c1345 ) * tmp2 * u[i][j-1][k][1];\n      b[i][j][4][2] = - dt * ty2\n\t* ( C1 * ( u[i][j-1][k][4] * tmp1 )\n\t    - 0.50 * C2 \n\t    * ( (  u[i][j-1][k][1]*u[i][j-1][k][1]\n                   + 3.0 * u[i][j-1][k][2]*u[i][j-1][k][2]\n\t\t   + u[i][j-1][k][3]*u[i][j-1][k][3] ) * tmp2 ) )\n\t- dt * ty1\n\t* ( r43*c34 - c1345 ) * tmp2 * u[i][j-1][k][2];\n      b[i][j][4][3] = - dt * ty2\n\t* ( - C2 * ( u[i][j-1][k][2]*u[i][j-1][k][3] ) * tmp2 )\n\t- dt * ty1 * ( c34 - c1345 ) * tmp2 * u[i][j-1][k][3];\n      b[i][j][4][4] = - dt * ty2\n\t* ( C1 * ( u[i][j-1][k][2] * tmp1 ) )\n\t- dt * ty1 * c1345 * tmp1\n\t- dt * ty1 * dy5;\n\n      tmp1 = 1.0 / u[i-1][j][k][0];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n\n      c[i][j][0][0] = - dt * tx1 * dx1;\n      c[i][j][0][1] = - dt * tx2;\n      c[i][j][0][2] =   0.0;\n      c[i][j][0][3] =   0.0;\n      c[i][j][0][4] =   0.0;\n\n      c[i][j][1][0] = - dt * tx2\n\t* ( - ( u[i-1][j][k][1] * tmp1 ) *( u[i-1][j][k][1] * tmp1 )\n\t    + C2 * 0.50 * (  u[i-1][j][k][1] * u[i-1][j][k][1]\n                             + u[i-1][j][k][2] * u[i-1][j][k][2]\n                             + u[i-1][j][k][3] * u[i-1][j][k][3] ) * tmp2 )\n\t- dt * tx1 * ( - r43 * c34 * tmp2 * u[i-1][j][k][1] );\n      c[i][j][1][1] = - dt * tx2\n\t* ( ( 2.0 - C2 ) * ( u[i-1][j][k][1] * tmp1 ) )\n\t- dt * tx1 * ( r43 * c34 * tmp1 )\n\t- dt * tx1 * dx2;\n      c[i][j][1][2] = - dt * tx2\n\t* ( - C2 * ( u[i-1][j][k][2] * tmp1 ) );\n      c[i][j][1][3] = - dt * tx2\n\t* ( - C2 * ( u[i-1][j][k][3] * tmp1 ) );\n      c[i][j][1][4] = - dt * tx2 * C2;\n\n      c[i][j][2][0] = - dt * tx2\n\t* ( - ( u[i-1][j][k][1] * u[i-1][j][k][2] ) * tmp2 )\n\t- dt * tx1 * ( - c34 * tmp2 * u[i-1][j][k][2] );\n      c[i][j][2][1] = - dt * tx2 * ( u[i-1][j][k][2] * tmp1 );\n      c[i][j][2][2] = - dt * tx2 * ( u[i-1][j][k][1] * tmp1 )\n\t- dt * tx1 * ( c34 * tmp1 )\n\t- dt * tx1 * dx3;\n      c[i][j][2][3] = 0.0;\n      c[i][j][2][4] = 0.0;\n\n      c[i][j][3][0] = - dt * tx2\n\t* ( - ( u[i-1][j][k][1]*u[i-1][j][k][3] ) * tmp2 )\n\t- dt * tx1 * ( - c34 * tmp2 * u[i-1][j][k][3] );\n      c[i][j][3][1] = - dt * tx2 * ( u[i-1][j][k][3] * tmp1 );\n      c[i][j][3][2] = 0.0;\n      c[i][j][3][3] = - dt * tx2 * ( u[i-1][j][k][1] * tmp1 )\n\t- dt * tx1 * ( c34 * tmp1 )\n\t- dt * tx1 * dx4;\n      c[i][j][3][4] = 0.0;\n\n      c[i][j][4][0] = - dt * tx2\n\t* ( ( C2 * (  u[i-1][j][k][1] * u[i-1][j][k][1]\n\t\t      + u[i-1][j][k][2] * u[i-1][j][k][2]\n\t\t      + u[i-1][j][k][3] * u[i-1][j][k][3] ) * tmp2\n\t      - C1 * ( u[i-1][j][k][4] * tmp1 ) )\n\t    * ( u[i-1][j][k][1] * tmp1 ) )\n\t- dt * tx1\n\t* ( - ( r43*c34 - c1345 ) * tmp3 * ( pow2(u[i-1][j][k][1]) )\n\t    - (     c34 - c1345 ) * tmp3 * ( pow2(u[i-1][j][k][2]) )\n\t    - (     c34 - c1345 ) * tmp3 * ( pow2(u[i-1][j][k][3]) )\n\t    - c1345 * tmp2 * u[i-1][j][k][4] );\n      c[i][j][4][1] = - dt * tx2\n\t* ( C1 * ( u[i-1][j][k][4] * tmp1 )\n\t    - 0.50 * C2\n\t    * ( (  3.0*u[i-1][j][k][1]*u[i-1][j][k][1]\n\t\t   + u[i-1][j][k][2]*u[i-1][j][k][2]\n\t\t   + u[i-1][j][k][3]*u[i-1][j][k][3] ) * tmp2 ) )\n\t- dt * tx1\n\t* ( r43*c34 - c1345 ) * tmp2 * u[i-1][j][k][1];\n      c[i][j][4][2] = - dt * tx2\n\t* ( - C2 * ( u[i-1][j][k][2]*u[i-1][j][k][1] ) * tmp2 )\n\t- dt * tx1\n\t* (  c34 - c1345 ) * tmp2 * u[i-1][j][k][2];\n      c[i][j][4][3] = - dt * tx2\n\t* ( - C2 * ( u[i-1][j][k][3]*u[i-1][j][k][1] ) * tmp2 )\n\t- dt * tx1\n\t* (  c34 - c1345 ) * tmp2 * u[i-1][j][k][3];\n      c[i][j][4][4] = - dt * tx2\n\t* ( C1 * ( u[i-1][j][k][1] * tmp1 ) )\n\t- dt * tx1 * c1345 * tmp1\n\t- dt * tx1 * dx5;\n    }\n  }\n}\n\n\n\nstatic void jacu(int k) {\n\n\n  int i, j;\n  double  r43;\n  double  c1345;\n  double  c34;\n  double  tmp1, tmp2, tmp3;\n\n  r43 = ( 4.0 / 3.0 );\n  c1345 = C1 * C3 * C4 * C5;\n  c34 = C3 * C4;\n\n#pragma omp for nowait schedule(static)\n#if defined(_OPENMP)  \n  for (i = iend; i >= ist; i--) {\n      for (j = jend; j >= jst; j--) {\n#else\t  \n  for (i = ist; i <= iend; i++) {\n    for (j = jst; j <= jend; j++) {\n#endif\t\n\n      tmp1 = 1.0 / u[i][j][k][0];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n\n      d[i][j][0][0] =  1.0\n\t+ dt * 2.0 * (   tx1 * dx1\n\t\t\t + ty1 * dy1\n\t\t\t + tz1 * dz1 );\n      d[i][j][0][1] =  0.0;\n      d[i][j][0][2] =  0.0;\n      d[i][j][0][3] =  0.0;\n      d[i][j][0][4] =  0.0;\n\n      d[i][j][1][0] =  dt * 2.0\n\t* (  tx1 * ( - r43 * c34 * tmp2 * u[i][j][k][1] )\n\t     + ty1 * ( -       c34 * tmp2 * u[i][j][k][1] )\n\t     + tz1 * ( -       c34 * tmp2 * u[i][j][k][1] ) );\n      d[i][j][1][1] =  1.0\n\t+ dt * 2.0 \n\t* (  tx1 * r43 * c34 * tmp1\n\t     + ty1 *       c34 * tmp1\n\t     + tz1 *       c34 * tmp1 )\n\t+ dt * 2.0 * (   tx1 * dx2\n\t\t\t + ty1 * dy2\n\t\t\t + tz1 * dz2  );\n      d[i][j][1][2] = 0.0;\n      d[i][j][1][3] = 0.0;\n      d[i][j][1][4] = 0.0;\n\n      d[i][j][2][0] = dt * 2.0\n\t* (  tx1 * ( -       c34 * tmp2 * u[i][j][k][2] )\n\t     + ty1 * ( - r43 * c34 * tmp2 * u[i][j][k][2] )\n\t     + tz1 * ( -       c34 * tmp2 * u[i][j][k][2] ) );\n      d[i][j][2][1] = 0.0;\n      d[i][j][2][2] = 1.0\n\t+ dt * 2.0\n\t* (  tx1 *       c34 * tmp1\n\t     + ty1 * r43 * c34 * tmp1\n\t     + tz1 *       c34 * tmp1 )\n\t+ dt * 2.0 * (  tx1 * dx3\n\t\t\t+ ty1 * dy3\n\t\t\t+ tz1 * dz3 );\n      d[i][j][2][3] = 0.0;\n      d[i][j][2][4] = 0.0;\n\n      d[i][j][3][0] = dt * 2.0\n\t* (  tx1 * ( -       c34 * tmp2 * u[i][j][k][3] )\n\t     + ty1 * ( -       c34 * tmp2 * u[i][j][k][3] )\n\t     + tz1 * ( - r43 * c34 * tmp2 * u[i][j][k][3] ) );\n      d[i][j][3][1] = 0.0;\n      d[i][j][3][2] = 0.0;\n      d[i][j][3][3] = 1.0\n\t+ dt * 2.0\n\t* (  tx1 *       c34 * tmp1\n\t     + ty1 *       c34 * tmp1\n\t     + tz1 * r43 * c34 * tmp1 )\n\t+ dt * 2.0 * (  tx1 * dx4\n\t\t\t+ ty1 * dy4\n\t\t\t+ tz1 * dz4 );\n      d[i][j][3][4] = 0.0;\n\n      d[i][j][4][0] = dt * 2.0\n\t* ( tx1 * ( - ( r43*c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][1]) )\n\t\t    - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][2]) )\n\t\t    - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][3]) )\n\t\t    - ( c1345 ) * tmp2 * u[i][j][k][4] )\n\t    + ty1 * ( - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][1]) )\n\t\t      - ( r43*c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][2]) )\n\t\t      - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][3]) )\n\t\t      - ( c1345 ) * tmp2 * u[i][j][k][4] )\n\t    + tz1 * ( - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][1]) )\n\t\t      - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][2]) )\n\t\t      - ( r43*c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k][3]) )\n\t\t      - ( c1345 ) * tmp2 * u[i][j][k][4] ) );\n      d[i][j][4][1] = dt * 2.0\n\t* ( tx1 * ( r43*c34 - c1345 ) * tmp2 * u[i][j][k][1]\n\t    + ty1 * (     c34 - c1345 ) * tmp2 * u[i][j][k][1]\n\t    + tz1 * (     c34 - c1345 ) * tmp2 * u[i][j][k][1] );\n      d[i][j][4][2] = dt * 2.0\n\t* ( tx1 * ( c34 - c1345 ) * tmp2 * u[i][j][k][2]\n\t    + ty1 * ( r43*c34 -c1345 ) * tmp2 * u[i][j][k][2]\n\t    + tz1 * ( c34 - c1345 ) * tmp2 * u[i][j][k][2] );\n      d[i][j][4][3] = dt * 2.0\n\t* ( tx1 * ( c34 - c1345 ) * tmp2 * u[i][j][k][3]\n\t    + ty1 * ( c34 - c1345 ) * tmp2 * u[i][j][k][3]\n\t    + tz1 * ( r43*c34 - c1345 ) * tmp2 * u[i][j][k][3] );\n      d[i][j][4][4] = 1.0\n        + dt * 2.0 * ( tx1 * c1345 * tmp1\n\t\t       + ty1 * c1345 * tmp1\n\t\t       + tz1 * c1345 * tmp1 )\n        + dt * 2.0 * (  tx1 * dx5\n\t\t\t+  ty1 * dy5\n\t\t\t+  tz1 * dz5 );\n\n      tmp1 = 1.0 / u[i+1][j][k][0];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n\n      a[i][j][0][0] = - dt * tx1 * dx1;\n      a[i][j][0][1] =   dt * tx2;\n      a[i][j][0][2] =   0.0;\n      a[i][j][0][3] =   0.0;\n      a[i][j][0][4] =   0.0;\n\n      a[i][j][1][0] =  dt * tx2\n\t* ( - ( u[i+1][j][k][1] * tmp1 ) *( u[i+1][j][k][1] * tmp1 )\n\t    + C2 * 0.50 * (  u[i+1][j][k][1] * u[i+1][j][k][1]\n                             + u[i+1][j][k][2] * u[i+1][j][k][2]\n                             + u[i+1][j][k][3] * u[i+1][j][k][3] ) * tmp2 )\n\t- dt * tx1 * ( - r43 * c34 * tmp2 * u[i+1][j][k][1] );\n      a[i][j][1][1] =  dt * tx2\n\t* ( ( 2.0 - C2 ) * ( u[i+1][j][k][1] * tmp1 ) )\n\t- dt * tx1 * ( r43 * c34 * tmp1 )\n\t- dt * tx1 * dx2;\n      a[i][j][1][2] =  dt * tx2\n\t* ( - C2 * ( u[i+1][j][k][2] * tmp1 ) );\n      a[i][j][1][3] =  dt * tx2\n\t* ( - C2 * ( u[i+1][j][k][3] * tmp1 ) );\n      a[i][j][1][4] =  dt * tx2 * C2 ;\n\n      a[i][j][2][0] =  dt * tx2\n\t* ( - ( u[i+1][j][k][1] * u[i+1][j][k][2] ) * tmp2 )\n\t- dt * tx1 * ( - c34 * tmp2 * u[i+1][j][k][2] );\n      a[i][j][2][1] =  dt * tx2 * ( u[i+1][j][k][2] * tmp1 );\n      a[i][j][2][2] =  dt * tx2 * ( u[i+1][j][k][1] * tmp1 )\n\t- dt * tx1 * ( c34 * tmp1 )\n\t- dt * tx1 * dx3;\n      a[i][j][2][3] = 0.0;\n      a[i][j][2][4] = 0.0;\n\n      a[i][j][3][0] = dt * tx2\n\t* ( - ( u[i+1][j][k][1]*u[i+1][j][k][3] ) * tmp2 )\n\t- dt * tx1 * ( - c34 * tmp2 * u[i+1][j][k][3] );\n      a[i][j][3][1] = dt * tx2 * ( u[i+1][j][k][3] * tmp1 );\n      a[i][j][3][2] = 0.0;\n      a[i][j][3][3] = dt * tx2 * ( u[i+1][j][k][1] * tmp1 )\n\t- dt * tx1 * ( c34 * tmp1 )\n\t- dt * tx1 * dx4;\n      a[i][j][3][4] = 0.0;\n\n      a[i][j][4][0] = dt * tx2\n\t* ( ( C2 * (  u[i+1][j][k][1] * u[i+1][j][k][1]\n\t\t      + u[i+1][j][k][2] * u[i+1][j][k][2]\n\t\t      + u[i+1][j][k][3] * u[i+1][j][k][3] ) * tmp2\n\t      - C1 * ( u[i+1][j][k][4] * tmp1 ) )\n\t    * ( u[i+1][j][k][1] * tmp1 ) )\n\t- dt * tx1\n\t* ( - ( r43*c34 - c1345 ) * tmp3 * ( pow2(u[i+1][j][k][1]) )\n\t    - (     c34 - c1345 ) * tmp3 * ( pow2(u[i+1][j][k][2]) )\n\t    - (     c34 - c1345 ) * tmp3 * ( pow2(u[i+1][j][k][3]) )\n\t    - c1345 * tmp2 * u[i+1][j][k][4] );\n      a[i][j][4][1] = dt * tx2\n\t* ( C1 * ( u[i+1][j][k][4] * tmp1 )\n\t    - 0.50 * C2\n\t    * ( (  3.0*u[i+1][j][k][1]*u[i+1][j][k][1]\n\t\t   + u[i+1][j][k][2]*u[i+1][j][k][2]\n\t\t   + u[i+1][j][k][3]*u[i+1][j][k][3] ) * tmp2 ) )\n\t- dt * tx1\n\t* ( r43*c34 - c1345 ) * tmp2 * u[i+1][j][k][1];\n      a[i][j][4][2] = dt * tx2\n\t* ( - C2 * ( u[i+1][j][k][2]*u[i+1][j][k][1] ) * tmp2 )\n\t- dt * tx1\n\t* (  c34 - c1345 ) * tmp2 * u[i+1][j][k][2];\n      a[i][j][4][3] = dt * tx2\n\t* ( - C2 * ( u[i+1][j][k][3]*u[i+1][j][k][1] ) * tmp2 )\n\t- dt * tx1\n\t* (  c34 - c1345 ) * tmp2 * u[i+1][j][k][3];\n      a[i][j][4][4] = dt * tx2\n\t* ( C1 * ( u[i+1][j][k][1] * tmp1 ) )\n\t- dt * tx1 * c1345 * tmp1\n\t- dt * tx1 * dx5;\n\n      tmp1 = 1.0 / u[i][j+1][k][0];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n\n      b[i][j][0][0] = - dt * ty1 * dy1;\n      b[i][j][0][1] =   0.0;\n      b[i][j][0][2] =  dt * ty2;\n      b[i][j][0][3] =   0.0;\n      b[i][j][0][4] =   0.0;\n\n      b[i][j][1][0] =  dt * ty2\n\t* ( - ( u[i][j+1][k][1]*u[i][j+1][k][2] ) * tmp2 )\n\t- dt * ty1 * ( - c34 * tmp2 * u[i][j+1][k][1] );\n      b[i][j][1][1] =  dt * ty2 * ( u[i][j+1][k][2] * tmp1 )\n\t- dt * ty1 * ( c34 * tmp1 )\n\t- dt * ty1 * dy2;\n      b[i][j][1][2] =  dt * ty2 * ( u[i][j+1][k][1] * tmp1 );\n      b[i][j][1][3] = 0.0;\n      b[i][j][1][4] = 0.0;\n\n      b[i][j][2][0] =  dt * ty2\n\t* ( - ( u[i][j+1][k][2] * tmp1 ) *( u[i][j+1][k][2] * tmp1 )\n\t    + 0.50 * C2 * ( (  u[i][j+1][k][1] * u[i][j+1][k][1]\n\t\t\t       + u[i][j+1][k][2] * u[i][j+1][k][2]\n\t\t\t       + u[i][j+1][k][3] * u[i][j+1][k][3] )\n\t\t\t    * tmp2 ) )\n\t- dt * ty1 * ( - r43 * c34 * tmp2 * u[i][j+1][k][2] );\n      b[i][j][2][1] =  dt * ty2\n\t* ( - C2 * ( u[i][j+1][k][1] * tmp1 ) );\n      b[i][j][2][2] =  dt * ty2 * ( ( 2.0 - C2 )\n\t\t\t\t * ( u[i][j+1][k][2] * tmp1 ) )\n\t- dt * ty1 * ( r43 * c34 * tmp1 )\n\t- dt * ty1 * dy3;\n      b[i][j][2][3] =  dt * ty2\n\t* ( - C2 * ( u[i][j+1][k][3] * tmp1 ) );\n      b[i][j][2][4] =  dt * ty2 * C2;\n\n      b[i][j][3][0] =  dt * ty2\n\t* ( - ( u[i][j+1][k][2]*u[i][j+1][k][3] ) * tmp2 )\n\t- dt * ty1 * ( - c34 * tmp2 * u[i][j+1][k][3] );\n      b[i][j][3][1] = 0.0;\n      b[i][j][3][2] =  dt * ty2 * ( u[i][j+1][k][3] * tmp1 );\n      b[i][j][3][3] =  dt * ty2 * ( u[i][j+1][k][2] * tmp1 )\n\t- dt * ty1 * ( c34 * tmp1 )\n\t- dt * ty1 * dy4;\n      b[i][j][3][4] = 0.0;\n\n      b[i][j][4][0] =  dt * ty2\n\t* ( ( C2 * (  u[i][j+1][k][1] * u[i][j+1][k][1]\n\t\t      + u[i][j+1][k][2] * u[i][j+1][k][2]\n\t\t      + u[i][j+1][k][3] * u[i][j+1][k][3] ) * tmp2\n\t      - C1 * ( u[i][j+1][k][4] * tmp1 ) )\n\t    * ( u[i][j+1][k][2] * tmp1 ) )\n\t- dt * ty1\n\t* ( - (     c34 - c1345 )*tmp3*( pow2(u[i][j+1][k][1]) )\n\t    - ( r43*c34 - c1345 )*tmp3*( pow2(u[i][j+1][k][2]) )\n\t    - (     c34 - c1345 )*tmp3*( pow2(u[i][j+1][k][3]) )\n\t    - c1345*tmp2*u[i][j+1][k][4] );\n      b[i][j][4][1] =  dt * ty2\n\t* ( - C2 * ( u[i][j+1][k][1]*u[i][j+1][k][2] ) * tmp2 )\n\t- dt * ty1\n\t* ( c34 - c1345 ) * tmp2 * u[i][j+1][k][1];\n      b[i][j][4][2] =  dt * ty2\n\t* ( C1 * ( u[i][j+1][k][4] * tmp1 )\n\t    - 0.50 * C2 \n\t    * ( (  u[i][j+1][k][1]*u[i][j+1][k][1]\n\t\t   + 3.0 * u[i][j+1][k][2]*u[i][j+1][k][2]\n\t\t   + u[i][j+1][k][3]*u[i][j+1][k][3] ) * tmp2 ) )\n\t- dt * ty1\n\t* ( r43*c34 - c1345 ) * tmp2 * u[i][j+1][k][2];\n      b[i][j][4][3] =  dt * ty2\n\t* ( - C2 * ( u[i][j+1][k][2]*u[i][j+1][k][3] ) * tmp2 )\n\t- dt * ty1 * ( c34 - c1345 ) * tmp2 * u[i][j+1][k][3];\n      b[i][j][4][4] =  dt * ty2\n\t* ( C1 * ( u[i][j+1][k][2] * tmp1 ) )\n\t- dt * ty1 * c1345 * tmp1\n\t- dt * ty1 * dy5;\n\n      tmp1 = 1.0 / u[i][j][k+1][0];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n\n      c[i][j][0][0] = - dt * tz1 * dz1;\n      c[i][j][0][1] =   0.0;\n      c[i][j][0][2] =   0.0;\n      c[i][j][0][3] = dt * tz2;\n      c[i][j][0][4] =   0.0;\n\n      c[i][j][1][0] = dt * tz2\n\t* ( - ( u[i][j][k+1][1]*u[i][j][k+1][3] ) * tmp2 )\n\t- dt * tz1 * ( - c34 * tmp2 * u[i][j][k+1][1] );\n      c[i][j][1][1] = dt * tz2 * ( u[i][j][k+1][3] * tmp1 )\n\t- dt * tz1 * c34 * tmp1\n\t- dt * tz1 * dz2 ;\n      c[i][j][1][2] = 0.0;\n      c[i][j][1][3] = dt * tz2 * ( u[i][j][k+1][1] * tmp1 );\n      c[i][j][1][4] = 0.0;\n\n      c[i][j][2][0] = dt * tz2\n\t* ( - ( u[i][j][k+1][2]*u[i][j][k+1][3] ) * tmp2 )\n\t- dt * tz1 * ( - c34 * tmp2 * u[i][j][k+1][2] );\n      c[i][j][2][1] = 0.0;\n      c[i][j][2][2] = dt * tz2 * ( u[i][j][k+1][3] * tmp1 )\n\t- dt * tz1 * ( c34 * tmp1 )\n\t- dt * tz1 * dz3;\n      c[i][j][2][3] = dt * tz2 * ( u[i][j][k+1][2] * tmp1 );\n      c[i][j][2][4] = 0.0;\n\n      c[i][j][3][0] = dt * tz2\n\t* ( - ( u[i][j][k+1][3] * tmp1 ) *( u[i][j][k+1][3] * tmp1 )\n\t    + 0.50 * C2\n\t    * ( ( u[i][j][k+1][1] * u[i][j][k+1][1]\n\t\t  + u[i][j][k+1][2] * u[i][j][k+1][2]\n\t\t  + u[i][j][k+1][3] * u[i][j][k+1][3] ) * tmp2 ) )\n\t- dt * tz1 * ( - r43 * c34 * tmp2 * u[i][j][k+1][3] );\n      c[i][j][3][1] = dt * tz2\n\t* ( - C2 * ( u[i][j][k+1][1] * tmp1 ) );\n      c[i][j][3][2] = dt * tz2\n\t* ( - C2 * ( u[i][j][k+1][2] * tmp1 ) );\n      c[i][j][3][3] = dt * tz2 * ( 2.0 - C2 )\n\t* ( u[i][j][k+1][3] * tmp1 )\n\t- dt * tz1 * ( r43 * c34 * tmp1 )\n\t- dt * tz1 * dz4;\n      c[i][j][3][4] = dt * tz2 * C2;\n\n      c[i][j][4][0] = dt * tz2\n\t* ( ( C2 * (  u[i][j][k+1][1] * u[i][j][k+1][1]\n                      + u[i][j][k+1][2] * u[i][j][k+1][2]\n                      + u[i][j][k+1][3] * u[i][j][k+1][3] ) * tmp2\n\t      - C1 * ( u[i][j][k+1][4] * tmp1 ) )\n\t    * ( u[i][j][k+1][3] * tmp1 ) )\n\t- dt * tz1\n\t* ( - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k+1][1]) )\n\t    - ( c34 - c1345 ) * tmp3 * ( pow2(u[i][j][k+1][2]) )\n\t    - ( r43*c34 - c1345 )* tmp3 * ( pow2(u[i][j][k+1][3]) )\n\t    - c1345 * tmp2 * u[i][j][k+1][4] );\n      c[i][j][4][1] = dt * tz2\n\t* ( - C2 * ( u[i][j][k+1][1]*u[i][j][k+1][3] ) * tmp2 )\n\t- dt * tz1 * ( c34 - c1345 ) * tmp2 * u[i][j][k+1][1];\n      c[i][j][4][2] = dt * tz2\n\t* ( - C2 * ( u[i][j][k+1][2]*u[i][j][k+1][3] ) * tmp2 )\n\t- dt * tz1 * ( c34 - c1345 ) * tmp2 * u[i][j][k+1][2];\n      c[i][j][4][3] = dt * tz2\n\t* ( C1 * ( u[i][j][k+1][4] * tmp1 )\n            - 0.50 * C2\n            * ( (  u[i][j][k+1][1]*u[i][j][k+1][1]\n\t\t   + u[i][j][k+1][2]*u[i][j][k+1][2]\n\t\t   + 3.0*u[i][j][k+1][3]*u[i][j][k+1][3] ) * tmp2 ) )\n\t- dt * tz1 * ( r43*c34 - c1345 ) * tmp2 * u[i][j][k+1][3];\n      c[i][j][4][4] = dt * tz2\n\t* ( C1 * ( u[i][j][k+1][3] * tmp1 ) )\n\t- dt * tz1 * c1345 * tmp1\n\t- dt * tz1 * dz5;\n    }\n  }\n}\n\n\nstatic void l2norm (int nx0, int ny0, int nz0,\n\t\t    int ist, int iend,\n\t\t    int jst, int jend,\n\t\t    double v[ISIZ1][ISIZ2/2*2+1][ISIZ3/2*2+1][5],\n\t\t    double sum[5]) {\n\n#pragma omp parallel \n{\n\n\n  int i, j, k, m;\n  double sum0=0.0, sum1=0.0, sum2=0.0, sum3=0.0, sum4=0.0;\n\n#pragma omp single  \n  for (m = 0; m < 5; m++) {\n    sum[m] = 0.0;\n  }\n\n#pragma omp for nowait\n  for (i = ist; i <= iend; i++) {\n    for (j = jst; j <= jend; j++) {\n      for (k = 1; k <= nz0-2; k++) {\n\t  sum0 = sum0 + v[i][j][k][0] * v[i][j][k][0];\n\t  sum1 = sum1 + v[i][j][k][1] * v[i][j][k][1];\n\t  sum2 = sum2 + v[i][j][k][2] * v[i][j][k][2];\n\t  sum3 = sum3 + v[i][j][k][3] * v[i][j][k][3];\n\t  sum4 = sum4 + v[i][j][k][4] * v[i][j][k][4];\n      }\n    }\n  }\n\n#pragma omp critical\n  {\n      sum[0] += sum0;\n      sum[1] += sum1;\n      sum[2] += sum2;\n      sum[3] += sum3;\n      sum[4] += sum4;\n  }\n#pragma omp barrier  \n  \n#pragma omp single  \n  for (m = 0;  m < 5; m++) {\n    sum[m] = sqrt ( sum[m] / ( (nx0-2)*(ny0-2)*(nz0-2) ) );\n  }\n}\n}\n\nstatic void pintgr(void) {\n\n  int i, j, k;\n  int ibeg, ifin, ifin1;\n  int jbeg, jfin, jfin1;\n  int iglob, iglob1, iglob2;\n  int jglob, jglob1, jglob2;\n  double phi1[ISIZ2+2][ISIZ3+2];\t/* phi1(0:isiz2+1,0:isiz3+1) */\n  double phi1[ISIZ2+2][ISIZ3+2];\t/* phi1(0:isiz2+1,0:isiz3+1) */\n  double phi2[ISIZ2+2][ISIZ3+2];\t/* phi2(0:isiz2+1,0:isiz3+1) */\n  double phi2[ISIZ2+2][ISIZ3+2];\t/* phi2(0:isiz2+1,0:isiz3+1) */\n  double  frc1, frc2, frc3;\n\n  ibeg = nx;\n  ifin = 0;\n  iglob1 = -1;\n  iglob2 = nx-1;\n  if (iglob1 >= ii1 && iglob2 < ii2+nx) ibeg = 0;\n  if (iglob1 >= ii1-nx && iglob2 <= ii2) ifin = nx;\n  if (ii1 >= iglob1 && ii1 <= iglob2) ibeg = ii1;\n  if (ii2 >= iglob1 && ii2 <= iglob2) ifin = ii2;\n  jbeg = ny;\n  jfin = -1;\n  jglob1 = 0;\n  jglob2 = ny-1;\n  if (jglob1 >= ji1 && jglob2 < ji2+ny) jbeg = 0;\n  if (jglob1 > ji1-ny && jglob2 <= ji2) jfin = ny;\n  if (ji1 >= jglob1 && ji1 <= jglob2) jbeg = ji1;\n  if (ji2 >= jglob1 && ji2 <= jglob2) jfin = ji2;\n  ifin1 = ifin;\n  jfin1 = jfin;\n  if (ifin1 == ii2) ifin1 = ifin -1;\n  if (jfin1 == ji2) jfin1 = jfin -1;\n\n  for (i = 0; i <= ISIZ2+1; i++) {\n    for (k = 0; k <= ISIZ3+1; k++) {\n      phi1[i][k] = 0.0;\n      phi2[i][k] = 0.0;\n    }\n  }\n  for (i = ibeg; i <= ifin; i++) {\n    iglob = i;\n    for (j = jbeg; j <= jfin; j++) {\n      jglob = j;\n\n      k = ki1;\n\n      phi1[i][j] = C2*(  u[i][j][k][4]\n\t\t\t- 0.50 * (  pow2(u[i][j][k][1])\n\t\t\t\t    + pow2(u[i][j][k][2])\n\t\t\t\t    + pow2(u[i][j][k][3]) )\n\t\t\t/ u[i][j][k][0] );\n\n      k = ki2;\n\n      phi2[i][j] = C2*(  u[i][j][k][4]\n\t\t\t- 0.50 * (  pow2(u[i][j][k][1])\n\t\t\t\t    + pow2(u[i][j][k][2])\n\t\t\t\t    + pow2(u[i][j][k][3]) )\n\t\t\t/ u[i][j][k][0] );\n    }\n  }\n\n  frc1 = 0.0;\n\n  for (i = ibeg; i <= ifin1; i++) {\n    for (j = jbeg; j <= jfin1; j++) {\n      frc1 = frc1 + (  phi1[i][j]\n\t\t       + phi1[i+1][j]\n\t\t       + phi1[i][j+1]\n\t\t       + phi1[i+1][j+1]\n\t\t       + phi2[i][j]\n\t\t       + phi2[i+1][j]\n\t\t       + phi2[i][j+1]\n\t\t       + phi2[i+1][j+1] );\n    }\n  }\n\n  frc1 = dxi * deta * frc1;\n\n  for (i = 0; i <= ISIZ2+1; i++) {\n    for (k = 0; k <= ISIZ3+1; k++) {\n      phi1[i][k] = 0.0;\n      phi2[i][k] = 0.0;\n    }\n  }\n  jglob = jbeg;\n  if (jglob == ji1) {\n    for (i = ibeg; i <= ifin; i++) {\n      iglob = i;\n      for (k = ki1; k <= ki2; k++) {\n\tphi1[i][k] = C2*(  u[i][jbeg][k][4]\n\t\t\t  - 0.50 * (  pow2(u[i][jbeg][k][1])\n\t\t\t\t      + pow2(u[i][jbeg][k][2])\n\t\t\t\t      + pow2(u[i][jbeg][k][3]) )\n\t\t\t  / u[i][jbeg][k][0] );\n      }\n    }\n  }\n\n  jglob = jfin;\n  if (jglob == ji2) {\n    for (i = ibeg; i <= ifin; i++) {\n      iglob = i;\n      for (k = ki1; k <= ki2; k++) {\n\tphi2[i][k] = C2*(  u[i][jfin][k][4]\n\t\t\t  - 0.50 * (  pow2(u[i][jfin][k][1])\n\t\t\t\t      + pow2(u[i][jfin][k][2])\n\t\t\t\t      + pow2(u[i][jfin][k][3]) )\n\t\t\t  / u[i][jfin][k][0] );\n      }\n    }\n  }\n\n\n  frc2 = 0.0;\n  for (i = ibeg; i <= ifin1; i++) {\n    for (k = ki1; k <= ki2-1; k++) {\n      frc2 = frc2 + (  phi1[i][k]\n\t\t       + phi1[i+1][k]\n\t\t       + phi1[i][k+1]\n\t\t       + phi1[i+1][k+1]\n\t\t       + phi2[i][k]\n\t\t       + phi2[i+1][k]\n\t\t       + phi2[i][k+1]\n\t\t       + phi2[i+1][k+1] );\n    }\n  }\n\n\n  frc2 = dxi * dzeta * frc2;\n\n  for (i = 0; i <= ISIZ2+1; i++) {\n    for (k = 0; k <= ISIZ3+1; k++) {\n      phi1[i][k] = 0.0;\n      phi2[i][k] = 0.0;\n    }\n  }\n  iglob = ibeg;\n  if (iglob == ii1) {\n    for (j = jbeg; j <= jfin; j++) {\n      jglob = j;\n      for (k = ki1; k <= ki2; k++) {\n\tphi1[j][k] = C2*(  u[ibeg][j][k][4]\n\t\t\t  - 0.50 * (  pow2(u[ibeg][j][k][1])\n\t\t\t\t      + pow2(u[ibeg][j][k][2])\n\t\t\t\t      + pow2(u[ibeg][j][k][3]) )\n\t\t\t  / u[ibeg][j][k][0] );\n      }\n    }\n  }\n\n  iglob = ifin;\n  if (iglob == ii2) {\n    for (j = jbeg; j <= jfin; j++) {\n      jglob = j;\n      for (k = ki1; k <= ki2; k++) {\n\tphi2[j][k] = C2*(  u[ifin][j][k][4]\n\t\t\t  - 0.50 * (  pow2(u[ifin][j][k][1])\n\t\t\t\t      + pow2(u[ifin][j][k][2])\n\t\t\t\t      + pow2(u[ifin][j][k][3]) )\n\t\t\t  / u[ifin][j][k][0] );\n      }\n    }\n  }\n\n  frc3 = 0.0;\n\n  for (j = jbeg; j <= jfin1; j++) {\n    for (k = ki1; k <= ki2-1; k++) {\n      frc3 = frc3 + (  phi1[j][k]\n\t\t       + phi1[j+1][k]\n\t\t       + phi1[j][k+1]\n\t\t       + phi1[j+1][k+1]\n\t\t       + phi2[j][k]\n\t\t       + phi2[j+1][k]\n\t\t       + phi2[j][k+1]\n\t\t       + phi2[j+1][k+1] );\n    }\n  }\n\n  frc3 = deta * dzeta * frc3;\n  frc = 0.25 * ( frc1 + frc2 + frc3 );\n}\n\n\nstatic void read_input(void) {\n\n  FILE *fp;\n    \n\n  printf(\"\\n\\n NAS Parallel Benchmarks 3.0 structured OpenMP C version\"\n\t \" - LU Benchmark\\n\\n\");\n\n  fp = fopen(\"inputlu.data\", \"r\");\n  if (fp != NULL) {\n    printf(\" Reading from input file inputlu.data\\n\");\n\n    while(fgetc(fp) != '\\n'); while(fgetc(fp) != '\\n');\n    fscanf(fp, \"%d%d\", &ipr, &inorm);\n    while(fgetc(fp) != '\\n');\n    \n    while(fgetc(fp) != '\\n'); while(fgetc(fp) != '\\n');\n    fscanf(fp, \"%d\", &itmax);\n    while(fgetc(fp) != '\\n');\n\n    while(fgetc(fp) != '\\n'); while(fgetc(fp) != '\\n');\n    fscanf(fp, \"%lf\", &dt);\n    while(fgetc(fp) != '\\n');\n    \n    while(fgetc(fp) != '\\n'); while(fgetc(fp) != '\\n');\n    fscanf(fp, \"%lf\", &omega);\n    while(fgetc(fp) != '\\n');\n    \n    while(fgetc(fp) != '\\n'); while(fgetc(fp) != '\\n');\n    fscanf(fp, \"%lf%lf%lf%lf%lf\",\n\t   &tolrsd[0], &tolrsd[1], &tolrsd[2], &tolrsd[3], &tolrsd[4]);\n    while(fgetc(fp) != '\\n');\n    \n    while(fgetc(fp) != '\\n'); while(fgetc(fp) != '\\n');\n    fscanf(fp, \"%d%d%d\", &nx0, &ny0, &nz0);\n    while(fgetc(fp) != '\\n');\n    fclose(fp);\n  } else {\n    ipr = IPR_DEFAULT;\n    inorm = INORM_DEFAULT;\n    itmax = ITMAX_DEFAULT;\n    dt = DT_DEFAULT;\n    omega = OMEGA_DEFAULT;\n    tolrsd[0] = TOLRSD1_DEF;\n    tolrsd[1] = TOLRSD2_DEF;\n    tolrsd[2] = TOLRSD3_DEF;\n    tolrsd[3] = TOLRSD4_DEF;\n    tolrsd[4] = TOLRSD5_DEF;\n    nx0 = ISIZ1;\n    ny0 = ISIZ2;\n    nz0 = ISIZ3;\n  }\n\n\n  if ( nx0 < 4 || ny0 < 4 || nz0 < 4 ) {\n    printf(\"     PROBLEM SIZE IS TOO SMALL - \\n\"\n\t   \"     SET EACH OF NX, NY AND NZ AT LEAST EQUAL TO 5\\n\");\n    exit(1);\n  }\n\n  if ( nx0 > ISIZ1 || ny0 > ISIZ2 || nz0 > ISIZ3 ) {\n    printf(\"     PROBLEM SIZE IS TOO LARGE - \\n\"\n\t   \"     NX, NY AND NZ SHOULD BE EQUAL TO \\n\"\n\t   \"     ISIZ1, ISIZ2 AND ISIZ3 RESPECTIVELY\\n\");\n    exit(1);\n  }\n\n  printf(\" Size: %3dx%3dx%3d\\n\", nx0, ny0, nz0);\n  printf(\" Iterations: %3d\\n\", itmax);\n}\n\n\nstatic void rhs(void) {\n\n#pragma omp parallel \n{\n\n\n  int i, j, k, m;\n  int L1, L2;\n  int ist1, iend1;\n  int jst1, jend1;\n  double  q;\n  double  u21, u31, u41;\n  double  tmp;\n  double  u21i, u31i, u41i, u51i;\n  double  u21j, u31j, u41j, u51j;\n  double  u21k, u31k, u41k, u51k;\n  double  u21im1, u31im1, u41im1, u51im1;\n  double  u21jm1, u31jm1, u41jm1, u51jm1;\n  double  u21km1, u31km1, u41km1, u51km1;\n\n#pragma omp for  \n  for (i = 0; i <= nx-1; i++) {\n    for (j = 0; j <= ny-1; j++) {\n      for (k = 0; k <= nz-1; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  rsd[i][j][k][m] = - frct[i][j][k][m];\n\t}\n      }\n    }\n  }\n\n\n  L1 = 0;\n  L2 = nx-1;\n\n#pragma omp for  \n  for (i = L1; i <= L2; i++) {\n    for (j = jst; j <= jend; j++) {\n      for (k = 1; k <= nz - 2; k++) {\n\tflux[i][j][k][0] = u[i][j][k][1];\n\tu21 = u[i][j][k][1] / u[i][j][k][0];\n\n\tq = 0.50 * (  u[i][j][k][1] * u[i][j][k][1]\n\t\t      + u[i][j][k][2] * u[i][j][k][2]\n\t\t      + u[i][j][k][3] * u[i][j][k][3] )\n\t  / u[i][j][k][0];\n\n\tflux[i][j][k][1] = u[i][j][k][1] * u21 + C2 * \n\t  ( u[i][j][k][4] - q );\n\tflux[i][j][k][2] = u[i][j][k][2] * u21;\n\tflux[i][j][k][3] = u[i][j][k][3] * u21;\n\tflux[i][j][k][4] = ( C1 * u[i][j][k][4] - C2 * q ) * u21;\n      }\n    } \n  } \n\n#pragma omp for  \n  for (j = jst; j <= jend; j++) {\n    for (k = 1; k <= nz - 2; k++) {\n      for (i = ist; i <= iend; i++) {\n\tfor (m = 0; m < 5; m++) {\n\t  rsd[i][j][k][m] =  rsd[i][j][k][m]\n\t    - tx2 * ( flux[i+1][j][k][m] - flux[i-1][j][k][m] );\n\t}\n      }\n\n      L2 = nx-1;\n\n      for (i = ist; i <= L2; i++) {\n\ttmp = 1.0 / u[i][j][k][0];\n\n\tu21i = tmp * u[i][j][k][1];\n\tu31i = tmp * u[i][j][k][2];\n\tu41i = tmp * u[i][j][k][3];\n\tu51i = tmp * u[i][j][k][4];\n\n\ttmp = 1.0 / u[i-1][j][k][0];\n\n\tu21im1 = tmp * u[i-1][j][k][1];\n\tu31im1 = tmp * u[i-1][j][k][2];\n\tu41im1 = tmp * u[i-1][j][k][3];\n\tu51im1 = tmp * u[i-1][j][k][4];\n\n\tflux[i][j][k][1] = (4.0/3.0) * tx3 * (u21i-u21im1);\n\tflux[i][j][k][2] = tx3 * ( u31i - u31im1 );\n\tflux[i][j][k][3] = tx3 * ( u41i - u41im1 );\n\tflux[i][j][k][4] = 0.50 * ( 1.0 - C1*C5 )\n\t  * tx3 * (   ( pow2(u21i)   + pow2(u31i)   + pow2(u41i) )\n\t\t    - ( pow2(u21im1) + pow2(u31im1) + pow2(u41im1) ) )\n\t  + (1.0/6.0)\n\t  * tx3 * ( pow2(u21i) - pow2(u21im1) )\n\t  + C1 * C5 * tx3 * ( u51i - u51im1 );\n      }\n\n      for (i = ist; i <= iend; i++) {\n\trsd[i][j][k][0] = rsd[i][j][k][0]\n\t  + dx1 * tx1 * (            u[i-1][j][k][0]\n\t\t\t\t     - 2.0 * u[i][j][k][0]\n\t\t\t\t     +           u[i+1][j][k][0] );\n\trsd[i][j][k][1] = rsd[i][j][k][1]\n\t  + tx3 * C3 * C4 * ( flux[i+1][j][k][1] - flux[i][j][k][1] )\n\t  + dx2 * tx1 * (            u[i-1][j][k][1]\n\t\t\t\t     - 2.0 * u[i][j][k][1]\n\t\t\t\t     +           u[i+1][j][k][1] );\n\trsd[i][j][k][2] = rsd[i][j][k][2]\n\t  + tx3 * C3 * C4 * ( flux[i+1][j][k][2] - flux[i][j][k][2] )\n\t  + dx3 * tx1 * (            u[i-1][j][k][2]\n\t\t\t\t     - 2.0 * u[i][j][k][2]\n\t\t\t\t     +           u[i+1][j][k][2] );\n\trsd[i][j][k][3] = rsd[i][j][k][3]\n\t  + tx3 * C3 * C4 * ( flux[i+1][j][k][3] - flux[i][j][k][3] )\n\t  + dx4 * tx1 * (            u[i-1][j][k][3]\n\t\t\t\t     - 2.0 * u[i][j][k][3]\n\t\t\t\t     +           u[i+1][j][k][3] );\n\trsd[i][j][k][4] = rsd[i][j][k][4]\n\t  + tx3 * C3 * C4 * ( flux[i+1][j][k][4] - flux[i][j][k][4] )\n\t  + dx5 * tx1 * (            u[i-1][j][k][4]\n\t\t\t\t     - 2.0 * u[i][j][k][4]\n\t\t\t\t     +           u[i+1][j][k][4] );\n      }\n\n      for (m = 0; m < 5; m++) {\n\trsd[1][j][k][m] = rsd[1][j][k][m]\n\t  - dssp * ( + 5.0 * u[1][j][k][m]\n\t\t     - 4.0 * u[2][j][k][m]\n\t\t     +           u[3][j][k][m] );\n\trsd[2][j][k][m] = rsd[2][j][k][m]\n\t  - dssp * ( - 4.0 * u[1][j][k][m]\n\t\t     + 6.0 * u[2][j][k][m]\n\t\t     - 4.0 * u[3][j][k][m]\n\t\t     +           u[4][j][k][m] );\n      }\n\n      ist1 = 3;\n      iend1 = nx - 4;\n\n      for (i = ist1; i <= iend1; i++) {\n\tfor (m = 0; m < 5; m++) {\n\t  rsd[i][j][k][m] = rsd[i][j][k][m]\n\t    - dssp * (            u[i-2][j][k][m]\n\t\t\t\t  - 4.0 * u[i-1][j][k][m]\n\t\t\t\t  + 6.0 * u[i][j][k][m]\n\t\t\t\t  - 4.0 * u[i+1][j][k][m]\n\t\t\t\t  +           u[i+2][j][k][m] );\n\t}\n      }\n\n\n      for (m = 0; m < 5; m++) {\n\trsd[nx-3][j][k][m] = rsd[nx-3][j][k][m]\n\t  - dssp * (             u[nx-5][j][k][m]\n\t\t\t\t - 4.0 * u[nx-4][j][k][m]\n\t\t\t\t + 6.0 * u[nx-3][j][k][m]\n\t\t\t\t - 4.0 * u[nx-2][j][k][m]  );\n\trsd[nx-2][j][k][m] = rsd[nx-2][j][k][m]\n\t  - dssp * (             u[nx-4][j][k][m]\n\t\t\t\t - 4.0 * u[nx-3][j][k][m]\n\t\t\t\t + 5.0 * u[nx-2][j][k][m] );\n      }\n    }\n  }\n\n\n  L1 = 0;\n  L2 = ny-1;\n\n#pragma omp for  \n  for (i = ist; i <= iend; i++) {\n    for (j = L1; j <= L2; j++) {\n      for (k = 1; k <= nz - 2; k++) {\n\tflux[i][j][k][0] = u[i][j][k][2];\n\tu31 = u[i][j][k][2] / u[i][j][k][0];\n\n\tq = 0.50 * (  u[i][j][k][1] * u[i][j][k][1]\n\t\t      + u[i][j][k][2] * u[i][j][k][2]\n\t\t      + u[i][j][k][3] * u[i][j][k][3] )\n\t  / u[i][j][k][0];\n\n\tflux[i][j][k][1] = u[i][j][k][1] * u31;\n\tflux[i][j][k][2] = u[i][j][k][2] * u31 + C2 * (u[i][j][k][4]-q);\n\tflux[i][j][k][3] = u[i][j][k][3] * u31;\n\tflux[i][j][k][4] = ( C1 * u[i][j][k][4] - C2 * q ) * u31;\n      }\n    }\n  }\n\n#pragma omp for  \n  for (i = ist; i <= iend; i++) {\n    for (k = 1; k <= nz - 2; k++) {\n      for (j = jst; j <= jend; j++) {\n\tfor (m = 0; m < 5; m++) {\n\t  rsd[i][j][k][m] =  rsd[i][j][k][m]\n\t    - ty2 * ( flux[i][j+1][k][m] - flux[i][j-1][k][m] );\n\t}\n      }\n\n      L2 = ny-1;\n      for (j = jst; j <= L2; j++) {\n\ttmp = 1.0 / u[i][j][k][0];\n\n\tu21j = tmp * u[i][j][k][1];\n\tu31j = tmp * u[i][j][k][2];\n\tu41j = tmp * u[i][j][k][3];\n\tu51j = tmp * u[i][j][k][4];\n\n\ttmp = 1.0 / u[i][j-1][k][0];\n\tu21jm1 = tmp * u[i][j-1][k][1];\n\tu31jm1 = tmp * u[i][j-1][k][2];\n\tu41jm1 = tmp * u[i][j-1][k][3];\n\tu51jm1 = tmp * u[i][j-1][k][4];\n\n\tflux[i][j][k][1] = ty3 * ( u21j - u21jm1 );\n\tflux[i][j][k][2] = (4.0/3.0) * ty3 * (u31j-u31jm1);\n\tflux[i][j][k][3] = ty3 * ( u41j - u41jm1 );\n\tflux[i][j][k][4] = 0.50 * ( 1.0 - C1*C5 )\n\t  * ty3 * (   ( pow2(u21j)   + pow2(u31j)   + pow2(u41j) )\n\t\t    - ( pow2(u21jm1) + pow2(u31jm1) + pow2(u41jm1) ) )\n\t  + (1.0/6.0)\n\t  * ty3 * ( pow2(u31j) - pow2(u31jm1) )\n\t  + C1 * C5 * ty3 * ( u51j - u51jm1 );\n      }\n\n      for (j = jst; j <= jend; j++) {\n\n\trsd[i][j][k][0] = rsd[i][j][k][0]\n\t  + dy1 * ty1 * (            u[i][j-1][k][0]\n\t\t\t\t     - 2.0 * u[i][j][k][0]\n\t\t\t\t     +           u[i][j+1][k][0] );\n\n\trsd[i][j][k][1] = rsd[i][j][k][1]\n\t  + ty3 * C3 * C4 * ( flux[i][j+1][k][1] - flux[i][j][k][1] )\n\t  + dy2 * ty1 * (            u[i][j-1][k][1]\n\t\t\t\t     - 2.0 * u[i][j][k][1]\n\t\t\t\t     +           u[i][j+1][k][1] );\n\n\trsd[i][j][k][2] = rsd[i][j][k][2]\n\t  + ty3 * C3 * C4 * ( flux[i][j+1][k][2] - flux[i][j][k][2] )\n\t  + dy3 * ty1 * (            u[i][j-1][k][2]\n\t\t\t\t     - 2.0 * u[i][j][k][2]\n\t\t\t\t     +           u[i][j+1][k][2] );\n\n\trsd[i][j][k][3] = rsd[i][j][k][3]\n\t  + ty3 * C3 * C4 * ( flux[i][j+1][k][3] - flux[i][j][k][3] )\n\t  + dy4 * ty1 * (            u[i][j-1][k][3]\n\t\t\t\t     - 2.0 * u[i][j][k][3]\n\t\t\t\t     +           u[i][j+1][k][3] );\n\n\trsd[i][j][k][4] = rsd[i][j][k][4]\n\t  + ty3 * C3 * C4 * ( flux[i][j+1][k][4] - flux[i][j][k][4] )\n\t  + dy5 * ty1 * (            u[i][j-1][k][4]\n\t\t\t\t     - 2.0 * u[i][j][k][4]\n\t\t\t\t     +           u[i][j+1][k][4] );\n\n      }\n\n      for (m = 0; m < 5; m++) {\n\trsd[i][1][k][m] = rsd[i][1][k][m]\n\t  - dssp * ( + 5.0 * u[i][1][k][m]\n\t\t     - 4.0 * u[i][2][k][m]\n\t\t     +           u[i][3][k][m] );\n\trsd[i][2][k][m] = rsd[i][2][k][m]\n\t  - dssp * ( - 4.0 * u[i][1][k][m]\n\t\t     + 6.0 * u[i][2][k][m]\n\t\t     - 4.0 * u[i][3][k][m]\n\t\t     +           u[i][4][k][m] );\n      }\n\n      jst1 = 3;\n      jend1 = ny - 4;\n      for (j = jst1; j <= jend1; j++) {\n\tfor (m = 0; m < 5; m++) {\n\t  rsd[i][j][k][m] = rsd[i][j][k][m]\n\t    - dssp * (            u[i][j-2][k][m]\n\t\t\t\t  - 4.0 * u[i][j-1][k][m]\n\t\t\t\t  + 6.0 * u[i][j][k][m]\n\t\t\t\t  - 4.0 * u[i][j+1][k][m]\n\t\t\t\t  +           u[i][j+2][k][m] );\n\t}\n      }\n\n      for (m = 0; m < 5; m++) {\n\trsd[i][ny-3][k][m] = rsd[i][ny-3][k][m]\n\t  - dssp * (             u[i][ny-5][k][m]\n\t\t\t\t - 4.0 * u[i][ny-4][k][m]\n\t\t\t\t + 6.0 * u[i][ny-3][k][m]\n\t\t\t\t - 4.0 * u[i][ny-2][k][m]  );\n\trsd[i][ny-2][k][m] = rsd[i][ny-2][k][m]\n\t  - dssp * (             u[i][ny-4][k][m]\n\t\t\t\t - 4.0 * u[i][ny-3][k][m]\n\t\t\t\t + 5.0 * u[i][ny-2][k][m] );\n      }\n    }\n  }\n\n#pragma omp for  \n  for (i = ist; i <= iend; i++) {\n    for (j = jst; j <= jend; j++) {\n      for (k = 0; k <= nz-1; k++) {\n\tflux[i][j][k][0] = u[i][j][k][3];\n\tu41 = u[i][j][k][3] / u[i][j][k][0];\n\n\tq = 0.50 * (  u[i][j][k][1] * u[i][j][k][1]\n\t\t      + u[i][j][k][2] * u[i][j][k][2]\n\t\t      + u[i][j][k][3] * u[i][j][k][3] )\n\t  / u[i][j][k][0];\n\n\tflux[i][j][k][1] = u[i][j][k][1] * u41;\n\tflux[i][j][k][2] = u[i][j][k][2] * u41; \n\tflux[i][j][k][3] = u[i][j][k][3] * u41 + C2 * (u[i][j][k][4]-q);\n\tflux[i][j][k][4] = ( C1 * u[i][j][k][4] - C2 * q ) * u41;\n      }\n\n      for (k = 1; k <= nz - 2; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  rsd[i][j][k][m] =  rsd[i][j][k][m]\n\t    - tz2 * ( flux[i][j][k+1][m] - flux[i][j][k-1][m] );\n\t}\n      }\n\n      for (k = 1; k <= nz-1; k++) {\n\ttmp = 1.0 / u[i][j][k][0];\n\n\tu21k = tmp * u[i][j][k][1];\n\tu31k = tmp * u[i][j][k][2];\n\tu41k = tmp * u[i][j][k][3];\n\tu51k = tmp * u[i][j][k][4];\n\n\ttmp = 1.0 / u[i][j][k-1][0];\n\n\tu21km1 = tmp * u[i][j][k-1][1];\n\tu31km1 = tmp * u[i][j][k-1][2];\n\tu41km1 = tmp * u[i][j][k-1][3];\n\tu51km1 = tmp * u[i][j][k-1][4];\n\n\tflux[i][j][k][1] = tz3 * ( u21k - u21km1 );\n\tflux[i][j][k][2] = tz3 * ( u31k - u31km1 );\n\tflux[i][j][k][3] = (4.0/3.0) * tz3 * (u41k-u41km1);\n\tflux[i][j][k][4] = 0.50 * ( 1.0 - C1*C5 )\n\t  * tz3 * (   ( pow2(u21k)   + pow2(u31k)   + pow2(u41k) )\n\t\t    - ( pow2(u21km1) + pow2(u31km1) + pow2(u41km1) ) )\n\t  + (1.0/6.0)\n\t  * tz3 * ( pow2(u41k) - pow2(u41km1) )\n\t  + C1 * C5 * tz3 * ( u51k - u51km1 );\n      }\n\n      for (k = 1; k <= nz - 2; k++) {\n\trsd[i][j][k][0] = rsd[i][j][k][0]\n\t  + dz1 * tz1 * (            u[i][j][k-1][0]\n\t\t\t\t     - 2.0 * u[i][j][k][0]\n\t\t\t\t     +           u[i][j][k+1][0] );\n\trsd[i][j][k][1] = rsd[i][j][k][1]\n\t  + tz3 * C3 * C4 * ( flux[i][j][k+1][1] - flux[i][j][k][1] )\n\t  + dz2 * tz1 * (            u[i][j][k-1][1]\n\t\t\t\t     - 2.0 * u[i][j][k][1]\n\t\t\t\t     +           u[i][j][k+1][1] );\n\trsd[i][j][k][2] = rsd[i][j][k][2]\n\t  + tz3 * C3 * C4 * ( flux[i][j][k+1][2] - flux[i][j][k][2] )\n\t  + dz3 * tz1 * (            u[i][j][k-1][2]\n\t\t\t\t     - 2.0 * u[i][j][k][2]\n\t\t\t\t     +           u[i][j][k+1][2] );\n\trsd[i][j][k][3] = rsd[i][j][k][3]\n\t  + tz3 * C3 * C4 * ( flux[i][j][k+1][3] - flux[i][j][k][3] )\n\t  + dz4 * tz1 * (            u[i][j][k-1][3]\n\t\t\t\t     - 2.0 * u[i][j][k][3]\n\t\t\t\t     +           u[i][j][k+1][3] );\n\trsd[i][j][k][4] = rsd[i][j][k][4]\n\t  + tz3 * C3 * C4 * ( flux[i][j][k+1][4] - flux[i][j][k][4] )\n\t  + dz5 * tz1 * (            u[i][j][k-1][4]\n\t\t\t\t     - 2.0 * u[i][j][k][4]\n\t\t\t\t     +           u[i][j][k+1][4] );\n      }\n\n      for (m = 0; m < 5; m++) {\n\trsd[i][j][1][m] = rsd[i][j][1][m]\n\t  - dssp * ( + 5.0 * u[i][j][1][m]\n\t\t     - 4.0 * u[i][j][2][m]\n\t\t     +           u[i][j][3][m] );\n\trsd[i][j][2][m] = rsd[i][j][2][m]\n\t  - dssp * ( - 4.0 * u[i][j][1][m]\n\t\t     + 6.0 * u[i][j][2][m]\n\t\t     - 4.0 * u[i][j][3][m]\n\t\t     +           u[i][j][4][m] );\n      }\n\n      for (k = 3; k <= nz - 4; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  rsd[i][j][k][m] = rsd[i][j][k][m]\n\t    - dssp * (            u[i][j][k-2][m]\n\t\t\t\t  - 4.0 * u[i][j][k-1][m]\n\t\t\t\t  + 6.0 * u[i][j][k][m]\n\t\t\t\t  - 4.0 * u[i][j][k+1][m]\n\t\t\t\t  +           u[i][j][k+2][m] );\n\t}\n      }\n\n      for (m = 0; m < 5; m++) {\n\trsd[i][j][nz-3][m] = rsd[i][j][nz-3][m]\n\t  - dssp * (             u[i][j][nz-5][m]\n\t\t\t\t - 4.0 * u[i][j][nz-4][m]\n\t\t\t\t + 6.0 * u[i][j][nz-3][m]\n\t\t\t\t - 4.0 * u[i][j][nz-2][m]  );\n\trsd[i][j][nz-2][m] = rsd[i][j][nz-2][m]\n\t  - dssp * (             u[i][j][nz-4][m]\n\t\t\t\t - 4.0 * u[i][j][nz-3][m]\n\t\t\t\t + 5.0 * u[i][j][nz-2][m] );\n      }\n    }\n  }\n}\n\n}\n\n\nstatic void setbv(void) {\n\n#pragma omp parallel\n{\n\n\n  int i, j, k;\n  int iglob, jglob;\n\n#pragma omp for\n  for (i = 0; i < nx; i++) {\n    iglob = i;\n    for (j = 0; j < ny; j++) {\n      jglob = j;\n      exact( iglob, jglob, 0, &u[i][j][0][0] );\n      exact( iglob, jglob, nz-1, &u[i][j][nz-1][0] );\n    }\n  }\n\n#pragma omp for\n  for (i = 0; i < nx; i++) {\n    iglob = i;\n    for (k = 0; k < nz; k++) {\n      exact( iglob, 0, k, &u[i][0][k][0] );\n    }\n  }\n\n#pragma omp for\n  for (i = 0; i < nx; i++) {\n    iglob = i;\n    for (k = 0; k < nz; k++) {\n      exact( iglob, ny0-1,  k, &u[i][ny-1][k][0] );\n    }\n  }\n\n#pragma omp for\n  for (j = 0; j < ny; j++) {\n    jglob = j;\n    for (k = 0; k < nz; k++) {\n      exact( 0, jglob, k, &u[0][j][k][0] );\n    }\n  }\n\n#pragma omp for\n  for (j = 0; j < ny; j++) {\n    jglob = j;\n    for (k = 0; k < nz; k++) {\n      exact( nx0-1, jglob, k, &u[nx-1][j][k][0] );\n    }\n  }\n}\n\n}\n\n\nstatic void setcoeff(void) {\n\n  dxi = 1.0 / ( nx0 - 1 );\n  deta = 1.0 / ( ny0 - 1 );\n  dzeta = 1.0 / ( nz0 - 1 );\n\n  tx1 = 1.0 / ( dxi * dxi );\n  tx2 = 1.0 / ( 2.0 * dxi );\n  tx3 = 1.0 / dxi;\n\n  ty1 = 1.0 / ( deta * deta );\n  ty2 = 1.0 / ( 2.0 * deta );\n  ty3 = 1.0 / deta;\n\n  tz1 = 1.0 / ( dzeta * dzeta );\n  tz2 = 1.0 / ( 2.0 * dzeta );\n  tz3 = 1.0 / dzeta;\n\n  ii1 = 1;\n  ii2 = nx0 - 2;\n  ji1 = 1;\n  ji2 = ny0 - 3;\n  ki1 = 2;\n  ki2 = nz0 - 2;\n\n  dx1 = 0.75;\n  dx2 = dx1;\n  dx3 = dx1;\n  dx4 = dx1;\n  dx5 = dx1;\n\n  dy1 = 0.75;\n  dy2 = dy1;\n  dy3 = dy1;\n  dy4 = dy1;\n  dy5 = dy1;\n\n  dz1 = 1.00;\n  dz2 = dz1;\n  dz3 = dz1;\n  dz4 = dz1;\n  dz5 = dz1;\n\n  dssp = ( max (dx1, max(dy1, dz1) ) ) / 4.0;\n\n  ce[0][0] = 2.0;\n  ce[0][1] = 0.0;\n  ce[0][2] = 0.0;\n  ce[0][3] = 4.0;\n  ce[0][4] = 5.0;\n  ce[0][5] = 3.0;\n  ce[0][6] = 5.0e-01;\n  ce[0][7] = 2.0e-02;\n  ce[0][8] = 1.0e-02;\n  ce[0][9] = 3.0e-02;\n  ce[0][10] = 5.0e-01;\n  ce[0][11] = 4.0e-01;\n  ce[0][12] = 3.0e-01;\n\n  ce[1][0] = 1.0;\n  ce[1][1] = 0.0;\n  ce[1][2] = 0.0;\n  ce[1][3] = 0.0;\n  ce[1][4] = 1.0;\n  ce[1][5] = 2.0;\n  ce[1][6] = 3.0;\n  ce[1][7] = 1.0e-02;\n  ce[1][8] = 3.0e-02;\n  ce[1][9] = 2.0e-02;\n  ce[1][10] = 4.0e-01;\n  ce[1][11] = 3.0e-01;\n  ce[1][12] = 5.0e-01;\n\n  ce[2][0] = 2.0;\n  ce[2][1] = 2.0;\n  ce[2][2] = 0.0;\n  ce[2][3] = 0.0;\n  ce[2][4] = 0.0;\n  ce[2][5] = 2.0;\n  ce[2][6] = 3.0;\n  ce[2][7] = 4.0e-02;\n  ce[2][8] = 3.0e-02;\n  ce[2][9] = 5.0e-02;\n  ce[2][10] = 3.0e-01;\n  ce[2][11] = 5.0e-01;\n  ce[2][12] = 4.0e-01;\n\n  ce[3][0] = 2.0;\n  ce[3][1] = 2.0;\n  ce[3][2] = 0.0;\n  ce[3][3] = 0.0;\n  ce[3][4] = 0.0;\n  ce[3][5] = 2.0;\n  ce[3][6] = 3.0;\n  ce[3][7] = 3.0e-02;\n  ce[3][8] = 5.0e-02;\n  ce[3][9] = 4.0e-02;\n  ce[3][10] = 2.0e-01;\n  ce[3][11] = 1.0e-01;\n  ce[3][12] = 3.0e-01;\n\n  ce[4][0] = 5.0;\n  ce[4][1] = 4.0;\n  ce[4][2] = 3.0;\n  ce[4][3] = 2.0;\n  ce[4][4] = 1.0e-01;\n  ce[4][5] = 4.0e-01;\n  ce[4][6] = 3.0e-01;\n  ce[4][7] = 5.0e-02;\n  ce[4][8] = 4.0e-02;\n  ce[4][9] = 3.0e-02;\n  ce[4][10] = 1.0e-01;\n  ce[4][11] = 3.0e-01;\n  ce[4][12] = 2.0e-01;\n}\n\n\n\nstatic void setiv(void) {\n\n#pragma omp parallel\n{\n\n  int i, j, k, m;\n  int iglob, jglob;\n  double  xi, eta, zeta;\n  double  pxi, peta, pzeta;\n  double  ue_1jk[5],ue_nx0jk[5],ue_i1k[5],\n    ue_iny0k[5],ue_ij1[5],ue_ijnz[5];\n\n#pragma omp for\n  for (j = 0; j < ny; j++) {\n    jglob = j;\n    for (k = 1; k < nz - 1; k++) {\n      zeta = ((double)k) / (nz-1);\n      if (jglob != 0 && jglob != ny0-1) {\n\teta = ( (double) (jglob) ) / (ny0-1);\n\tfor (i = 0; i < nx; i++) {\n\t  iglob = i;\n\t  if(iglob != 0 && iglob != nx0-1) {\n\t    xi = ( (double) (iglob) ) / (nx0-1);\n\t    exact (0,jglob,k,ue_1jk);\n\t    exact (nx0-1,jglob,k,ue_nx0jk);\n\t    exact (iglob,0,k,ue_i1k);\n\t    exact (iglob,ny0-1,k,ue_iny0k);\n\t    exact (iglob,jglob,0,ue_ij1);\n\t    exact (iglob,jglob,nz-1,ue_ijnz);\n\t    for (m = 0; m < 5; m++) {\n\t      pxi =   ( 1.0 - xi ) * ue_1jk[m]\n\t\t+ xi   * ue_nx0jk[m];\n\t      peta =  ( 1.0 - eta ) * ue_i1k[m]\n\t\t+ eta   * ue_iny0k[m];\n\t      pzeta = ( 1.0 - zeta ) * ue_ij1[m]\n\t\t+ zeta   * ue_ijnz[m];\n\n\t      u[i][j][k][m] = pxi + peta + pzeta\n\t\t- pxi * peta - peta * pzeta - pzeta * pxi\n\t\t+ pxi * peta * pzeta;\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\n}\n\nstatic void ssor(void) {\n\n\n  int i, j, k, m;\n  int istep;\n  double  tmp;\n  double  delunm[5], tv[ISIZ1][ISIZ2][5];\n\n  tmp = 1.0 / ( omega * ( 2.0 - omega ) ) ;\n\n#pragma omp parallel private(i,j,k,m)\n{\n#pragma omp for    \n  for (i = 0; i < ISIZ1; i++) {\n    for (j = 0; j < ISIZ2; j++) {\n      for (k = 0; k < 5; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  a[i][j][k][m] = 0.0;\n\t  b[i][j][k][m] = 0.0;\n\t  c[i][j][k][m] = 0.0;\n\t  d[i][j][k][m] = 0.0;\n\t}\n      }\n    }\n  }\n}\n  rhs();\n \n  l2norm( nx0, ny0, nz0,\n\t  ist, iend, jst, jend,\n\t  rsd, rsdnm );\n\n\n  timer_clear(1);\n  timer_start(1);\n \n\n\n  for (istep = 1; istep <= itmax; istep++) {\n\n    if (istep%20  ==  0 || istep  ==  itmax || istep  ==  1) {\n#pragma omp master\t\n      printf(\" Time step %4d\\n\", istep);\n    }\n\n#pragma omp parallel private(istep,i,j,k,m)\n{  \n \n#pragma omp for    \n    for (i = ist; i <= iend; i++) {\n      for (j = jst; j <= jend; j++) {\n\tfor (k = 1; k <= nz - 2; k++) {\n\t  for (m = 0; m < 5; m++) {\n\t    rsd[i][j][k][m] = dt * rsd[i][j][k][m];\n\t  }\n\t}\n      }\n    }\n\n    for (k = 1; k <= nz - 2; k++) {\n      jacld(k);\n \n      blts(nx, ny, nz, k,\n\t   omega,\n\t   rsd,\n\t   a, b, c, d,\n\t   ist, iend, jst, jend, \n\t   nx0, ny0 );\n    }\n    \n#pragma omp barrier\n\n    for (k = nz - 2; k >= 1; k--) {\n      jacu(k);\n\n      buts(nx, ny, nz, k,\n\t   omega,\n\t   rsd, tv,\n\t   d, a, b, c,\n\t   ist, iend, jst, jend,\n\t   nx0, ny0 );\n    }\n#pragma omp barrier \n \n\n#pragma omp for\n    for (i = ist; i <= iend; i++) {\n      for (j = jst; j <= jend; j++) {\n\tfor (k = 1; k <= nz-2; k++) {\n\t  for (m = 0; m < 5; m++) {\n\t    u[i][j][k][m] = u[i][j][k][m]\n\t      + tmp * rsd[i][j][k][m];\n\t  }\n\t}\n      }\n    }\n} /* end parallel */\n} /* end parallel */\n    if ( istep % inorm  ==  0 ) {\n      l2norm( nx0, ny0, nz0,\n\t      ist, iend, jst, jend,\n\t      rsd, delunm );\n    }\n \n    rhs();\n \n    if ( ( istep % inorm  ==  0 ) ||\n\t ( istep  ==  itmax ) ) {\n      l2norm( nx0, ny0, nz0,\n\t      ist, iend, jst, jend,\n\t      rsd, rsdnm );\n    }\n\n    if ( ( rsdnm[0] < tolrsd[0] ) &&\n\t ( rsdnm[1] < tolrsd[1] ) &&\n\t ( rsdnm[2] < tolrsd[2] ) &&\n\t ( rsdnm[3] < tolrsd[3] ) &&\n\t ( rsdnm[4] < tolrsd[4] ) ) {\n\texit(1);\n    }\n  }\n\n \n  timer_stop(1);\n  maxtime= timer_read(1);\n \n}\n\n\nstatic void verify(double xcr[5], double xce[5], double xci,\n\t\t   char *class, boolean *verified) {\n\n\n  double xcrref[5],xceref[5],xciref, \n    xcrdif[5],xcedif[5],xcidif,\n    epsilon, dtref;\n  int m;\n\n  epsilon = 1.0e-08;\n\n  *class = 'U';\n  *verified = TRUE;\n\n  for (m = 0; m < 5; m++) {\n    xcrref[m] = 1.0;\n    xceref[m] = 1.0;\n  }\n  xciref = 1.0;\n\n  if ( nx0 == 12 && ny0 == 12 && nz0 == 12 && itmax == 50)  {\n    *class = 'S';\n    dtref = 5.0e-1;\n\n    xcrref[0] = 1.6196343210976702e-02;\n    xcrref[1] = 2.1976745164821318e-03;\n    xcrref[2] = 1.5179927653399185e-03;\n    xcrref[3] = 1.5029584435994323e-03;\n    xcrref[4] = 3.4264073155896461e-02;\n\n    xceref[0] = 6.4223319957960924e-04;\n    xceref[1] = 8.4144342047347926e-05;\n    xceref[2] = 5.8588269616485186e-05;\n    xceref[3] = 5.8474222595157350e-05;\n    xceref[4] = 1.3103347914111294e-03;\n\n    xciref = 7.8418928865937083;\n\n  } else if ( nx0 == 33 && ny0 == 33 && nz0 == 33 && itmax == 300) {\n\n    *class = 'W';   /* SPEC95fp size */\n    *class = 'W';   /* SPEC95fp size */\n    dtref = 1.5e-3;\n    xcrref[0] =   0.1236511638192e+02;\n    xcrref[1] =   0.1317228477799e+01;\n    xcrref[2] =   0.2550120713095e+01;\n    xcrref[3] =   0.2326187750252e+01;\n    xcrref[4] =   0.2826799444189e+02;\n\n    xceref[0] =   0.4867877144216;\n    xceref[1] =   0.5064652880982e-01;\n    xceref[2] =   0.9281818101960e-01;\n    xceref[3] =   0.8570126542733e-01;\n    xceref[4] =   0.1084277417792e+01;\n\n    xciref    =   0.1161399311023e+02;\n\n  } else if ( nx0 == 64 && ny0 == 64 && nz0 == 64 && itmax == 250) {\n\n    *class = 'A';\n    dtref = 2.0e+0;\n    xcrref[0] = 7.7902107606689367e+02;\n    xcrref[1] = 6.3402765259692870e+01;\n    xcrref[2] = 1.9499249727292479e+02;\n    xcrref[3] = 1.7845301160418537e+02;\n    xcrref[4] = 1.8384760349464247e+03;\n\n    xceref[0] = 2.9964085685471943e+01;\n    xceref[1] = 2.8194576365003349;\n    xceref[2] = 7.3473412698774742;\n    xceref[3] = 6.7139225687777051;\n    xceref[4] = 7.0715315688392578e+01;\n\n    xciref = 2.6030925604886277e+01;\n\n    } else if ( nx0 == 102 && ny0 == 102 && nz0 == 102 && itmax == 250) {\n\n      *class = 'B';\n      dtref = 2.0e+0;\n\n      xcrref[0] = 3.5532672969982736e+03;\n      xcrref[1] = 2.6214750795310692e+02;\n      xcrref[2] = 8.8333721850952190e+02;\n      xcrref[3] = 7.7812774739425265e+02;\n      xcrref[4] = 7.3087969592545314e+03;\n\n      xceref[0] = 1.1401176380212709e+02;\n      xceref[1] = 8.1098963655421574;\n      xceref[2] = 2.8480597317698308e+01;\n      xceref[3] = 2.5905394567832939e+01;\n      xceref[4] = 2.6054907504857413e+02;\n\n      xciref = 4.7887162703308227e+01;\n\n      } else if ( nx0 == 162 && ny0 == 162 && nz0 == 162 && itmax == 250) {\n\n\t*class = 'C';\n\tdtref = 2.0e+0;\n\n\txcrref[0] = 1.03766980323537846e+04;\n\txcrref[1] = 8.92212458801008552e+02;\n\txcrref[2] = 2.56238814582660871e+03;\n\txcrref[3] = 2.19194343857831427e+03;\n\txcrref[4] = 1.78078057261061185e+04;\n\n\txceref[0] = 2.15986399716949279e+02;\n\txceref[1] = 1.55789559239863600e+01;\n\txceref[2] = 5.41318863077207766e+01;\n\txceref[3] = 4.82262643154045421e+01;\n\txceref[4] = 4.55902910043250358e+02;\n\n\txciref = 6.66404553572181300e+01;\n      } else {\n\t*verified = FALSE;\n      }\n\n\n  for (m = 0; m < 5; m++) {\n           \n    xcrdif[m] = fabs((xcr[m]-xcrref[m])/xcrref[m]);\n    xcedif[m] = fabs((xce[m]-xceref[m])/xceref[m]);\n           \n  }\n  xcidif = fabs((xci - xciref)/xciref);\n\n\n  if (*class != 'U') {\n    printf(\"\\n Verification being performed for class %1c\\n\", *class);\n    printf(\" Accuracy setting for epsilon = %20.13e\\n\", epsilon);\n    if (fabs(dt-dtref) > epsilon) {  \n      *verified = FALSE;\n      *class = 'U';\n      printf(\" DT does not match the reference value of %15.8e\\n\", dtref);\n    }\n  } else {\n    printf(\" Unknown class\\n\");\n  }\n\n  if (*class != 'U') {\n    printf(\" Comparison of RMS-norms of residual\\n\");\n  } else {\n    printf(\" RMS-norms of residual\\n\");\n  }\n\n  for (m = 0; m < 5; m++) {\n    if (*class  ==  'U') {\n      printf(\"          %2d  %20.13e\\n\", m, xcr[m]);\n    } else if (xcrdif[m] > epsilon) {\n      *verified = FALSE;\n      printf(\" FAILURE: %2d  %20.13e%20.13e%20.13e\\n\",\n\t     m,xcr[m],xcrref[m],xcrdif[m]);\n    } else {\n      printf(\"          %2d  %20.13e%20.13e%20.13e\\n\",\n\t     m,xcr[m],xcrref[m],xcrdif[m]);\n    }\n  }\n\n  if (*class != 'U') {\n    printf(\" Comparison of RMS-norms of solution error\\n\");\n  } else {\n    printf(\" RMS-norms of solution error\\n\");\n  }\n        \n  for (m = 0; m < 5; m++) {\n    if (*class  ==  'U') {\n      printf(\"          %2d  %20.13e\\n\", m, xce[m]);\n    } else if (xcedif[m] > epsilon) {\n      *verified = FALSE;\n      printf(\" FAILURE: %2d  %20.13e%20.13e%20.13e\\n\",\n\t     m,xce[m],xceref[m],xcedif[m]);\n    } else {\n      printf(\"          %2d  %20.13e%20.13e%20.13e\\n\",\n\t     m,xce[m],xceref[m],xcedif[m]);\n    }\n  }\n        \n  if (*class != 'U') {\n    printf(\" Comparison of surface integral\\n\");\n  } else {\n    printf(\" Surface integral\\n\");\n  }\n\n  if (*class  ==  'U') {\n    printf(\"              %20.13e\\n\", xci);\n  } else if (xcidif > epsilon) {\n    *verified = FALSE;\n    printf(\" FAILURE:     %20.13e%20.13e%20.13e\\n\", \n\t   xci, xciref, xcidif);\n  } else {\n    printf(\"              %20.13e%20.13e%20.13e\\n\",\n\t   xci, xciref, xcidif);\n  }\n\n  if (*class  ==  'U') {\n    printf(\" No reference values provided\\n\");\n    printf(\" No verification performed\\n\");\n  } else if (*verified) {\n    printf(\" Verification Successful\\n\");\n  } else {\n    printf(\" Verification failed\\n\");\n  }\n}\n"}, {"prompt": "#include \"npb-C.h\"\n\n#endif /* _OPENMP */\n#endif /* _OPENMP */\n} /* end parallel */\n} /* end parallel */\n\n  timer_stop(1);\n  tmax = timer_read(1);\n       \n  verify(niter, &class, &verified);\n\n  n3 = grid_points[0]*grid_points[1]*grid_points[2];\n  navg = (grid_points[0]+grid_points[1]+grid_points[2])/3.0;\n  if ( tmax != 0.0 ) {\n    mflops = 1.0e-6*(double)niter*\n\t(3478.8*(double)n3-17655.7*pow2(navg)+28023.7*navg) / tmax;\n  } else {\n    mflops = 0.0;\n  }\n  c_print_results(\"BT\", class, grid_points[0], \n\t\t  grid_points[1], grid_points[2], niter, nthreads,\n\t\t  tmax, mflops, \"          floating point\", \n\t\t  verified, NPBVERSION,COMPILETIME, CS1, CS2, CS3, CS4, CS5, \n\t\t  CS6, \"(none)\");\n}\nstatic void add(void) {\n\n  int i, j, k, m;\n  \n#pragma omp for\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  u[i][j][k][m] = u[i][j][k][m] + rhs[i][j][k][m];\n\t}\n      }\n    }\n  }\n}\n\nstatic void adi(void) {\n#pragma omp parallel\n    compute_rhs();\n\n#pragma omp parallel\n    x_solve();\n\n#pragma omp parallel\n    y_solve();\n\n#pragma omp parallel\n    z_solve();\n\n#pragma omp parallel\n    add();\n}\n\nstatic void error_norm(double rms[5]) {\n  int i, j, k, m, d;\n  double xi, eta, zeta, u_exact[5], add;\n\n  for (m = 0; m < 5; m++) {\n    rms[m] = 0.0;\n  }\n\n  for (i = 0; i < grid_points[0]; i++) {\n    xi = (double)i * dnxm1;\n    for (j = 0; j < grid_points[1]; j++) {\n      eta = (double)j * dnym1;\n      for (k = 0; k < grid_points[2]; k++) {\n\tzeta = (double)k * dnzm1;\n\texact_solution(xi, eta, zeta, u_exact);\n\n\tfor (m = 0; m < 5; m++) {\n\t  add = u[i][j][k][m] - u_exact[m];\n\t  rms[m] = rms[m] + add*add;\n\t}\n      }\n    }\n  }\n\n  for (m = 0; m < 5; m++) {\n    for (d = 0; d <= 2; d++) {\n      rms[m] = rms[m] / (double)(grid_points[d]-2);\n    }\n    rms[m] = sqrt(rms[m]);\n  }\n}\n\nstatic void rhs_norm(double rms[5]) {\n  int i, j, k, d, m;\n  double add;\n\n  for (m = 0; m < 5; m++) {\n    rms[m] = 0.0;\n  }\n\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  add = rhs[i][j][k][m];\n\t  rms[m] = rms[m] + add*add;\n\t}\n      }\n    }\n  }\n\n  for (m = 0; m < 5; m++) {\n    for (d = 0; d <= 2; d++) {\n      rms[m] = rms[m] / (double)(grid_points[d]-2);\n    }\n    rms[m] = sqrt(rms[m]);\n  }\n}\n\nstatic void exact_rhs(void) {\n\n#pragma omp parallel\n{\n  double dtemp[5], xi, eta, zeta, dtpp;\n  int m, i, j, k, ip1, im1, jp1, jm1, km1, kp1;\n\n#pragma omp for  \n  for (i = 0; i < grid_points[0]; i++) {\n    for (j = 0; j < grid_points[1]; j++) {\n      for (k = 0; k < grid_points[2]; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  forcing[i][j][k][m] = 0.0;\n\t}\n      }\n    }\n  }\n\n\n#pragma omp for\n  for (j = 1; j < grid_points[1]-1; j++) {\n    eta = (double)j * dnym1;\n    \n    for (k = 1; k < grid_points[2]-1; k++) {\n      zeta = (double)k * dnzm1;\n\n      for (i = 0; i < grid_points[0]; i++) {\n\txi = (double)i * dnxm1;\n\n\texact_solution(xi, eta, zeta, dtemp);\n\tfor (m = 0; m < 5; m++) {\n\t  ue[i][m] = dtemp[m];\n\t}\n\n\tdtpp = 1.0 / dtemp[0];\n\n\tfor (m = 1; m <= 4; m++) {\n\t  buf[i][m] = dtpp * dtemp[m];\n\t}\n\n\tcuf[i]   = buf[i][1] * buf[i][1];\n\tbuf[i][0] = cuf[i] + buf[i][2] * buf[i][2] + \n\t  buf[i][3] * buf[i][3];\n\tq[i] = 0.5*(buf[i][1]*ue[i][1] + buf[i][2]*ue[i][2] +\n\t\t    buf[i][3]*ue[i][3]);\n      }\n               \n      for (i = 1; i < grid_points[0]-1; i++) {\n\tim1 = i-1;\n\tip1 = i+1;\n\n\tforcing[i][j][k][0] = forcing[i][j][k][0] -\n\t  tx2*(ue[ip1][1]-ue[im1][1])+\n\t  dx1tx1*(ue[ip1][0]-2.0*ue[i][0]+ue[im1][0]);\n\n\tforcing[i][j][k][1] = forcing[i][j][k][1] -\n\t  tx2 * ((ue[ip1][1]*buf[ip1][1]+c2*(ue[ip1][4]-q[ip1]))-\n\t\t (ue[im1][1]*buf[im1][1]+c2*(ue[im1][4]-q[im1])))+\n\t  xxcon1*(buf[ip1][1]-2.0*buf[i][1]+buf[im1][1])+\n\t  dx2tx1*( ue[ip1][1]-2.0* ue[i][1]+ ue[im1][1]);\n\n\tforcing[i][j][k][2] = forcing[i][j][k][2] -\n\t  tx2 * (ue[ip1][2]*buf[ip1][1]-ue[im1][2]*buf[im1][1])+\n\t  xxcon2*(buf[ip1][2]-2.0*buf[i][2]+buf[im1][2])+\n\t  dx3tx1*( ue[ip1][2]-2.0* ue[i][2]+ ue[im1][2]);\n                  \n\tforcing[i][j][k][3] = forcing[i][j][k][3] -\n\t  tx2*(ue[ip1][3]*buf[ip1][1]-ue[im1][3]*buf[im1][1])+\n\t  xxcon2*(buf[ip1][3]-2.0*buf[i][3]+buf[im1][3])+\n\t  dx4tx1*( ue[ip1][3]-2.0* ue[i][3]+ ue[im1][3]);\n\n\tforcing[i][j][k][4] = forcing[i][j][k][4] -\n\t  tx2*(buf[ip1][1]*(c1*ue[ip1][4]-c2*q[ip1])-\n\t       buf[im1][1]*(c1*ue[im1][4]-c2*q[im1]))+\n\t  0.5*xxcon3*(buf[ip1][0]-2.0*buf[i][0]+buf[im1][0])+\n\t  xxcon4*(cuf[ip1]-2.0*cuf[i]+cuf[im1])+\n\t  xxcon5*(buf[ip1][4]-2.0*buf[i][4]+buf[im1][4])+\n\t  dx5tx1*( ue[ip1][4]-2.0* ue[i][4]+ ue[im1][4]);\n      }\n\n      for (m = 0; m < 5; m++) {\n\ti = 1;\n\tforcing[i][j][k][m] = forcing[i][j][k][m] - dssp *\n\t  (5.0*ue[i][m] - 4.0*ue[i+1][m] +ue[i+2][m]);\n\ti = 2;\n\tforcing[i][j][k][m] = forcing[i][j][k][m] - dssp *\n\t  (-4.0*ue[i-1][m] + 6.0*ue[i][m] -\n\t    4.0*ue[i+1][m] +     ue[i+2][m]);\n      }\n\n      for (m = 0; m < 5; m++) {\n\tfor (i = 1*3; i <= grid_points[0]-3*1-1; i++) {\n\t  forcing[i][j][k][m] = forcing[i][j][k][m] - dssp*\n\t    (ue[i-2][m] - 4.0*ue[i-1][m] +\n\t     6.0*ue[i][m] - 4.0*ue[i+1][m] + ue[i+2][m]);\n\t}\n      }\n\n      for (m = 0; m < 5; m++) {\n\ti = grid_points[0]-3;\n\tforcing[i][j][k][m] = forcing[i][j][k][m] - dssp *\n\t  (ue[i-2][m] - 4.0*ue[i-1][m] +\n\t   6.0*ue[i][m] - 4.0*ue[i+1][m]);\n\ti = grid_points[0]-2;\n\tforcing[i][j][k][m] = forcing[i][j][k][m] - dssp *\n\t  (ue[i-2][m] - 4.0*ue[i-1][m] + 5.0*ue[i][m]);\n      }\n\n    }\n  }\n\n#pragma omp for\n  for (i = 1; i < grid_points[0]-1; i++) {\n    xi = (double)i * dnxm1;\n    \n    for (k = 1; k < grid_points[2]-1; k++) {\n      zeta = (double)k * dnzm1;\n\n      for (j = 0; j < grid_points[1]; j++) {\n\teta = (double)j * dnym1;\n\n\texact_solution(xi, eta, zeta, dtemp);\n\tfor (m = 0; m < 5; m++) {\n\t  ue[j][m] = dtemp[m];\n\t}\n                  \n\tdtpp = 1.0/dtemp[0];\n\n\tfor (m = 1; m <= 4; m++) {\n\t  buf[j][m] = dtpp * dtemp[m];\n\t}\n\n\tcuf[j]   = buf[j][2] * buf[j][2];\n\tbuf[j][0] = cuf[j] + buf[j][1] * buf[j][1] + \n\t  buf[j][3] * buf[j][3];\n\tq[j] = 0.5*(buf[j][1]*ue[j][1] + buf[j][2]*ue[j][2] +\n\t\t    buf[j][3]*ue[j][3]);\n      }\n\n      for (j = 1; j < grid_points[1]-1; j++) {\n\tjm1 = j-1;\n\tjp1 = j+1;\n                  \n\tforcing[i][j][k][0] = forcing[i][j][k][0] -\n\t  ty2*( ue[jp1][2]-ue[jm1][2] )+\n\t  dy1ty1*(ue[jp1][0]-2.0*ue[j][0]+ue[jm1][0]);\n\n\tforcing[i][j][k][1] = forcing[i][j][k][1] -\n\t  ty2*(ue[jp1][1]*buf[jp1][2]-ue[jm1][1]*buf[jm1][2])+\n\t  yycon2*(buf[jp1][1]-2.0*buf[j][1]+buf[jm1][1])+\n\t  dy2ty1*( ue[jp1][1]-2.0* ue[j][1]+ ue[jm1][1]);\n\n\tforcing[i][j][k][2] = forcing[i][j][k][2] -\n\t  ty2*((ue[jp1][2]*buf[jp1][2]+c2*(ue[jp1][4]-q[jp1]))-\n\t       (ue[jm1][2]*buf[jm1][2]+c2*(ue[jm1][4]-q[jm1])))+\n\t  yycon1*(buf[jp1][2]-2.0*buf[j][2]+buf[jm1][2])+\n\t  dy3ty1*( ue[jp1][2]-2.0*ue[j][2] +ue[jm1][2]);\n\n\tforcing[i][j][k][3] = forcing[i][j][k][3] -\n\t  ty2*(ue[jp1][3]*buf[jp1][2]-ue[jm1][3]*buf[jm1][2])+\n\t  yycon2*(buf[jp1][3]-2.0*buf[j][3]+buf[jm1][3])+\n\t  dy4ty1*( ue[jp1][3]-2.0*ue[j][3]+ ue[jm1][3]);\n\n\tforcing[i][j][k][4] = forcing[i][j][k][4] -\n\t  ty2*(buf[jp1][2]*(c1*ue[jp1][4]-c2*q[jp1])-\n\t       buf[jm1][2]*(c1*ue[jm1][4]-c2*q[jm1]))+\n\t  0.5*yycon3*(buf[jp1][0]-2.0*buf[j][0]+\n                      buf[jm1][0])+\n\t  yycon4*(cuf[jp1]-2.0*cuf[j]+cuf[jm1])+\n\t  yycon5*(buf[jp1][4]-2.0*buf[j][4]+buf[jm1][4])+\n\t  dy5ty1*(ue[jp1][4]-2.0*ue[j][4]+ue[jm1][4]);\n      }\n\n      for (m = 0; m < 5; m++) {\n\tj = 1;\n\tforcing[i][j][k][m] = forcing[i][j][k][m] - dssp *\n\t  (5.0*ue[j][m] - 4.0*ue[j+1][m] +ue[j+2][m]);\n\tj = 2;\n\tforcing[i][j][k][m] = forcing[i][j][k][m] - dssp *\n\t  (-4.0*ue[j-1][m] + 6.0*ue[j][m] -\n\t   4.0*ue[j+1][m] +       ue[j+2][m]);\n      }\n\n      for (m = 0; m < 5; m++) {\n\tfor (j = 1*3; j <= grid_points[1]-3*1-1; j++) {\n\t  forcing[i][j][k][m] = forcing[i][j][k][m] - dssp*\n\t    (ue[j-2][m] - 4.0*ue[j-1][m] +\n\t     6.0*ue[j][m] - 4.0*ue[j+1][m] + ue[j+2][m]);\n\t}\n      }\n\n      for (m = 0; m < 5; m++) {\n\tj = grid_points[1]-3;\n\tforcing[i][j][k][m] = forcing[i][j][k][m] - dssp *\n\t  (ue[j-2][m] - 4.0*ue[j-1][m] +\n\t   6.0*ue[j][m] - 4.0*ue[j+1][m]);\n\tj = grid_points[1]-2;\n\tforcing[i][j][k][m] = forcing[i][j][k][m] - dssp *\n\t  (ue[j-2][m] - 4.0*ue[j-1][m] + 5.0*ue[j][m]);\n      }\n\n    }\n  }\n\n#pragma omp for\n  for (i = 1; i < grid_points[0]-1; i++) {\n    xi = (double)i * dnxm1;\n    \n    for (j = 1; j < grid_points[1]-1; j++) {\n      eta = (double)j * dnym1;\n\n      for (k = 0; k < grid_points[2]; k++) {\n\tzeta = (double)k * dnzm1;\n\n\texact_solution(xi, eta, zeta, dtemp);\n\tfor (m = 0; m < 5; m++) {\n\t  ue[k][m] = dtemp[m];\n\t}\n\n\tdtpp = 1.0/dtemp[0];\n\n\tfor (m = 1; m <= 4; m++) {\n\t  buf[k][m] = dtpp * dtemp[m];\n\t}\n\n\tcuf[k]   = buf[k][3] * buf[k][3];\n\tbuf[k][0] = cuf[k] + buf[k][1] * buf[k][1] + \n\t  buf[k][2] * buf[k][2];\n\tq[k] = 0.5*(buf[k][1]*ue[k][1] + buf[k][2]*ue[k][2] +\n\t\t    buf[k][3]*ue[k][3]);\n      }\n\n      for (k = 1; k < grid_points[2]-1; k++) {\n\tkm1 = k-1;\n\tkp1 = k+1;\n                  \n\tforcing[i][j][k][0] = forcing[i][j][k][0] -\n\t  tz2*( ue[kp1][3]-ue[km1][3] )+\n\t  dz1tz1*(ue[kp1][0]-2.0*ue[k][0]+ue[km1][0]);\n\n\tforcing[i][j][k][1] = forcing[i][j][k][1] -\n\t  tz2 * (ue[kp1][1]*buf[kp1][3]-ue[km1][1]*buf[km1][3])+\n\t  zzcon2*(buf[kp1][1]-2.0*buf[k][1]+buf[km1][1])+\n\t  dz2tz1*( ue[kp1][1]-2.0* ue[k][1]+ ue[km1][1]);\n\n\tforcing[i][j][k][2] = forcing[i][j][k][2] -\n\t  tz2 * (ue[kp1][2]*buf[kp1][3]-ue[km1][2]*buf[km1][3])+\n\t  zzcon2*(buf[kp1][2]-2.0*buf[k][2]+buf[km1][2])+\n\t  dz3tz1*(ue[kp1][2]-2.0*ue[k][2]+ue[km1][2]);\n\n\tforcing[i][j][k][3] = forcing[i][j][k][3] -\n\t  tz2 * ((ue[kp1][3]*buf[kp1][3]+c2*(ue[kp1][4]-q[kp1]))-\n\t\t (ue[km1][3]*buf[km1][3]+c2*(ue[km1][4]-q[km1])))+\n\t  zzcon1*(buf[kp1][3]-2.0*buf[k][3]+buf[km1][3])+\n\t  dz4tz1*( ue[kp1][3]-2.0*ue[k][3] +ue[km1][3]);\n\n\tforcing[i][j][k][4] = forcing[i][j][k][4] -\n\t  tz2 * (buf[kp1][3]*(c1*ue[kp1][4]-c2*q[kp1])-\n\t\t buf[km1][3]*(c1*ue[km1][4]-c2*q[km1]))+\n\t  0.5*zzcon3*(buf[kp1][0]-2.0*buf[k][0]\n                      +buf[km1][0])+\n\t  zzcon4*(cuf[kp1]-2.0*cuf[k]+cuf[km1])+\n\t  zzcon5*(buf[kp1][4]-2.0*buf[k][4]+buf[km1][4])+\n\t  dz5tz1*( ue[kp1][4]-2.0*ue[k][4]+ ue[km1][4]);\n      }\n\n      for (m = 0; m < 5; m++) {\n\tk = 1;\n\tforcing[i][j][k][m] = forcing[i][j][k][m] - dssp *\n\t  (5.0*ue[k][m] - 4.0*ue[k+1][m] +ue[k+2][m]);\n\tk = 2;\n\tforcing[i][j][k][m] = forcing[i][j][k][m] - dssp *\n\t  (-4.0*ue[k-1][m] + 6.0*ue[k][m] -\n\t   4.0*ue[k+1][m] +       ue[k+2][m]);\n      }\n\n      for (m = 0; m < 5; m++) {\n\tfor (k = 1*3; k <= grid_points[2]-3*1-1; k++) {\n\t  forcing[i][j][k][m] = forcing[i][j][k][m] - dssp*\n\t    (ue[k-2][m] - 4.0*ue[k-1][m] +\n\t     6.0*ue[k][m] - 4.0*ue[k+1][m] + ue[k+2][m]);\n\t}\n      }\n\n      for (m = 0; m < 5; m++) {\n\tk = grid_points[2]-3;\n\tforcing[i][j][k][m] = forcing[i][j][k][m] - dssp *\n\t  (ue[k-2][m] - 4.0*ue[k-1][m] +\n\t   6.0*ue[k][m] - 4.0*ue[k+1][m]);\n\tk = grid_points[2]-2;\n\tforcing[i][j][k][m] = forcing[i][j][k][m] - dssp *\n\t  (ue[k-2][m] - 4.0*ue[k-1][m] + 5.0*ue[k][m]);\n      }\n\n    }\n  }\n\n#pragma omp for  \n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  forcing[i][j][k][m] = -1.0 * forcing[i][j][k][m];\n\t}\n      }\n    }\n  }\n}\n\n}\n\nstatic void exact_solution(double xi, double eta, double zeta,\n\t\t\t   double dtemp[5]) {\n\n  int m;\n\n  for (m = 0; m < 5; m++) {\n    dtemp[m] =  ce[m][0] +\n      xi*(ce[m][1] + xi*(ce[m][4] + xi*(ce[m][7]\n\t\t\t\t\t+ xi*ce[m][10]))) +\n      eta*(ce[m][2] + eta*(ce[m][5] + eta*(ce[m][8]\n\t\t\t\t\t   + eta*ce[m][11])))+\n      zeta*(ce[m][3] + zeta*(ce[m][6] + zeta*(ce[m][9] + \n\t\t\t\t\t      zeta*ce[m][12])));\n  }\n}\n\nstatic void initialize(void) {\n\n#pragma omp parallel\n{\n\n  int i, j, k, m, ix, iy, iz;\n  double xi, eta, zeta, Pface[2][3][5], Pxi, Peta, Pzeta, temp[5];\n\n\n#pragma omp for\n  for (i = 0; i < IMAX; i++) {\n    for (j = 0; j < IMAX; j++) {\n      for (k = 0; k < IMAX; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  u[i][j][k][m] = 1.0;\n\t}\n      }\n    }\n  }\n\n#pragma omp for\n  for (i = 0; i < grid_points[0]; i++) {\n    xi = (double)i * dnxm1;\n    \n    for (j = 0; j < grid_points[1]; j++) {\n      eta = (double)j * dnym1;\n      \n      for (k = 0; k < grid_points[2]; k++) {\n\tzeta = (double)k * dnzm1;\n                  \n\tfor (ix = 0; ix < 2; ix++) {\n\t  exact_solution((double)ix, eta, zeta, \n                         &(Pface[ix][0][0]));\n\t}\n\n\tfor (iy = 0; iy < 2; iy++) {\n\t  exact_solution(xi, (double)iy , zeta, \n                         &Pface[iy][1][0]);\n\t}\n\n\tfor (iz = 0; iz < 2; iz++) {\n\t  exact_solution(xi, eta, (double)iz,   \n                         &Pface[iz][2][0]);\n\t}\n\n\tfor (m = 0; m < 5; m++) {\n\t  Pxi   = xi   * Pface[1][0][m] + \n\t    (1.0-xi)   * Pface[0][0][m];\n\t  Peta  = eta  * Pface[1][1][m] + \n\t    (1.0-eta)  * Pface[0][1][m];\n\t  Pzeta = zeta * Pface[1][2][m] + \n\t    (1.0-zeta) * Pface[0][2][m];\n                     \n\t  u[i][j][k][m] = Pxi + Peta + Pzeta - \n\t    Pxi*Peta - Pxi*Pzeta - Peta*Pzeta + \n\t    Pxi*Peta*Pzeta;\n\t}\n      }\n    }\n  }\n\n  i = 0;\n  xi = 0.0;\n#pragma omp for nowait\n  for (j = 0; j < grid_points[1]; j++) {\n    eta = (double)j * dnym1;\n    for (k = 0; k < grid_points[2]; k++) {\n      zeta = (double)k * dnzm1;\n      exact_solution(xi, eta, zeta, temp);\n      for (m = 0; m < 5; m++) {\n\tu[i][j][k][m] = temp[m];\n      }\n    }\n  }\n\n  i = grid_points[0]-1;\n  xi = 1.0;\n#pragma omp for\n  for (j = 0; j < grid_points[1]; j++) {\n    eta = (double)j * dnym1;\n    for (k = 0; k < grid_points[2]; k++) {\n      zeta = (double)k * dnzm1;\n      exact_solution(xi, eta, zeta, temp);\n      for (m = 0; m < 5; m++) {\n\tu[i][j][k][m] = temp[m];\n      }\n    }\n  }\n\n  j = 0;\n  eta = 0.0;\n#pragma omp for nowait\n  for (i = 0; i < grid_points[0]; i++) {\n    xi = (double)i * dnxm1;\n    for (k = 0; k < grid_points[2]; k++) {\n      zeta = (double)k * dnzm1;\n      exact_solution(xi, eta, zeta, temp);\n      for (m = 0; m < 5; m++) {\n\tu[i][j][k][m] = temp[m];\n      }\n    }\n  }\n\n  j = grid_points[1]-1;\n  eta = 1.0;\n#pragma omp for\n  for (i = 0; i < grid_points[0]; i++) {\n    xi = (double)i * dnxm1;\n    for (k = 0; k < grid_points[2]; k++) {\n      zeta = (double)k * dnzm1;\n      exact_solution(xi, eta, zeta, temp);\n      for (m = 0; m < 5; m++) {\n\tu[i][j][k][m] = temp[m];\n      }\n    }\n  }\n\n  k = 0;\n  zeta = 0.0;\n#pragma omp for nowait\n  for (i = 0; i < grid_points[0]; i++) {\n    xi = (double)i *dnxm1;\n    for (j = 0; j < grid_points[1]; j++) {\n      eta = (double)j * dnym1;\n      exact_solution(xi, eta, zeta, temp);\n      for (m = 0; m < 5; m++) {\n\tu[i][j][k][m] = temp[m];\n      }\n    }\n  }\n\n  k = grid_points[2]-1;\n  zeta = 1.0;\n#pragma omp for\n  for (i = 0; i < grid_points[0]; i++) {\n    xi = (double)i * dnxm1;\n    for (j = 0; j < grid_points[1]; j++) {\n      eta = (double)j * dnym1;\n      exact_solution(xi, eta, zeta, temp);\n      for (m = 0; m < 5; m++) {\n\tu[i][j][k][m] = temp[m];\n      }\n    }\n  }\n}\n\n}\n\nstatic void lhsinit(void) {\n\n#pragma omp parallel\n{\n  int i, j, k, m, n;\n\n#pragma omp for\n  for (i = 0; i < grid_points[0]; i++) {\n    for (j = 0; j < grid_points[1]; j++) {\n      for (k = 0; k < grid_points[2]; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  for (n = 0; n < 5; n++) {\n\t    lhs[i][j][k][0][m][n] = 0.0;\n\t    lhs[i][j][k][1][m][n] = 0.0;\n\t    lhs[i][j][k][2][m][n] = 0.0;\n\t  }\n\t}\n      }\n    }\n  }\n\n#pragma omp for  \n  for (i = 0; i < grid_points[0]; i++) {\n    for (j = 0; j < grid_points[1]; j++) {\n      for (k = 0; k < grid_points[2]; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  lhs[i][j][k][1][m][m] = 1.0;\n\t}\n      }\n    }\n  }\n}\n\n}\n\nstatic void lhsx(void) {\n  int i, j, k;\n#pragma omp for  \n  for (j = 1; j < grid_points[1]-1; j++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      for (i = 0; i < grid_points[0]; i++) {\n\n\ttmp1 = 1.0 / u[i][j][k][0];\n\ttmp2 = tmp1 * tmp1;\n\ttmp3 = tmp1 * tmp2;\n\n\tfjac[ i][ j][ k][0][0] = 0.0;\n\tfjac[ i][ j][ k][0][1] = 1.0;\n\tfjac[ i][ j][ k][0][2] = 0.0;\n\tfjac[ i][ j][ k][0][3] = 0.0;\n\tfjac[ i][ j][ k][0][4] = 0.0;\n\n\tfjac[ i][ j][ k][1][0] = -(u[i][j][k][1] * tmp2 * \n\t\t\t\t    u[i][j][k][1])\n\t  + c2 * 0.50 * (u[i][j][k][1] * u[i][j][k][1]\n\t\t       + u[i][j][k][2] * u[i][j][k][2]\n\t\t       + u[i][j][k][3] * u[i][j][k][3] ) * tmp2;\n\tfjac[i][j][k][1][1] = ( 2.0 - c2 )\n\t  * ( u[i][j][k][1] / u[i][j][k][0] );\n\tfjac[i][j][k][1][2] = - c2 * ( u[i][j][k][2] * tmp1 );\n\tfjac[i][j][k][1][3] = - c2 * ( u[i][j][k][3] * tmp1 );\n\tfjac[i][j][k][1][4] = c2;\n\n\tfjac[i][j][k][2][0] = - ( u[i][j][k][1]*u[i][j][k][2] ) * tmp2;\n\tfjac[i][j][k][2][1] = u[i][j][k][2] * tmp1;\n\tfjac[i][j][k][2][2] = u[i][j][k][1] * tmp1;\n\tfjac[i][j][k][2][3] = 0.0;\n\tfjac[i][j][k][2][4] = 0.0;\n\n\tfjac[i][j][k][3][0] = - ( u[i][j][k][1]*u[i][j][k][3] ) * tmp2;\n\tfjac[i][j][k][3][1] = u[i][j][k][3] * tmp1;\n\tfjac[i][j][k][3][2] = 0.0;\n\tfjac[i][j][k][3][3] = u[i][j][k][1] * tmp1;\n\tfjac[i][j][k][3][4] = 0.0;\n\n\tfjac[i][j][k][4][0] = ( c2 * ( u[i][j][k][1] * u[i][j][k][1]\n\t\t\t\t     + u[i][j][k][2] * u[i][j][k][2]\n\t\t\t\t     + u[i][j][k][3] * u[i][j][k][3] ) * tmp2\n\t\t\t\t- c1 * ( u[i][j][k][4] * tmp1 ) )\n\t  * ( u[i][j][k][1] * tmp1 );\n\tfjac[i][j][k][4][1] = c1 *  u[i][j][k][4] * tmp1 \n\t  - 0.50 * c2\n\t  * (  3.0*u[i][j][k][1]*u[i][j][k][1]\n\t       + u[i][j][k][2]*u[i][j][k][2]\n\t       + u[i][j][k][3]*u[i][j][k][3] ) * tmp2;\n\tfjac[i][j][k][4][2] = - c2 * ( u[i][j][k][2]*u[i][j][k][1] )\n\t  * tmp2;\n\tfjac[i][j][k][4][3] = - c2 * ( u[i][j][k][3]*u[i][j][k][1] )\n\t  * tmp2;\n\tfjac[i][j][k][4][4] = c1 * ( u[i][j][k][1] * tmp1 );\n\n\tnjac[i][j][k][0][0] = 0.0;\n\tnjac[i][j][k][0][1] = 0.0;\n\tnjac[i][j][k][0][2] = 0.0;\n\tnjac[i][j][k][0][3] = 0.0;\n\tnjac[i][j][k][0][4] = 0.0;\n\n\tnjac[i][j][k][1][0] = - con43 * c3c4 * tmp2 * u[i][j][k][1];\n\tnjac[i][j][k][1][1] =   con43 * c3c4 * tmp1;\n\tnjac[i][j][k][1][2] =   0.0;\n\tnjac[i][j][k][1][3] =   0.0;\n\tnjac[i][j][k][1][4] =   0.0;\n\n\tnjac[i][j][k][2][0] = - c3c4 * tmp2 * u[i][j][k][2];\n\tnjac[i][j][k][2][1] =   0.0;\n\tnjac[i][j][k][2][2] =   c3c4 * tmp1;\n\tnjac[i][j][k][2][3] =   0.0;\n\tnjac[i][j][k][2][4] =   0.0;\n\n\tnjac[i][j][k][3][0] = - c3c4 * tmp2 * u[i][j][k][3];\n\tnjac[i][j][k][3][1] =   0.0;\n\tnjac[i][j][k][3][2] =   0.0;\n\tnjac[i][j][k][3][3] =   c3c4 * tmp1;\n\tnjac[i][j][k][3][4] =   0.0;\n\n\tnjac[i][j][k][4][0] = - ( con43 * c3c4\n\t  - c1345 ) * tmp3 * (pow2(u[i][j][k][1]))\n\t  - ( c3c4 - c1345 ) * tmp3 * (pow2(u[i][j][k][2]))\n\t  - ( c3c4 - c1345 ) * tmp3 * (pow2(u[i][j][k][3]))\n\t  - c1345 * tmp2 * u[i][j][k][4];\n\n\tnjac[i][j][k][4][1] = ( con43 * c3c4\n\t\t\t\t- c1345 ) * tmp2 * u[i][j][k][1];\n\tnjac[i][j][k][4][2] = ( c3c4 - c1345 ) * tmp2 * u[i][j][k][2];\n\tnjac[i][j][k][4][3] = ( c3c4 - c1345 ) * tmp2 * u[i][j][k][3];\n\tnjac[i][j][k][4][4] = ( c1345 ) * tmp1;\n\n      }\n\n      for (i = 1; i < grid_points[0]-1; i++) {\n\n\ttmp1 = dt * tx1;\n\ttmp2 = dt * tx2;\n\n\tlhs[i][j][k][AA][0][0] = - tmp2 * fjac[i-1][j][k][0][0]\n\t  - tmp1 * njac[i-1][j][k][0][0]\n\t  - tmp1 * dx1;\n\tlhs[i][j][k][AA][0][1] = - tmp2 * fjac[i-1][j][k][0][1]\n\t  - tmp1 * njac[i-1][j][k][0][1];\n\tlhs[i][j][k][AA][0][2] = - tmp2 * fjac[i-1][j][k][0][2]\n\t  - tmp1 * njac[i-1][j][k][0][2];\n\tlhs[i][j][k][AA][0][3] = - tmp2 * fjac[i-1][j][k][0][3]\n\t  - tmp1 * njac[i-1][j][k][0][3];\n\tlhs[i][j][k][AA][0][4] = - tmp2 * fjac[i-1][j][k][0][4]\n\t  - tmp1 * njac[i-1][j][k][0][4];\n\n\tlhs[i][j][k][AA][1][0] = - tmp2 * fjac[i-1][j][k][1][0]\n\t  - tmp1 * njac[i-1][j][k][1][0];\n\tlhs[i][j][k][AA][1][1] = - tmp2 * fjac[i-1][j][k][1][1]\n\t  - tmp1 * njac[i-1][j][k][1][1]\n\t  - tmp1 * dx2;\n\tlhs[i][j][k][AA][1][2] = - tmp2 * fjac[i-1][j][k][1][2]\n\t  - tmp1 * njac[i-1][j][k][1][2];\n\tlhs[i][j][k][AA][1][3] = - tmp2 * fjac[i-1][j][k][1][3]\n\t  - tmp1 * njac[i-1][j][k][1][3];\n\tlhs[i][j][k][AA][1][4] = - tmp2 * fjac[i-1][j][k][1][4]\n\t  - tmp1 * njac[i-1][j][k][1][4];\n\n\tlhs[i][j][k][AA][2][0] = - tmp2 * fjac[i-1][j][k][2][0]\n\t  - tmp1 * njac[i-1][j][k][2][0];\n\tlhs[i][j][k][AA][2][1] = - tmp2 * fjac[i-1][j][k][2][1]\n\t  - tmp1 * njac[i-1][j][k][2][1];\n\tlhs[i][j][k][AA][2][2] = - tmp2 * fjac[i-1][j][k][2][2]\n\t  - tmp1 * njac[i-1][j][k][2][2]\n\t  - tmp1 * dx3;\n\tlhs[i][j][k][AA][2][3] = - tmp2 * fjac[i-1][j][k][2][3]\n\t  - tmp1 * njac[i-1][j][k][2][3];\n\tlhs[i][j][k][AA][2][4] = - tmp2 * fjac[i-1][j][k][2][4]\n\t  - tmp1 * njac[i-1][j][k][2][4];\n\n\tlhs[i][j][k][AA][3][0] = - tmp2 * fjac[i-1][j][k][3][0]\n\t  - tmp1 * njac[i-1][j][k][3][0];\n\tlhs[i][j][k][AA][3][1] = - tmp2 * fjac[i-1][j][k][3][1]\n\t  - tmp1 * njac[i-1][j][k][3][1];\n\tlhs[i][j][k][AA][3][2] = - tmp2 * fjac[i-1][j][k][3][2]\n\t  - tmp1 * njac[i-1][j][k][3][2];\n\tlhs[i][j][k][AA][3][3] = - tmp2 * fjac[i-1][j][k][3][3]\n\t  - tmp1 * njac[i-1][j][k][3][3]\n\t  - tmp1 * dx4;\n\tlhs[i][j][k][AA][3][4] = - tmp2 * fjac[i-1][j][k][3][4]\n\t  - tmp1 * njac[i-1][j][k][3][4];\n\n\tlhs[i][j][k][AA][4][0] = - tmp2 * fjac[i-1][j][k][4][0]\n\t  - tmp1 * njac[i-1][j][k][4][0];\n\tlhs[i][j][k][AA][4][1] = - tmp2 * fjac[i-1][j][k][4][1]\n\t  - tmp1 * njac[i-1][j][k][4][1];\n\tlhs[i][j][k][AA][4][2] = - tmp2 * fjac[i-1][j][k][4][2]\n\t  - tmp1 * njac[i-1][j][k][4][2];\n\tlhs[i][j][k][AA][4][3] = - tmp2 * fjac[i-1][j][k][4][3]\n\t  - tmp1 * njac[i-1][j][k][4][3];\n\tlhs[i][j][k][AA][4][4] = - tmp2 * fjac[i-1][j][k][4][4]\n\t  - tmp1 * njac[i-1][j][k][4][4]\n\t  - tmp1 * dx5;\n\n\tlhs[i][j][k][BB][0][0] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][0][0]\n\t  + tmp1 * 2.0 * dx1;\n\tlhs[i][j][k][BB][0][1] = tmp1 * 2.0 * njac[i][j][k][0][1];\n\tlhs[i][j][k][BB][0][2] = tmp1 * 2.0 * njac[i][j][k][0][2];\n\tlhs[i][j][k][BB][0][3] = tmp1 * 2.0 * njac[i][j][k][0][3];\n\tlhs[i][j][k][BB][0][4] = tmp1 * 2.0 * njac[i][j][k][0][4];\n\n\tlhs[i][j][k][BB][1][0] = tmp1 * 2.0 * njac[i][j][k][1][0];\n\tlhs[i][j][k][BB][1][1] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][1][1]\n\t  + tmp1 * 2.0 * dx2;\n\tlhs[i][j][k][BB][1][2] = tmp1 * 2.0 * njac[i][j][k][1][2];\n\tlhs[i][j][k][BB][1][3] = tmp1 * 2.0 * njac[i][j][k][1][3];\n\tlhs[i][j][k][BB][1][4] = tmp1 * 2.0 * njac[i][j][k][1][4];\n\n\tlhs[i][j][k][BB][2][0] = tmp1 * 2.0 * njac[i][j][k][2][0];\n\tlhs[i][j][k][BB][2][1] = tmp1 * 2.0 * njac[i][j][k][2][1];\n\tlhs[i][j][k][BB][2][2] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][2][2]\n\t  + tmp1 * 2.0 * dx3;\n\tlhs[i][j][k][BB][2][3] = tmp1 * 2.0 * njac[i][j][k][2][3];\n\tlhs[i][j][k][BB][2][4] = tmp1 * 2.0 * njac[i][j][k][2][4];\n\n\tlhs[i][j][k][BB][3][0] = tmp1 * 2.0 * njac[i][j][k][3][0];\n\tlhs[i][j][k][BB][3][1] = tmp1 * 2.0 * njac[i][j][k][3][1];\n\tlhs[i][j][k][BB][3][2] = tmp1 * 2.0 * njac[i][j][k][3][2];\n\tlhs[i][j][k][BB][3][3] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][3][3]\n\t  + tmp1 * 2.0 * dx4;\n\tlhs[i][j][k][BB][3][4] = tmp1 * 2.0 * njac[i][j][k][3][4];\n\n\tlhs[i][j][k][BB][4][0] = tmp1 * 2.0 * njac[i][j][k][4][0];\n\tlhs[i][j][k][BB][4][1] = tmp1 * 2.0 * njac[i][j][k][4][1];\n\tlhs[i][j][k][BB][4][2] = tmp1 * 2.0 * njac[i][j][k][4][2];\n\tlhs[i][j][k][BB][4][3] = tmp1 * 2.0 * njac[i][j][k][4][3];\n\tlhs[i][j][k][BB][4][4] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][4][4]\n\t  + tmp1 * 2.0 * dx5;\n\n\tlhs[i][j][k][CC][0][0] =  tmp2 * fjac[i+1][j][k][0][0]\n\t  - tmp1 * njac[i+1][j][k][0][0]\n\t  - tmp1 * dx1;\n\tlhs[i][j][k][CC][0][1] =  tmp2 * fjac[i+1][j][k][0][1]\n\t  - tmp1 * njac[i+1][j][k][0][1];\n\tlhs[i][j][k][CC][0][2] =  tmp2 * fjac[i+1][j][k][0][2]\n\t  - tmp1 * njac[i+1][j][k][0][2];\n\tlhs[i][j][k][CC][0][3] =  tmp2 * fjac[i+1][j][k][0][3]\n\t  - tmp1 * njac[i+1][j][k][0][3];\n\tlhs[i][j][k][CC][0][4] =  tmp2 * fjac[i+1][j][k][0][4]\n\t  - tmp1 * njac[i+1][j][k][0][4];\n\n\tlhs[i][j][k][CC][1][0] =  tmp2 * fjac[i+1][j][k][1][0]\n\t  - tmp1 * njac[i+1][j][k][1][0];\n\tlhs[i][j][k][CC][1][1] =  tmp2 * fjac[i+1][j][k][1][1]\n\t  - tmp1 * njac[i+1][j][k][1][1]\n\t  - tmp1 * dx2;\n\tlhs[i][j][k][CC][1][2] =  tmp2 * fjac[i+1][j][k][1][2]\n\t  - tmp1 * njac[i+1][j][k][1][2];\n\tlhs[i][j][k][CC][1][3] =  tmp2 * fjac[i+1][j][k][1][3]\n\t  - tmp1 * njac[i+1][j][k][1][3];\n\tlhs[i][j][k][CC][1][4] =  tmp2 * fjac[i+1][j][k][1][4]\n\t  - tmp1 * njac[i+1][j][k][1][4];\n\n\tlhs[i][j][k][CC][2][0] =  tmp2 * fjac[i+1][j][k][2][0]\n\t  - tmp1 * njac[i+1][j][k][2][0];\n\tlhs[i][j][k][CC][2][1] =  tmp2 * fjac[i+1][j][k][2][1]\n\t  - tmp1 * njac[i+1][j][k][2][1];\n\tlhs[i][j][k][CC][2][2] =  tmp2 * fjac[i+1][j][k][2][2]\n\t  - tmp1 * njac[i+1][j][k][2][2]\n\t  - tmp1 * dx3;\n\tlhs[i][j][k][CC][2][3] =  tmp2 * fjac[i+1][j][k][2][3]\n\t  - tmp1 * njac[i+1][j][k][2][3];\n\tlhs[i][j][k][CC][2][4] =  tmp2 * fjac[i+1][j][k][2][4]\n\t  - tmp1 * njac[i+1][j][k][2][4];\n\n\tlhs[i][j][k][CC][3][0] =  tmp2 * fjac[i+1][j][k][3][0]\n\t  - tmp1 * njac[i+1][j][k][3][0];\n\tlhs[i][j][k][CC][3][1] =  tmp2 * fjac[i+1][j][k][3][1]\n\t  - tmp1 * njac[i+1][j][k][3][1];\n\tlhs[i][j][k][CC][3][2] =  tmp2 * fjac[i+1][j][k][3][2]\n\t  - tmp1 * njac[i+1][j][k][3][2];\n\tlhs[i][j][k][CC][3][3] =  tmp2 * fjac[i+1][j][k][3][3]\n\t  - tmp1 * njac[i+1][j][k][3][3]\n\t  - tmp1 * dx4;\n\tlhs[i][j][k][CC][3][4] =  tmp2 * fjac[i+1][j][k][3][4]\n\t  - tmp1 * njac[i+1][j][k][3][4];\n\n\tlhs[i][j][k][CC][4][0] =  tmp2 * fjac[i+1][j][k][4][0]\n\t  - tmp1 * njac[i+1][j][k][4][0];\n\tlhs[i][j][k][CC][4][1] =  tmp2 * fjac[i+1][j][k][4][1]\n\t  - tmp1 * njac[i+1][j][k][4][1];\n\tlhs[i][j][k][CC][4][2] =  tmp2 * fjac[i+1][j][k][4][2]\n\t  - tmp1 * njac[i+1][j][k][4][2];\n\tlhs[i][j][k][CC][4][3] =  tmp2 * fjac[i+1][j][k][4][3]\n\t  - tmp1 * njac[i+1][j][k][4][3];\n\tlhs[i][j][k][CC][4][4] =  tmp2 * fjac[i+1][j][k][4][4]\n\t  - tmp1 * njac[i+1][j][k][4][4]\n\t  - tmp1 * dx5;\n\n      }\n    }\n  }\n}\n\nstatic void lhsy(void) {\n  int i, j, k;\n#pragma omp for\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 0; j < grid_points[1]; j++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\n\ttmp1 = 1.0 / u[i][j][k][0];\n\ttmp2 = tmp1 * tmp1;\n\ttmp3 = tmp1 * tmp2;\n\n\tfjac[ i][ j][ k][0][0] = 0.0;\n\tfjac[ i][ j][ k][0][1] = 0.0;\n\tfjac[ i][ j][ k][0][2] = 1.0;\n\tfjac[ i][ j][ k][0][3] = 0.0;\n\tfjac[ i][ j][ k][0][4] = 0.0;\n\n\tfjac[i][j][k][1][0] = - ( u[i][j][k][1]*u[i][j][k][2] )\n\t  * tmp2;\n\tfjac[i][j][k][1][1] = u[i][j][k][2] * tmp1;\n\tfjac[i][j][k][1][2] = u[i][j][k][1] * tmp1;\n\tfjac[i][j][k][1][3] = 0.0;\n\tfjac[i][j][k][1][4] = 0.0;\n\n\tfjac[i][j][k][2][0] = - ( u[i][j][k][2]*u[i][j][k][2]*tmp2)\n\t  + 0.50 * c2 * ( (  u[i][j][k][1] * u[i][j][k][1]\n\t\t\t     + u[i][j][k][2] * u[i][j][k][2]\n\t\t\t     + u[i][j][k][3] * u[i][j][k][3] )\n\t\t\t  * tmp2 );\n\tfjac[i][j][k][2][1] = - c2 *  u[i][j][k][1] * tmp1;\n\tfjac[i][j][k][2][2] = ( 2.0 - c2 )\n\t  *  u[i][j][k][2] * tmp1;\n\tfjac[i][j][k][2][3] = - c2 * u[i][j][k][3] * tmp1;\n\tfjac[i][j][k][2][4] = c2;\n\n\tfjac[i][j][k][3][0] = - ( u[i][j][k][2]*u[i][j][k][3] )\n\t  * tmp2;\n\tfjac[i][j][k][3][1] = 0.0;\n\tfjac[i][j][k][3][2] = u[i][j][k][3] * tmp1;\n\tfjac[i][j][k][3][3] = u[i][j][k][2] * tmp1;\n\tfjac[i][j][k][3][4] = 0.0;\n\n\tfjac[i][j][k][4][0] = ( c2 * (  u[i][j][k][1] * u[i][j][k][1]\n\t\t\t\t\t+ u[i][j][k][2] * u[i][j][k][2]\n\t\t\t\t\t+ u[i][j][k][3] * u[i][j][k][3] )\n\t\t\t\t* tmp2\n\t\t\t\t- c1 * u[i][j][k][4] * tmp1 ) \n\t  * u[i][j][k][2] * tmp1;\n\tfjac[i][j][k][4][1] = - c2 * u[i][j][k][1]*u[i][j][k][2] \n\t  * tmp2;\n\tfjac[i][j][k][4][2] = c1 * u[i][j][k][4] * tmp1 \n\t  - 0.50 * c2 \n\t  * ( (  u[i][j][k][1]*u[i][j][k][1]\n\t\t + 3.0 * u[i][j][k][2]*u[i][j][k][2]\n\t\t + u[i][j][k][3]*u[i][j][k][3] )\n\t      * tmp2 );\n\tfjac[i][j][k][4][3] = - c2 * ( u[i][j][k][2]*u[i][j][k][3] )\n\t  * tmp2;\n\tfjac[i][j][k][4][4] = c1 * u[i][j][k][2] * tmp1; \n\n\tnjac[i][j][k][0][0] = 0.0;\n\tnjac[i][j][k][0][1] = 0.0;\n\tnjac[i][j][k][0][2] = 0.0;\n\tnjac[i][j][k][0][3] = 0.0;\n\tnjac[i][j][k][0][4] = 0.0;\n\n\tnjac[i][j][k][1][0] = - c3c4 * tmp2 * u[i][j][k][1];\n\tnjac[i][j][k][1][1] =   c3c4 * tmp1;\n\tnjac[i][j][k][1][2] =   0.0;\n\tnjac[i][j][k][1][3] =   0.0;\n\tnjac[i][j][k][1][4] =   0.0;\n\n\tnjac[i][j][k][2][0] = - con43 * c3c4 * tmp2 * u[i][j][k][2];\n\tnjac[i][j][k][2][1] =   0.0;\n\tnjac[i][j][k][2][2] =   con43 * c3c4 * tmp1;\n\tnjac[i][j][k][2][3] =   0.0;\n\tnjac[i][j][k][2][4] =   0.0;\n\n\tnjac[i][j][k][3][0] = - c3c4 * tmp2 * u[i][j][k][3];\n\tnjac[i][j][k][3][1] =   0.0;\n\tnjac[i][j][k][3][2] =   0.0;\n\tnjac[i][j][k][3][3] =   c3c4 * tmp1;\n\tnjac[i][j][k][3][4] =   0.0;\n\n\tnjac[i][j][k][4][0] = - (  c3c4\n          - c1345 ) * tmp3 * (pow2(u[i][j][k][1]))\n\t  - ( con43 * c3c4\n\t      - c1345 ) * tmp3 * (pow2(u[i][j][k][2]))\n\t  - ( c3c4 - c1345 ) * tmp3 * (pow2(u[i][j][k][3]))\n\t  - c1345 * tmp2 * u[i][j][k][4];\n\n\tnjac[i][j][k][4][1] = (  c3c4 - c1345 ) * tmp2 * u[i][j][k][1];\n\tnjac[i][j][k][4][2] = ( con43 * c3c4\n\t\t\t\t- c1345 ) * tmp2 * u[i][j][k][2];\n\tnjac[i][j][k][4][3] = ( c3c4 - c1345 ) * tmp2 * u[i][j][k][3];\n\tnjac[i][j][k][4][4] = ( c1345 ) * tmp1;\n\n      }\n    }\n  }\n\n#pragma omp for  \n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\n\ttmp1 = dt * ty1;\n\ttmp2 = dt * ty2;\n\n\tlhs[i][j][k][AA][0][0] = - tmp2 * fjac[i][j-1][k][0][0]\n\t  - tmp1 * njac[i][j-1][k][0][0]\n\t  - tmp1 * dy1;\n\tlhs[i][j][k][AA][0][1] = - tmp2 * fjac[i][j-1][k][0][1]\n\t  - tmp1 * njac[i][j-1][k][0][1];\n\tlhs[i][j][k][AA][0][2] = - tmp2 * fjac[i][j-1][k][0][2]\n\t  - tmp1 * njac[i][j-1][k][0][2];\n\tlhs[i][j][k][AA][0][3] = - tmp2 * fjac[i][j-1][k][0][3]\n\t  - tmp1 * njac[i][j-1][k][0][3];\n\tlhs[i][j][k][AA][0][4] = - tmp2 * fjac[i][j-1][k][0][4]\n\t  - tmp1 * njac[i][j-1][k][0][4];\n\n\tlhs[i][j][k][AA][1][0] = - tmp2 * fjac[i][j-1][k][1][0]\n\t  - tmp1 * njac[i][j-1][k][1][0];\n\tlhs[i][j][k][AA][1][1] = - tmp2 * fjac[i][j-1][k][1][1]\n\t  - tmp1 * njac[i][j-1][k][1][1]\n\t  - tmp1 * dy2;\n\tlhs[i][j][k][AA][1][2] = - tmp2 * fjac[i][j-1][k][1][2]\n\t  - tmp1 * njac[i][j-1][k][1][2];\n\tlhs[i][j][k][AA][1][3] = - tmp2 * fjac[i][j-1][k][1][3]\n\t  - tmp1 * njac[i][j-1][k][1][3];\n\tlhs[i][j][k][AA][1][4] = - tmp2 * fjac[i][j-1][k][1][4]\n\t  - tmp1 * njac[i][j-1][k][1][4];\n\n\tlhs[i][j][k][AA][2][0] = - tmp2 * fjac[i][j-1][k][2][0]\n\t  - tmp1 * njac[i][j-1][k][2][0];\n\tlhs[i][j][k][AA][2][1] = - tmp2 * fjac[i][j-1][k][2][1]\n\t  - tmp1 * njac[i][j-1][k][2][1];\n\tlhs[i][j][k][AA][2][2] = - tmp2 * fjac[i][j-1][k][2][2]\n\t  - tmp1 * njac[i][j-1][k][2][2]\n\t  - tmp1 * dy3;\n\tlhs[i][j][k][AA][2][3] = - tmp2 * fjac[i][j-1][k][2][3]\n\t  - tmp1 * njac[i][j-1][k][2][3];\n\tlhs[i][j][k][AA][2][4] = - tmp2 * fjac[i][j-1][k][2][4]\n\t  - tmp1 * njac[i][j-1][k][2][4];\n\n\tlhs[i][j][k][AA][3][0] = - tmp2 * fjac[i][j-1][k][3][0]\n\t  - tmp1 * njac[i][j-1][k][3][0];\n\tlhs[i][j][k][AA][3][1] = - tmp2 * fjac[i][j-1][k][3][1]\n\t  - tmp1 * njac[i][j-1][k][3][1];\n\tlhs[i][j][k][AA][3][2] = - tmp2 * fjac[i][j-1][k][3][2]\n\t  - tmp1 * njac[i][j-1][k][3][2];\n\tlhs[i][j][k][AA][3][3] = - tmp2 * fjac[i][j-1][k][3][3]\n\t  - tmp1 * njac[i][j-1][k][3][3]\n\t  - tmp1 * dy4;\n\tlhs[i][j][k][AA][3][4] = - tmp2 * fjac[i][j-1][k][3][4]\n\t  - tmp1 * njac[i][j-1][k][3][4];\n\n\tlhs[i][j][k][AA][4][0] = - tmp2 * fjac[i][j-1][k][4][0]\n\t  - tmp1 * njac[i][j-1][k][4][0];\n\tlhs[i][j][k][AA][4][1] = - tmp2 * fjac[i][j-1][k][4][1]\n\t  - tmp1 * njac[i][j-1][k][4][1];\n\tlhs[i][j][k][AA][4][2] = - tmp2 * fjac[i][j-1][k][4][2]\n\t  - tmp1 * njac[i][j-1][k][4][2];\n\tlhs[i][j][k][AA][4][3] = - tmp2 * fjac[i][j-1][k][4][3]\n\t  - tmp1 * njac[i][j-1][k][4][3];\n\tlhs[i][j][k][AA][4][4] = - tmp2 * fjac[i][j-1][k][4][4]\n\t  - tmp1 * njac[i][j-1][k][4][4]\n\t  - tmp1 * dy5;\n\n\tlhs[i][j][k][BB][0][0] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][0][0]\n\t  + tmp1 * 2.0 * dy1;\n\tlhs[i][j][k][BB][0][1] = tmp1 * 2.0 * njac[i][j][k][0][1];\n\tlhs[i][j][k][BB][0][2] = tmp1 * 2.0 * njac[i][j][k][0][2];\n\tlhs[i][j][k][BB][0][3] = tmp1 * 2.0 * njac[i][j][k][0][3];\n\tlhs[i][j][k][BB][0][4] = tmp1 * 2.0 * njac[i][j][k][0][4];\n\n\tlhs[i][j][k][BB][1][0] = tmp1 * 2.0 * njac[i][j][k][1][0];\n\tlhs[i][j][k][BB][1][1] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][1][1]\n\t  + tmp1 * 2.0 * dy2;\n\tlhs[i][j][k][BB][1][2] = tmp1 * 2.0 * njac[i][j][k][1][2];\n\tlhs[i][j][k][BB][1][3] = tmp1 * 2.0 * njac[i][j][k][1][3];\n\tlhs[i][j][k][BB][1][4] = tmp1 * 2.0 * njac[i][j][k][1][4];\n\n\tlhs[i][j][k][BB][2][0] = tmp1 * 2.0 * njac[i][j][k][2][0];\n\tlhs[i][j][k][BB][2][1] = tmp1 * 2.0 * njac[i][j][k][2][1];\n\tlhs[i][j][k][BB][2][2] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][2][2]\n\t  + tmp1 * 2.0 * dy3;\n\tlhs[i][j][k][BB][2][3] = tmp1 * 2.0 * njac[i][j][k][2][3];\n\tlhs[i][j][k][BB][2][4] = tmp1 * 2.0 * njac[i][j][k][2][4];\n\n\tlhs[i][j][k][BB][3][0] = tmp1 * 2.0 * njac[i][j][k][3][0];\n\tlhs[i][j][k][BB][3][1] = tmp1 * 2.0 * njac[i][j][k][3][1];\n\tlhs[i][j][k][BB][3][2] = tmp1 * 2.0 * njac[i][j][k][3][2];\n\tlhs[i][j][k][BB][3][3] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][3][3]\n\t  + tmp1 * 2.0 * dy4;\n\tlhs[i][j][k][BB][3][4] = tmp1 * 2.0 * njac[i][j][k][3][4];\n\n\tlhs[i][j][k][BB][4][0] = tmp1 * 2.0 * njac[i][j][k][4][0];\n\tlhs[i][j][k][BB][4][1] = tmp1 * 2.0 * njac[i][j][k][4][1];\n\tlhs[i][j][k][BB][4][2] = tmp1 * 2.0 * njac[i][j][k][4][2];\n\tlhs[i][j][k][BB][4][3] = tmp1 * 2.0 * njac[i][j][k][4][3];\n\tlhs[i][j][k][BB][4][4] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][4][4] \n\t  + tmp1 * 2.0 * dy5;\n\n\tlhs[i][j][k][CC][0][0] =  tmp2 * fjac[i][j+1][k][0][0]\n\t  - tmp1 * njac[i][j+1][k][0][0]\n\t  - tmp1 * dy1;\n\tlhs[i][j][k][CC][0][1] =  tmp2 * fjac[i][j+1][k][0][1]\n\t  - tmp1 * njac[i][j+1][k][0][1];\n\tlhs[i][j][k][CC][0][2] =  tmp2 * fjac[i][j+1][k][0][2]\n\t  - tmp1 * njac[i][j+1][k][0][2];\n\tlhs[i][j][k][CC][0][3] =  tmp2 * fjac[i][j+1][k][0][3]\n\t  - tmp1 * njac[i][j+1][k][0][3];\n\tlhs[i][j][k][CC][0][4] =  tmp2 * fjac[i][j+1][k][0][4]\n\t  - tmp1 * njac[i][j+1][k][0][4];\n\n\tlhs[i][j][k][CC][1][0] =  tmp2 * fjac[i][j+1][k][1][0]\n\t  - tmp1 * njac[i][j+1][k][1][0];\n\tlhs[i][j][k][CC][1][1] =  tmp2 * fjac[i][j+1][k][1][1]\n\t  - tmp1 * njac[i][j+1][k][1][1]\n\t  - tmp1 * dy2;\n\tlhs[i][j][k][CC][1][2] =  tmp2 * fjac[i][j+1][k][1][2]\n\t  - tmp1 * njac[i][j+1][k][1][2];\n\tlhs[i][j][k][CC][1][3] =  tmp2 * fjac[i][j+1][k][1][3]\n\t  - tmp1 * njac[i][j+1][k][1][3];\n\tlhs[i][j][k][CC][1][4] =  tmp2 * fjac[i][j+1][k][1][4]\n\t  - tmp1 * njac[i][j+1][k][1][4];\n\n\tlhs[i][j][k][CC][2][0] =  tmp2 * fjac[i][j+1][k][2][0]\n\t  - tmp1 * njac[i][j+1][k][2][0];\n\tlhs[i][j][k][CC][2][1] =  tmp2 * fjac[i][j+1][k][2][1]\n\t  - tmp1 * njac[i][j+1][k][2][1];\n\tlhs[i][j][k][CC][2][2] =  tmp2 * fjac[i][j+1][k][2][2]\n\t  - tmp1 * njac[i][j+1][k][2][2]\n\t  - tmp1 * dy3;\n\tlhs[i][j][k][CC][2][3] =  tmp2 * fjac[i][j+1][k][2][3]\n\t  - tmp1 * njac[i][j+1][k][2][3];\n\tlhs[i][j][k][CC][2][4] =  tmp2 * fjac[i][j+1][k][2][4]\n\t  - tmp1 * njac[i][j+1][k][2][4];\n\n\tlhs[i][j][k][CC][3][0] =  tmp2 * fjac[i][j+1][k][3][0]\n\t  - tmp1 * njac[i][j+1][k][3][0];\n\tlhs[i][j][k][CC][3][1] =  tmp2 * fjac[i][j+1][k][3][1]\n\t  - tmp1 * njac[i][j+1][k][3][1];\n\tlhs[i][j][k][CC][3][2] =  tmp2 * fjac[i][j+1][k][3][2]\n\t  - tmp1 * njac[i][j+1][k][3][2];\n\tlhs[i][j][k][CC][3][3] =  tmp2 * fjac[i][j+1][k][3][3]\n\t  - tmp1 * njac[i][j+1][k][3][3]\n\t  - tmp1 * dy4;\n\tlhs[i][j][k][CC][3][4] =  tmp2 * fjac[i][j+1][k][3][4]\n\t  - tmp1 * njac[i][j+1][k][3][4];\n\n\tlhs[i][j][k][CC][4][0] =  tmp2 * fjac[i][j+1][k][4][0]\n\t  - tmp1 * njac[i][j+1][k][4][0];\n\tlhs[i][j][k][CC][4][1] =  tmp2 * fjac[i][j+1][k][4][1]\n\t  - tmp1 * njac[i][j+1][k][4][1];\n\tlhs[i][j][k][CC][4][2] =  tmp2 * fjac[i][j+1][k][4][2]\n\t  - tmp1 * njac[i][j+1][k][4][2];\n\tlhs[i][j][k][CC][4][3] =  tmp2 * fjac[i][j+1][k][4][3]\n\t  - tmp1 * njac[i][j+1][k][4][3];\n\tlhs[i][j][k][CC][4][4] =  tmp2 * fjac[i][j+1][k][4][4]\n\t  - tmp1 * njac[i][j+1][k][4][4]\n\t  - tmp1 * dy5;\n\n      }\n    }\n  }\n}\n\nstatic void lhsz(void) {\n\n  int i, j, k;\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = 0; k < grid_points[2]; k++) {\n\n\ttmp1 = 1.0 / u[i][j][k][0];\n\ttmp2 = tmp1 * tmp1;\n\ttmp3 = tmp1 * tmp2;\n\n\tfjac[i][j][k][0][0] = 0.0;\n\tfjac[i][j][k][0][1] = 0.0;\n\tfjac[i][j][k][0][2] = 0.0;\n\tfjac[i][j][k][0][3] = 1.0;\n\tfjac[i][j][k][0][4] = 0.0;\n\n\tfjac[i][j][k][1][0] = - ( u[i][j][k][1]*u[i][j][k][3] ) \n\t  * tmp2;\n\tfjac[i][j][k][1][1] = u[i][j][k][3] * tmp1;\n\tfjac[i][j][k][1][2] = 0.0;\n\tfjac[i][j][k][1][3] = u[i][j][k][1] * tmp1;\n\tfjac[i][j][k][1][4] = 0.0;\n\n\tfjac[i][j][k][2][0] = - ( u[i][j][k][2]*u[i][j][k][3] )\n\t  * tmp2;\n\tfjac[i][j][k][2][1] = 0.0;\n\tfjac[i][j][k][2][2] = u[i][j][k][3] * tmp1;\n\tfjac[i][j][k][2][3] = u[i][j][k][2] * tmp1;\n\tfjac[i][j][k][2][4] = 0.0;\n\n\tfjac[i][j][k][3][0] = - (u[i][j][k][3]*u[i][j][k][3] * tmp2 ) \n\t  + 0.50 * c2 * ( (  u[i][j][k][1] * u[i][j][k][1]\n\t\t\t     + u[i][j][k][2] * u[i][j][k][2]\n\t\t\t     + u[i][j][k][3] * u[i][j][k][3] ) * tmp2 );\n\tfjac[i][j][k][3][1] = - c2 *  u[i][j][k][1] * tmp1;\n\tfjac[i][j][k][3][2] = - c2 *  u[i][j][k][2] * tmp1;\n\tfjac[i][j][k][3][3] = ( 2.0 - c2 )\n\t  *  u[i][j][k][3] * tmp1;\n\tfjac[i][j][k][3][4] = c2;\n\n\tfjac[i][j][k][4][0] = ( c2 * (  u[i][j][k][1] * u[i][j][k][1]\n\t\t\t\t\t+ u[i][j][k][2] * u[i][j][k][2]\n\t\t\t\t\t+ u[i][j][k][3] * u[i][j][k][3] )\n\t\t\t\t* tmp2\n\t\t\t\t- c1 * ( u[i][j][k][4] * tmp1 ) )\n\t  * ( u[i][j][k][3] * tmp1 );\n\tfjac[i][j][k][4][1] = - c2 * ( u[i][j][k][1]*u[i][j][k][3] )\n\t  * tmp2;\n\tfjac[i][j][k][4][2] = - c2 * ( u[i][j][k][2]*u[i][j][k][3] )\n\t  * tmp2;\n\tfjac[i][j][k][4][3] = c1 * ( u[i][j][k][4] * tmp1 )\n\t  - 0.50 * c2\n\t  * ( (  u[i][j][k][1]*u[i][j][k][1]\n\t\t + u[i][j][k][2]*u[i][j][k][2]\n\t\t + 3.0*u[i][j][k][3]*u[i][j][k][3] )\n\t      * tmp2 );\n\tfjac[i][j][k][4][4] = c1 * u[i][j][k][3] * tmp1;\n\n\tnjac[i][j][k][0][0] = 0.0;\n\tnjac[i][j][k][0][1] = 0.0;\n\tnjac[i][j][k][0][2] = 0.0;\n\tnjac[i][j][k][0][3] = 0.0;\n\tnjac[i][j][k][0][4] = 0.0;\n\n\tnjac[i][j][k][1][0] = - c3c4 * tmp2 * u[i][j][k][1];\n\tnjac[i][j][k][1][1] =   c3c4 * tmp1;\n\tnjac[i][j][k][1][2] =   0.0;\n\tnjac[i][j][k][1][3] =   0.0;\n\tnjac[i][j][k][1][4] =   0.0;\n\n\tnjac[i][j][k][2][0] = - c3c4 * tmp2 * u[i][j][k][2];\n\tnjac[i][j][k][2][1] =   0.0;\n\tnjac[i][j][k][2][2] =   c3c4 * tmp1;\n\tnjac[i][j][k][2][3] =   0.0;\n\tnjac[i][j][k][2][4] =   0.0;\n\n\tnjac[i][j][k][3][0] = - con43 * c3c4 * tmp2 * u[i][j][k][3];\n\tnjac[i][j][k][3][1] =   0.0;\n\tnjac[i][j][k][3][2] =   0.0;\n\tnjac[i][j][k][3][3] =   con43 * c3 * c4 * tmp1;\n\tnjac[i][j][k][3][4] =   0.0;\n\n\tnjac[i][j][k][4][0] = - (  c3c4\n\t  - c1345 ) * tmp3 * (pow2(u[i][j][k][1]))\n\t  - ( c3c4 - c1345 ) * tmp3 * (pow2(u[i][j][k][2]))\n\t  - ( con43 * c3c4\n\t      - c1345 ) * tmp3 * (pow2(u[i][j][k][3]))\n\t  - c1345 * tmp2 * u[i][j][k][4];\n\n\tnjac[i][j][k][4][1] = (  c3c4 - c1345 ) * tmp2 * u[i][j][k][1];\n\tnjac[i][j][k][4][2] = (  c3c4 - c1345 ) * tmp2 * u[i][j][k][2];\n\tnjac[i][j][k][4][3] = ( con43 * c3c4\n\t\t\t\t- c1345 ) * tmp2 * u[i][j][k][3];\n\tnjac[i][j][k][4][4] = ( c1345 )* tmp1;\n\n      }\n    }\n  }\n\n#pragma omp for\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\n\ttmp1 = dt * tz1;\n\ttmp2 = dt * tz2;\n\n\tlhs[i][j][k][AA][0][0] = - tmp2 * fjac[i][j][k-1][0][0]\n\t  - tmp1 * njac[i][j][k-1][0][0]\n\t  - tmp1 * dz1;\n\tlhs[i][j][k][AA][0][1] = - tmp2 * fjac[i][j][k-1][0][1]\n\t  - tmp1 * njac[i][j][k-1][0][1];\n\tlhs[i][j][k][AA][0][2] = - tmp2 * fjac[i][j][k-1][0][2]\n\t  - tmp1 * njac[i][j][k-1][0][2];\n\tlhs[i][j][k][AA][0][3] = - tmp2 * fjac[i][j][k-1][0][3]\n\t  - tmp1 * njac[i][j][k-1][0][3];\n\tlhs[i][j][k][AA][0][4] = - tmp2 * fjac[i][j][k-1][0][4]\n\t  - tmp1 * njac[i][j][k-1][0][4];\n\n\tlhs[i][j][k][AA][1][0] = - tmp2 * fjac[i][j][k-1][1][0]\n\t  - tmp1 * njac[i][j][k-1][1][0];\n\tlhs[i][j][k][AA][1][1] = - tmp2 * fjac[i][j][k-1][1][1]\n\t  - tmp1 * njac[i][j][k-1][1][1]\n\t  - tmp1 * dz2;\n\tlhs[i][j][k][AA][1][2] = - tmp2 * fjac[i][j][k-1][1][2]\n\t  - tmp1 * njac[i][j][k-1][1][2];\n\tlhs[i][j][k][AA][1][3] = - tmp2 * fjac[i][j][k-1][1][3]\n\t  - tmp1 * njac[i][j][k-1][1][3];\n\tlhs[i][j][k][AA][1][4] = - tmp2 * fjac[i][j][k-1][1][4]\n\t  - tmp1 * njac[i][j][k-1][1][4];\n\n\tlhs[i][j][k][AA][2][0] = - tmp2 * fjac[i][j][k-1][2][0]\n\t  - tmp1 * njac[i][j][k-1][2][0];\n\tlhs[i][j][k][AA][2][1] = - tmp2 * fjac[i][j][k-1][2][1]\n\t  - tmp1 * njac[i][j][k-1][2][1];\n\tlhs[i][j][k][AA][2][2] = - tmp2 * fjac[i][j][k-1][2][2]\n\t  - tmp1 * njac[i][j][k-1][2][2]\n\t  - tmp1 * dz3;\n\tlhs[i][j][k][AA][2][3] = - tmp2 * fjac[i][j][k-1][2][3]\n\t  - tmp1 * njac[i][j][k-1][2][3];\n\tlhs[i][j][k][AA][2][4] = - tmp2 * fjac[i][j][k-1][2][4]\n\t  - tmp1 * njac[i][j][k-1][2][4];\n\n\tlhs[i][j][k][AA][3][0] = - tmp2 * fjac[i][j][k-1][3][0]\n\t  - tmp1 * njac[i][j][k-1][3][0];\n\tlhs[i][j][k][AA][3][1] = - tmp2 * fjac[i][j][k-1][3][1]\n\t  - tmp1 * njac[i][j][k-1][3][1];\n\tlhs[i][j][k][AA][3][2] = - tmp2 * fjac[i][j][k-1][3][2]\n\t  - tmp1 * njac[i][j][k-1][3][2];\n\tlhs[i][j][k][AA][3][3] = - tmp2 * fjac[i][j][k-1][3][3]\n\t  - tmp1 * njac[i][j][k-1][3][3]\n\t  - tmp1 * dz4;\n\tlhs[i][j][k][AA][3][4] = - tmp2 * fjac[i][j][k-1][3][4]\n\t  - tmp1 * njac[i][j][k-1][3][4];\n\n\tlhs[i][j][k][AA][4][0] = - tmp2 * fjac[i][j][k-1][4][0]\n\t  - tmp1 * njac[i][j][k-1][4][0];\n\tlhs[i][j][k][AA][4][1] = - tmp2 * fjac[i][j][k-1][4][1]\n\t  - tmp1 * njac[i][j][k-1][4][1];\n\tlhs[i][j][k][AA][4][2] = - tmp2 * fjac[i][j][k-1][4][2]\n\t  - tmp1 * njac[i][j][k-1][4][2];\n\tlhs[i][j][k][AA][4][3] = - tmp2 * fjac[i][j][k-1][4][3]\n\t  - tmp1 * njac[i][j][k-1][4][3];\n\tlhs[i][j][k][AA][4][4] = - tmp2 * fjac[i][j][k-1][4][4]\n\t  - tmp1 * njac[i][j][k-1][4][4]\n\t  - tmp1 * dz5;\n\n\tlhs[i][j][k][BB][0][0] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][0][0]\n\t  + tmp1 * 2.0 * dz1;\n\tlhs[i][j][k][BB][0][1] = tmp1 * 2.0 * njac[i][j][k][0][1];\n\tlhs[i][j][k][BB][0][2] = tmp1 * 2.0 * njac[i][j][k][0][2];\n\tlhs[i][j][k][BB][0][3] = tmp1 * 2.0 * njac[i][j][k][0][3];\n\tlhs[i][j][k][BB][0][4] = tmp1 * 2.0 * njac[i][j][k][0][4];\n\n\tlhs[i][j][k][BB][1][0] = tmp1 * 2.0 * njac[i][j][k][1][0];\n\tlhs[i][j][k][BB][1][1] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][1][1]\n\t  + tmp1 * 2.0 * dz2;\n\tlhs[i][j][k][BB][1][2] = tmp1 * 2.0 * njac[i][j][k][1][2];\n\tlhs[i][j][k][BB][1][3] = tmp1 * 2.0 * njac[i][j][k][1][3];\n\tlhs[i][j][k][BB][1][4] = tmp1 * 2.0 * njac[i][j][k][1][4];\n\n\tlhs[i][j][k][BB][2][0] = tmp1 * 2.0 * njac[i][j][k][2][0];\n\tlhs[i][j][k][BB][2][1] = tmp1 * 2.0 * njac[i][j][k][2][1];\n\tlhs[i][j][k][BB][2][2] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][2][2]\n\t  + tmp1 * 2.0 * dz3;\n\tlhs[i][j][k][BB][2][3] = tmp1 * 2.0 * njac[i][j][k][2][3];\n\tlhs[i][j][k][BB][2][4] = tmp1 * 2.0 * njac[i][j][k][2][4];\n\n\tlhs[i][j][k][BB][3][0] = tmp1 * 2.0 * njac[i][j][k][3][0];\n\tlhs[i][j][k][BB][3][1] = tmp1 * 2.0 * njac[i][j][k][3][1];\n\tlhs[i][j][k][BB][3][2] = tmp1 * 2.0 * njac[i][j][k][3][2];\n\tlhs[i][j][k][BB][3][3] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][3][3]\n\t  + tmp1 * 2.0 * dz4;\n\tlhs[i][j][k][BB][3][4] = tmp1 * 2.0 * njac[i][j][k][3][4];\n\n\tlhs[i][j][k][BB][4][0] = tmp1 * 2.0 * njac[i][j][k][4][0];\n\tlhs[i][j][k][BB][4][1] = tmp1 * 2.0 * njac[i][j][k][4][1];\n\tlhs[i][j][k][BB][4][2] = tmp1 * 2.0 * njac[i][j][k][4][2];\n\tlhs[i][j][k][BB][4][3] = tmp1 * 2.0 * njac[i][j][k][4][3];\n\tlhs[i][j][k][BB][4][4] = 1.0\n\t  + tmp1 * 2.0 * njac[i][j][k][4][4]\n\t  + tmp1 * 2.0 * dz5;\n\n\tlhs[i][j][k][CC][0][0] =  tmp2 * fjac[i][j][k+1][0][0]\n\t  - tmp1 * njac[i][j][k+1][0][0]\n\t  - tmp1 * dz1;\n\tlhs[i][j][k][CC][0][1] =  tmp2 * fjac[i][j][k+1][0][1]\n\t  - tmp1 * njac[i][j][k+1][0][1];\n\tlhs[i][j][k][CC][0][2] =  tmp2 * fjac[i][j][k+1][0][2]\n\t  - tmp1 * njac[i][j][k+1][0][2];\n\tlhs[i][j][k][CC][0][3] =  tmp2 * fjac[i][j][k+1][0][3]\n\t  - tmp1 * njac[i][j][k+1][0][3];\n\tlhs[i][j][k][CC][0][4] =  tmp2 * fjac[i][j][k+1][0][4]\n\t  - tmp1 * njac[i][j][k+1][0][4];\n\n\tlhs[i][j][k][CC][1][0] =  tmp2 * fjac[i][j][k+1][1][0]\n\t  - tmp1 * njac[i][j][k+1][1][0];\n\tlhs[i][j][k][CC][1][1] =  tmp2 * fjac[i][j][k+1][1][1]\n\t  - tmp1 * njac[i][j][k+1][1][1]\n\t  - tmp1 * dz2;\n\tlhs[i][j][k][CC][1][2] =  tmp2 * fjac[i][j][k+1][1][2]\n\t  - tmp1 * njac[i][j][k+1][1][2];\n\tlhs[i][j][k][CC][1][3] =  tmp2 * fjac[i][j][k+1][1][3]\n\t  - tmp1 * njac[i][j][k+1][1][3];\n\tlhs[i][j][k][CC][1][4] =  tmp2 * fjac[i][j][k+1][1][4]\n\t  - tmp1 * njac[i][j][k+1][1][4];\n\n\tlhs[i][j][k][CC][2][0] =  tmp2 * fjac[i][j][k+1][2][0]\n\t  - tmp1 * njac[i][j][k+1][2][0];\n\tlhs[i][j][k][CC][2][1] =  tmp2 * fjac[i][j][k+1][2][1]\n\t  - tmp1 * njac[i][j][k+1][2][1];\n\tlhs[i][j][k][CC][2][2] =  tmp2 * fjac[i][j][k+1][2][2]\n\t  - tmp1 * njac[i][j][k+1][2][2]\n\t  - tmp1 * dz3;\n\tlhs[i][j][k][CC][2][3] =  tmp2 * fjac[i][j][k+1][2][3]\n\t  - tmp1 * njac[i][j][k+1][2][3];\n\tlhs[i][j][k][CC][2][4] =  tmp2 * fjac[i][j][k+1][2][4]\n\t  - tmp1 * njac[i][j][k+1][2][4];\n\n\tlhs[i][j][k][CC][3][0] =  tmp2 * fjac[i][j][k+1][3][0]\n\t  - tmp1 * njac[i][j][k+1][3][0];\n\tlhs[i][j][k][CC][3][1] =  tmp2 * fjac[i][j][k+1][3][1]\n\t  - tmp1 * njac[i][j][k+1][3][1];\n\tlhs[i][j][k][CC][3][2] =  tmp2 * fjac[i][j][k+1][3][2]\n\t  - tmp1 * njac[i][j][k+1][3][2];\n\tlhs[i][j][k][CC][3][3] =  tmp2 * fjac[i][j][k+1][3][3]\n\t  - tmp1 * njac[i][j][k+1][3][3]\n\t  - tmp1 * dz4;\n\tlhs[i][j][k][CC][3][4] =  tmp2 * fjac[i][j][k+1][3][4]\n\t  - tmp1 * njac[i][j][k+1][3][4];\n\n\tlhs[i][j][k][CC][4][0] =  tmp2 * fjac[i][j][k+1][4][0]\n\t  - tmp1 * njac[i][j][k+1][4][0];\n\tlhs[i][j][k][CC][4][1] =  tmp2 * fjac[i][j][k+1][4][1]\n\t  - tmp1 * njac[i][j][k+1][4][1];\n\tlhs[i][j][k][CC][4][2] =  tmp2 * fjac[i][j][k+1][4][2]\n\t  - tmp1 * njac[i][j][k+1][4][2];\n\tlhs[i][j][k][CC][4][3] =  tmp2 * fjac[i][j][k+1][4][3]\n\t  - tmp1 * njac[i][j][k+1][4][3];\n\tlhs[i][j][k][CC][4][4] =  tmp2 * fjac[i][j][k+1][4][4]\n\t  - tmp1 * njac[i][j][k+1][4][4]\n\t  - tmp1 * dz5;\n\n      }\n    }\n  }\n}\n\nstatic void compute_rhs(void) {\n\n  int i, j, k, m;\n  double rho_inv, uijk, up1, um1, vijk, vp1, vm1, wijk, wp1, wm1;\n\n#pragma omp for nowait\n  for (i = 0; i < grid_points[0]; i++) {\n    for (j = 0; j < grid_points[1]; j++) {\n      for (k = 0; k < grid_points[2]; k++) {\n\trho_inv = 1.0/u[i][j][k][0];\n\trho_i[i][j][k] = rho_inv;\n\tus[i][j][k] = u[i][j][k][1] * rho_inv;\n\tvs[i][j][k] = u[i][j][k][2] * rho_inv;\n\tws[i][j][k] = u[i][j][k][3] * rho_inv;\n\tsquare[i][j][k] = 0.5 * (u[i][j][k][1]*u[i][j][k][1] + \n\t\t\t\t u[i][j][k][2]*u[i][j][k][2] +\n\t\t\t\t u[i][j][k][3]*u[i][j][k][3] ) * rho_inv;\n\tqs[i][j][k] = square[i][j][k] * rho_inv;\n      }\n    }\n  }\n\n#pragma omp for\n  for (i = 0; i < grid_points[0]; i++) {\n    for (j = 0; j < grid_points[1]; j++) {\n      for (k = 0; k < grid_points[2]; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  rhs[i][j][k][m] = forcing[i][j][k][m];\n\t}\n      }\n    }\n  }\n\n#pragma omp for\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\tuijk = us[i][j][k];\n\tup1  = us[i+1][j][k];\n\tum1  = us[i-1][j][k];\n\n\trhs[i][j][k][0] = rhs[i][j][k][0] + dx1tx1 * \n\t  (u[i+1][j][k][0] - 2.0*u[i][j][k][0] + \n\t   u[i-1][j][k][0]) -\n\t  tx2 * (u[i+1][j][k][1] - u[i-1][j][k][1]);\n\n\trhs[i][j][k][1] = rhs[i][j][k][1] + dx2tx1 * \n\t  (u[i+1][j][k][1] - 2.0*u[i][j][k][1] + \n\t   u[i-1][j][k][1]) +\n\t  xxcon2*con43 * (up1 - 2.0*uijk + um1) -\n\t  tx2 * (u[i+1][j][k][1]*up1 - \n\t\t u[i-1][j][k][1]*um1 +\n\t\t (u[i+1][j][k][4]- square[i+1][j][k]-\n\t\t  u[i-1][j][k][4]+ square[i-1][j][k])*\n\t\t c2);\n\n\trhs[i][j][k][2] = rhs[i][j][k][2] + dx3tx1 * \n\t  (u[i+1][j][k][2] - 2.0*u[i][j][k][2] +\n\t   u[i-1][j][k][2]) +\n\t  xxcon2 * (vs[i+1][j][k] - 2.0*vs[i][j][k] +\n\t\t    vs[i-1][j][k]) -\n\t  tx2 * (u[i+1][j][k][2]*up1 - \n\t\t u[i-1][j][k][2]*um1);\n\n\trhs[i][j][k][3] = rhs[i][j][k][3] + dx4tx1 * \n\t  (u[i+1][j][k][3] - 2.0*u[i][j][k][3] +\n\t   u[i-1][j][k][3]) +\n\t  xxcon2 * (ws[i+1][j][k] - 2.0*ws[i][j][k] +\n\t\t    ws[i-1][j][k]) -\n\t  tx2 * (u[i+1][j][k][3]*up1 - \n\t\t u[i-1][j][k][3]*um1);\n\n\trhs[i][j][k][4] = rhs[i][j][k][4] + dx5tx1 * \n\t  (u[i+1][j][k][4] - 2.0*u[i][j][k][4] +\n\t   u[i-1][j][k][4]) +\n\t  xxcon3 * (qs[i+1][j][k] - 2.0*qs[i][j][k] +\n\t\t    qs[i-1][j][k]) +\n\t  xxcon4 * (up1*up1 -       2.0*uijk*uijk + \n\t\t    um1*um1) +\n\t  xxcon5 * (u[i+1][j][k][4]*rho_i[i+1][j][k] - \n\t\t    2.0*u[i][j][k][4]*rho_i[i][j][k] +\n\t\t    u[i-1][j][k][4]*rho_i[i-1][j][k]) -\n\t  tx2 * ( (c1*u[i+1][j][k][4] - \n\t\t   c2*square[i+1][j][k])*up1 -\n\t\t  (c1*u[i-1][j][k][4] - \n\t\t   c2*square[i-1][j][k])*um1 );\n      }\n    }\n  }\n\n  i = 1;\n#pragma omp for nowait\n  for (j = 1; j < grid_points[1]-1; j++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      for (m = 0; m < 5; m++) {\n\trhs[i][j][k][m] = rhs[i][j][k][m]- dssp * \n\t  ( 5.0*u[i][j][k][m] - 4.0*u[i+1][j][k][m] +\n\t    u[i+2][j][k][m]);\n      }\n    }\n  }\n\n  i = 2;\n#pragma omp for nowait\n  for (j = 1; j < grid_points[1]-1; j++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      for (m = 0; m < 5; m++) {\n\trhs[i][j][k][m] = rhs[i][j][k][m] - dssp * \n\t  (-4.0*u[i-1][j][k][m] + 6.0*u[i][j][k][m] -\n\t   4.0*u[i+1][j][k][m] + u[i+2][j][k][m]);\n      }\n    }\n  }\n\n#pragma omp for nowait\n  for (i = 3; i < grid_points[0]-3; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  rhs[i][j][k][m] = rhs[i][j][k][m] - dssp * \n\t    (  u[i-2][j][k][m] - 4.0*u[i-1][j][k][m] + \n\t       6.0*u[i][j][k][m] - 4.0*u[i+1][j][k][m] + \n\t       u[i+2][j][k][m] );\n\t}\n      }\n    }\n  }\n         \n  i = grid_points[0]-3;\n#pragma omp for nowait\n  for (j = 1; j < grid_points[1]-1; j++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      for (m = 0; m < 5; m++) {\n\trhs[i][j][k][m] = rhs[i][j][k][m] - dssp *\n\t  ( u[i-2][j][k][m] - 4.0*u[i-1][j][k][m] + \n\t    6.0*u[i][j][k][m] - 4.0*u[i+1][j][k][m] );\n      }\n    }\n  }\n\n  i = grid_points[0]-2;\n#pragma omp for\n  for (j = 1; j < grid_points[1]-1; j++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      for (m = 0; m < 5; m++) {\n\trhs[i][j][k][m] = rhs[i][j][k][m] - dssp *\n\t  ( u[i-2][j][k][m] - 4.*u[i-1][j][k][m] +\n\t    5.0*u[i][j][k][m] );\n      }\n    }\n  }\n\n#pragma omp for\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\tvijk = vs[i][j][k];\n\tvp1  = vs[i][j+1][k];\n\tvm1  = vs[i][j-1][k];\n\trhs[i][j][k][0] = rhs[i][j][k][0] + dy1ty1 * \n\t  (u[i][j+1][k][0] - 2.0*u[i][j][k][0] + \n\t   u[i][j-1][k][0]) -\n\t  ty2 * (u[i][j+1][k][2] - u[i][j-1][k][2]);\n\trhs[i][j][k][1] = rhs[i][j][k][1] + dy2ty1 * \n\t  (u[i][j+1][k][1] - 2.0*u[i][j][k][1] + \n\t   u[i][j-1][k][1]) +\n\t  yycon2 * (us[i][j+1][k] - 2.0*us[i][j][k] + \n\t\t    us[i][j-1][k]) -\n\t  ty2 * (u[i][j+1][k][1]*vp1 - \n\t\t u[i][j-1][k][1]*vm1);\n\trhs[i][j][k][2] = rhs[i][j][k][2] + dy3ty1 * \n\t  (u[i][j+1][k][2] - 2.0*u[i][j][k][2] + \n\t   u[i][j-1][k][2]) +\n\t  yycon2*con43 * (vp1 - 2.0*vijk + vm1) -\n\t  ty2 * (u[i][j+1][k][2]*vp1 - \n\t\t u[i][j-1][k][2]*vm1 +\n\t\t (u[i][j+1][k][4] - square[i][j+1][k] - \n\t\t  u[i][j-1][k][4] + square[i][j-1][k])\n\t\t *c2);\n\trhs[i][j][k][3] = rhs[i][j][k][3] + dy4ty1 * \n\t  (u[i][j+1][k][3] - 2.0*u[i][j][k][3] + \n\t   u[i][j-1][k][3]) +\n\t  yycon2 * (ws[i][j+1][k] - 2.0*ws[i][j][k] + \n\t\t    ws[i][j-1][k]) -\n\t  ty2 * (u[i][j+1][k][3]*vp1 - \n\t\t u[i][j-1][k][3]*vm1);\n\trhs[i][j][k][4] = rhs[i][j][k][4] + dy5ty1 * \n\t  (u[i][j+1][k][4] - 2.0*u[i][j][k][4] + \n\t   u[i][j-1][k][4]) +\n\t  yycon3 * (qs[i][j+1][k] - 2.0*qs[i][j][k] + \n\t\t    qs[i][j-1][k]) +\n\t  yycon4 * (vp1*vp1       - 2.0*vijk*vijk + \n\t\t    vm1*vm1) +\n\t  yycon5 * (u[i][j+1][k][4]*rho_i[i][j+1][k] - \n\t\t    2.0*u[i][j][k][4]*rho_i[i][j][k] +\n\t\t    u[i][j-1][k][4]*rho_i[i][j-1][k]) -\n\t  ty2 * ((c1*u[i][j+1][k][4] - \n\t\t  c2*square[i][j+1][k]) * vp1 -\n\t\t (c1*u[i][j-1][k][4] - \n\t\t  c2*square[i][j-1][k]) * vm1);\n      }\n    }\n  }\n\n  j = 1;\n#pragma omp for nowait\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      for (m = 0; m < 5; m++) {\n\trhs[i][j][k][m] = rhs[i][j][k][m]- dssp * \n\t  ( 5.0*u[i][j][k][m] - 4.0*u[i][j+1][k][m] +\n\t    u[i][j+2][k][m]);\n      }\n    }\n  }\n\n  j = 2;\n#pragma omp for nowait\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      for (m = 0; m < 5; m++) {\n\trhs[i][j][k][m] = rhs[i][j][k][m] - dssp * \n\t  (-4.0*u[i][j-1][k][m] + 6.0*u[i][j][k][m] -\n\t   4.0*u[i][j+1][k][m] + u[i][j+2][k][m]);\n      }\n    }\n  }\n\n#pragma omp for nowait\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 3; j < grid_points[1]-3; j++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  rhs[i][j][k][m] = rhs[i][j][k][m] - dssp * \n\t    (  u[i][j-2][k][m] - 4.0*u[i][j-1][k][m] + \n\t       6.0*u[i][j][k][m] - 4.0*u[i][j+1][k][m] + \n\t       u[i][j+2][k][m] );\n\t}\n      }\n    }\n  }\n         \n  j = grid_points[1]-3;\n#pragma omp for nowait\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      for (m = 0; m < 5; m++) {\n\trhs[i][j][k][m] = rhs[i][j][k][m] - dssp *\n\t  ( u[i][j-2][k][m] - 4.0*u[i][j-1][k][m] + \n\t    6.0*u[i][j][k][m] - 4.0*u[i][j+1][k][m] );\n      }\n    }\n  }\n\n  j = grid_points[1]-2;\n#pragma omp for\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      for (m = 0; m < 5; m++) {\n\trhs[i][j][k][m] = rhs[i][j][k][m] - dssp *\n\t  ( u[i][j-2][k][m] - 4.*u[i][j-1][k][m] +\n\t    5.*u[i][j][k][m] );\n      }\n    }\n  }\n\n#pragma omp for\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\twijk = ws[i][j][k];\n\twp1  = ws[i][j][k+1];\n\twm1  = ws[i][j][k-1];\n\n\trhs[i][j][k][0] = rhs[i][j][k][0] + dz1tz1 * \n\t  (u[i][j][k+1][0] - 2.0*u[i][j][k][0] + \n\t   u[i][j][k-1][0]) -\n\t  tz2 * (u[i][j][k+1][3] - u[i][j][k-1][3]);\n\trhs[i][j][k][1] = rhs[i][j][k][1] + dz2tz1 * \n\t  (u[i][j][k+1][1] - 2.0*u[i][j][k][1] + \n\t   u[i][j][k-1][1]) +\n\t  zzcon2 * (us[i][j][k+1] - 2.0*us[i][j][k] + \n\t\t    us[i][j][k-1]) -\n\t  tz2 * (u[i][j][k+1][1]*wp1 - \n\t\t u[i][j][k-1][1]*wm1);\n\trhs[i][j][k][2] = rhs[i][j][k][2] + dz3tz1 * \n\t  (u[i][j][k+1][2] - 2.0*u[i][j][k][2] + \n\t   u[i][j][k-1][2]) +\n\t  zzcon2 * (vs[i][j][k+1] - 2.0*vs[i][j][k] + \n\t\t    vs[i][j][k-1]) -\n\t  tz2 * (u[i][j][k+1][2]*wp1 - \n\t\t u[i][j][k-1][2]*wm1);\n\trhs[i][j][k][3] = rhs[i][j][k][3] + dz4tz1 * \n\t  (u[i][j][k+1][3] - 2.0*u[i][j][k][3] + \n\t   u[i][j][k-1][3]) +\n\t  zzcon2*con43 * (wp1 - 2.0*wijk + wm1) -\n\t  tz2 * (u[i][j][k+1][3]*wp1 - \n\t\t u[i][j][k-1][3]*wm1 +\n\t\t (u[i][j][k+1][4] - square[i][j][k+1] - \n\t\t  u[i][j][k-1][4] + square[i][j][k-1])\n\t\t *c2);\n\trhs[i][j][k][4] = rhs[i][j][k][4] + dz5tz1 * \n\t  (u[i][j][k+1][4] - 2.0*u[i][j][k][4] + \n\t   u[i][j][k-1][4]) +\n\t  zzcon3 * (qs[i][j][k+1] - 2.0*qs[i][j][k] + \n\t\t    qs[i][j][k-1]) +\n\t  zzcon4 * (wp1*wp1 - 2.0*wijk*wijk + \n\t\t    wm1*wm1) +\n\t  zzcon5 * (u[i][j][k+1][4]*rho_i[i][j][k+1] - \n\t\t    2.0*u[i][j][k][4]*rho_i[i][j][k] +\n\t\t    u[i][j][k-1][4]*rho_i[i][j][k-1]) -\n\t  tz2 * ( (c1*u[i][j][k+1][4] - \n\t\t   c2*square[i][j][k+1])*wp1 -\n\t\t  (c1*u[i][j][k-1][4] - \n\t\t   c2*square[i][j][k-1])*wm1);\n      }\n    }\n  }\n\n  k = 1;\n#pragma omp for nowait\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (m = 0; m < 5; m++) {\n\trhs[i][j][k][m] = rhs[i][j][k][m]- dssp * \n\t  ( 5.0*u[i][j][k][m] - 4.0*u[i][j][k+1][m] +\n\t    u[i][j][k+2][m]);\n      }\n    }\n  }\n\n  k = 2;\n#pragma omp for nowait\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (m = 0; m < 5; m++) {\n\trhs[i][j][k][m] = rhs[i][j][k][m] - dssp * \n\t  (-4.0*u[i][j][k-1][m] + 6.0*u[i][j][k][m] -\n\t   4.0*u[i][j][k+1][m] + u[i][j][k+2][m]);\n      }\n    }\n  }\n\n#pragma omp for nowait\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = 3; k < grid_points[2]-3; k++) {\n\tfor (m = 0; m < 5; m++) {\n\t  rhs[i][j][k][m] = rhs[i][j][k][m] - dssp * \n\t    (  u[i][j][k-2][m] - 4.0*u[i][j][k-1][m] + \n\t       6.0*u[i][j][k][m] - 4.0*u[i][j][k+1][m] + \n\t       u[i][j][k+2][m] );\n\t}\n      }\n    }\n  }\n         \n  k = grid_points[2]-3;\n#pragma omp for nowait\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (m = 0; m < 5; m++) {\n\trhs[i][j][k][m] = rhs[i][j][k][m] - dssp *\n\t  ( u[i][j][k-2][m] - 4.0*u[i][j][k-1][m] + \n\t    6.0*u[i][j][k][m] - 4.0*u[i][j][k+1][m] );\n      }\n    }\n  }\n\n  k = grid_points[2]-2;\n#pragma omp for\n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (m = 0; m < 5; m++) {\n\trhs[i][j][k][m] = rhs[i][j][k][m] - dssp *\n\t  ( u[i][j][k-2][m] - 4.0*u[i][j][k-1][m] +\n\t    5.0*u[i][j][k][m] );\n      }\n    }\n  }\n\n#pragma omp for\n  for (j = 1; j < grid_points[1]-1; j++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      for (m = 0; m < 5; m++) {\n\tfor (i = 1; i < grid_points[0]-1; i++) {\n\t  rhs[i][j][k][m] = rhs[i][j][k][m] * dt;\n\t}\n      }\n    }\n  }\n}\n\nstatic void set_constants(void) {\n\n  ce[0][0]  = 2.0;\n  ce[0][1]  = 0.0;\n  ce[0][2]  = 0.0;\n  ce[0][3]  = 4.0;\n  ce[0][4]  = 5.0;\n  ce[0][5]  = 3.0;\n  ce[0][6]  = 0.5;\n  ce[0][7]  = 0.02;\n  ce[0][8]  = 0.01;\n  ce[0][9]  = 0.03;\n  ce[0][10] = 0.5;\n  ce[0][11] = 0.4;\n  ce[0][12] = 0.3;\n      \n  ce[1][0]  = 1.0;\n  ce[1][1]  = 0.0;\n  ce[1][2]  = 0.0;\n  ce[1][3]  = 0.0;\n  ce[1][4]  = 1.0;\n  ce[1][5]  = 2.0;\n  ce[1][6]  = 3.0;\n  ce[1][7]  = 0.01;\n  ce[1][8]  = 0.03;\n  ce[1][9]  = 0.02;\n  ce[1][10] = 0.4;\n  ce[1][11] = 0.3;\n  ce[1][12] = 0.5;\n\n  ce[2][0]  = 2.0;\n  ce[2][1]  = 2.0;\n  ce[2][2]  = 0.0;\n  ce[2][3]  = 0.0;\n  ce[2][4]  = 0.0;\n  ce[2][5]  = 2.0;\n  ce[2][6]  = 3.0;\n  ce[2][7]  = 0.04;\n  ce[2][8]  = 0.03;\n  ce[2][9]  = 0.05;\n  ce[2][10] = 0.3;\n  ce[2][11] = 0.5;\n  ce[2][12] = 0.4;\n\n  ce[3][0]  = 2.0;\n  ce[3][1]  = 2.0;\n  ce[3][2]  = 0.0;\n  ce[3][3]  = 0.0;\n  ce[3][4]  = 0.0;\n  ce[3][5]  = 2.0;\n  ce[3][6]  = 3.0;\n  ce[3][7]  = 0.03;\n  ce[3][8]  = 0.05;\n  ce[3][9]  = 0.04;\n  ce[3][10] = 0.2;\n  ce[3][11] = 0.1;\n  ce[3][12] = 0.3;\n\n  ce[4][0]  = 5.0;\n  ce[4][1]  = 4.0;\n  ce[4][2]  = 3.0;\n  ce[4][3]  = 2.0;\n  ce[4][4]  = 0.1;\n  ce[4][5]  = 0.4;\n  ce[4][6]  = 0.3;\n  ce[4][7]  = 0.05;\n  ce[4][8]  = 0.04;\n  ce[4][9]  = 0.03;\n  ce[4][10] = 0.1;\n  ce[4][11] = 0.3;\n  ce[4][12] = 0.2;\n\n  c1 = 1.4;\n  c2 = 0.4;\n  c3 = 0.1;\n  c4 = 1.0;\n  c5 = 1.4;\n\n  dnxm1 = 1.0 / (double)(grid_points[0]-1);\n  dnym1 = 1.0 / (double)(grid_points[1]-1);\n  dnzm1 = 1.0 / (double)(grid_points[2]-1);\n\n  c1c2 = c1 * c2;\n  c1c5 = c1 * c5;\n  c3c4 = c3 * c4;\n  c1345 = c1c5 * c3c4;\n\n  conz1 = (1.0-c1c5);\n\n  tx1 = 1.0 / (dnxm1 * dnxm1);\n  tx2 = 1.0 / (2.0 * dnxm1);\n  tx3 = 1.0 / dnxm1;\n\n  ty1 = 1.0 / (dnym1 * dnym1);\n  ty2 = 1.0 / (2.0 * dnym1);\n  ty3 = 1.0 / dnym1;\n      \n  tz1 = 1.0 / (dnzm1 * dnzm1);\n  tz2 = 1.0 / (2.0 * dnzm1);\n  tz3 = 1.0 / dnzm1;\n\n  dx1 = 0.75;\n  dx2 = 0.75;\n  dx3 = 0.75;\n  dx4 = 0.75;\n  dx5 = 0.75;\n\n  dy1 = 0.75;\n  dy2 = 0.75;\n  dy3 = 0.75;\n  dy4 = 0.75;\n  dy5 = 0.75;\n\n  dz1 = 1.0;\n  dz2 = 1.0;\n  dz3 = 1.0;\n  dz4 = 1.0;\n  dz5 = 1.0;\n\n  dxmax = max(dx3, dx4);\n  dymax = max(dy2, dy4);\n  dzmax = max(dz2, dz3);\n\n  dssp = 0.25 * max(dx1, max(dy1, dz1) );\n\n  c4dssp = 4.0 * dssp;\n  c5dssp = 5.0 * dssp;\n\n  dttx1 = dt*tx1;\n  dttx2 = dt*tx2;\n  dtty1 = dt*ty1;\n  dtty2 = dt*ty2;\n  dttz1 = dt*tz1;\n  dttz2 = dt*tz2;\n\n  c2dttx1 = 2.0*dttx1;\n  c2dtty1 = 2.0*dtty1;\n  c2dttz1 = 2.0*dttz1;\n\n  dtdssp = dt*dssp;\n\n  comz1  = dtdssp;\n  comz4  = 4.0*dtdssp;\n  comz5  = 5.0*dtdssp;\n  comz6  = 6.0*dtdssp;\n\n  c3c4tx3 = c3c4*tx3;\n  c3c4ty3 = c3c4*ty3;\n  c3c4tz3 = c3c4*tz3;\n\n  dx1tx1 = dx1*tx1;\n  dx2tx1 = dx2*tx1;\n  dx3tx1 = dx3*tx1;\n  dx4tx1 = dx4*tx1;\n  dx5tx1 = dx5*tx1;\n      \n  dy1ty1 = dy1*ty1;\n  dy2ty1 = dy2*ty1;\n  dy3ty1 = dy3*ty1;\n  dy4ty1 = dy4*ty1;\n  dy5ty1 = dy5*ty1;\n  \n  dz1tz1 = dz1*tz1;\n  dz2tz1 = dz2*tz1;\n  dz3tz1 = dz3*tz1;\n  dz4tz1 = dz4*tz1;\n  dz5tz1 = dz5*tz1;\n\n  c2iv  = 2.5;\n  con43 = 4.0/3.0;\n  con16 = 1.0/6.0;\n      \n  xxcon1 = c3c4tx3*con43*tx3;\n  xxcon2 = c3c4tx3*tx3;\n  xxcon3 = c3c4tx3*conz1*tx3;\n  xxcon4 = c3c4tx3*con16*tx3;\n  xxcon5 = c3c4tx3*c1c5*tx3;\n\n  yycon1 = c3c4ty3*con43*ty3;\n  yycon2 = c3c4ty3*ty3;\n  yycon3 = c3c4ty3*conz1*ty3;\n  yycon4 = c3c4ty3*con16*ty3;\n  yycon5 = c3c4ty3*c1c5*ty3;\n\n  zzcon1 = c3c4tz3*con43*tz3;\n  zzcon2 = c3c4tz3*tz3;\n  zzcon3 = c3c4tz3*conz1*tz3;\n  zzcon4 = c3c4tz3*con16*tz3;\n  zzcon5 = c3c4tz3*c1c5*tz3;\n}\n\n\nstatic void verify(int no_time_steps, char *class, boolean *verified) {\n\n  double xcrref[5],xceref[5],xcrdif[5],xcedif[5], \n    epsilon, xce[5], xcr[5], dtref;\n  int m;\n\n  epsilon = 1.0e-08;\n  error_norm(xce);\n  compute_rhs();\n\n  rhs_norm(xcr);\n\n  for (m = 0; m < 5; m++) {\n    xcr[m] = xcr[m] / dt;\n  }\n\n  *class = 'U';\n  *verified = TRUE;\n\n  for (m = 0; m < 5; m++) {\n    xcrref[m] = 1.0;\n    xceref[m] = 1.0;\n  }\n\n  if (grid_points[0] == 12 &&\n      grid_points[1] == 12 &&\n      grid_points[2] == 12 &&\n      no_time_steps == 60) {\n\n    *class = 'S';\n    dtref = 1.0e-2;\n\n    xcrref[0] = 1.7034283709541311e-01;\n    xcrref[1] = 1.2975252070034097e-02;\n    xcrref[2] = 3.2527926989486055e-02;\n    xcrref[3] = 2.6436421275166801e-02;\n    xcrref[4] = 1.9211784131744430e-01;\n    xceref[0] = 4.9976913345811579e-04;\n    xceref[1] = 4.5195666782961927e-05;\n    xceref[2] = 7.3973765172921357e-05;\n    xceref[3] = 7.3821238632439731e-05;\n    xceref[4] = 8.9269630987491446e-04;\n\n    } else if (grid_points[0] == 24 &&\n\t       grid_points[1] == 24 &&\n\t       grid_points[2] == 24 &&\n\t       no_time_steps == 200) {\n\n      *class = 'W';\n      dtref = 0.8e-3;\n      xcrref[0] = 0.1125590409344e+03;\n      xcrref[1] = 0.1180007595731e+02;\n      xcrref[2] = 0.2710329767846e+02;\n      xcrref[3] = 0.2469174937669e+02;\n      xcrref[4] = 0.2638427874317e+03;\n      xceref[0] = 0.4419655736008e+01;\n      xceref[1] = 0.4638531260002e+00;\n      xceref[2] = 0.1011551749967e+01;\n      xceref[3] = 0.9235878729944e+00;\n      xceref[4] = 0.1018045837718e+02;\n\n    } else if (grid_points[0] == 64 &&\n\t       grid_points[1] == 64 &&\n\t       grid_points[2] == 64 &&\n\t       no_time_steps == 200) {\n\n      *class = 'A';\n      dtref = 0.8e-3;\n      xcrref[0] = 1.0806346714637264e+02;\n      xcrref[1] = 1.1319730901220813e+01;\n      xcrref[2] = 2.5974354511582465e+01;\n      xcrref[3] = 2.3665622544678910e+01;\n      xcrref[4] = 2.5278963211748344e+02;\n      xceref[0] = 4.2348416040525025e+00;\n      xceref[1] = 4.4390282496995698e-01;\n      xceref[2] = 9.6692480136345650e-01;\n      xceref[3] = 8.8302063039765474e-01;\n      xceref[4] = 9.7379901770829278e+00;\n    } else if (grid_points[0] == 102 &&\n\t       grid_points[1] == 102 &&\n\t       grid_points[2] == 102 &&\n\t       no_time_steps == 200) {\n\n      *class = 'B';\n      dtref = 3.0e-4;\n      xcrref[0] = 1.4233597229287254e+03;\n      xcrref[1] = 9.9330522590150238e+01;\n      xcrref[2] = 3.5646025644535285e+02;\n      xcrref[3] = 3.2485447959084092e+02;\n      xcrref[4] = 3.2707541254659363e+03;\n      xceref[0] = 5.2969847140936856e+01;\n      xceref[1] = 4.4632896115670668e+00;\n      xceref[2] = 1.3122573342210174e+01;\n      xceref[3] = 1.2006925323559144e+01;\n      xceref[4] = 1.2459576151035986e+02;\n    } else if (grid_points[0] == 162 &&\n\t       grid_points[1] == 162 &&\n\t       grid_points[2] == 162 &&\n\t       no_time_steps == 200) {\n\n      *class = 'C';\n      dtref = 1.0e-4;\n      xcrref[0] = 0.62398116551764615e+04;\n      xcrref[1] = 0.50793239190423964e+03;\n      xcrref[2] = 0.15423530093013596e+04;\n      xcrref[3] = 0.13302387929291190e+04;\n      xcrref[4] = 0.11604087428436455e+05;\n      xceref[0] = 0.16462008369091265e+03;\n      xceref[1] = 0.11497107903824313e+02;\n      xceref[2] = 0.41207446207461508e+02;\n      xceref[3] = 0.37087651059694167e+02;\n      xceref[4] = 0.36211053051841265e+03;\n\n    } else {\n      *verified = FALSE;\n    }\n  for (m = 0; m < 5; m++) {\n           \n    xcrdif[m] = fabs((xcr[m]-xcrref[m])/xcrref[m]);\n    xcedif[m] = fabs((xce[m]-xceref[m])/xceref[m]);\n           \n  }\n\n  if (*class != 'U') {\n    printf(\" Verification being performed for class %1c\\n\", *class);\n    printf(\" accuracy setting for epsilon = %20.13e\\n\", epsilon);\n    if (fabs(dt-dtref) > epsilon) {\n      *verified = FALSE;\n      *class = 'U';\n      printf(\" DT does not match the reference value of %15.8e\\n\", dtref);\n    }\n  } else {\n    printf(\" Unknown class\\n\");\n  }\n\n  if (*class != 'U') {\n    printf(\" Comparison of RMS-norms of residual\\n\");\n  } else {\n    printf(\" RMS-norms of residual\\n\");\n  }\n  for (m = 0; m < 5; m++) {\n    if (*class == 'U') {\n      printf(\"          %2d%20.13e\\n\", m, xcr[m]);\n    } else if (xcrdif[m] > epsilon) {\n      *verified = FALSE;\n      printf(\" FAILURE: %2d%20.13e%20.13e%20.13e\\n\",\n\t     m, xcr[m], xcrref[m], xcrdif[m]);\n    } else {\n      printf(\"          %2d%20.13e%20.13e%20.13e\\n\",\n\t     m, xcr[m], xcrref[m], xcrdif[m]);\n    }\n  }\n\n  if (*class != 'U') {\n    printf(\" Comparison of RMS-norms of solution error\\n\");\n  } else {\n    printf(\" RMS-norms of solution error\\n\");\n  }\n        \n  for (m = 0; m < 5; m++) {\n    if (*class == 'U') {\n      printf(\"          %2d%20.13e\\n\", m, xce[m]);\n    } else if (xcedif[m] > epsilon) {\n      *verified = FALSE;\n      printf(\" FAILURE: %2d%20.13e%20.13e%20.13e\\n\",\n\t     m, xce[m], xceref[m], xcedif[m]);\n    } else {\n      printf(\"          %2d%20.13e%20.13e%20.13e\\n\",\n\t     m, xce[m], xceref[m], xcedif[m]);\n    }\n  }\n\n  if (*class == 'U') {\n    printf(\" No reference values provided\\n\");\n    printf(\" No verification performed\\n\");\n  } else if (*verified == TRUE) {\n    printf(\" Verification Successful\\n\");\n  } else {\n    printf(\" Verification failed\\n\");\n  }\n}\n\nstatic void x_solve(void) {\n\n  lhsx();\n  x_solve_cell();\n  x_backsubstitute();\n}\n      \nstatic void x_backsubstitute(void) {\n  int i, j, k, m, n;\n\n  for (i = grid_points[0]-2; i >= 0; i--) {\n#pragma omp for\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\tfor (m = 0; m < BLOCK_SIZE; m++) {\n\t  for (n = 0; n < BLOCK_SIZE; n++) {\n\t    rhs[i][j][k][m] = rhs[i][j][k][m]\n\t      - lhs[i][j][k][CC][m][n]*rhs[i+1][j][k][n];\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nstatic void x_solve_cell(void) {\n  int i,j,k,isize;\n\n  isize = grid_points[0]-1;\n#pragma omp for\n  for (j = 1; j < grid_points[1]-1; j++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      binvcrhs( lhs[0][j][k][BB],\n\t\tlhs[0][j][k][CC],\n\t\trhs[0][j][k] );\n    }\n  }\n  for (i = 1; i < isize; i++) {\n#pragma omp for\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\tmatvec_sub(lhs[i][j][k][AA],\n\t\t   rhs[i-1][j][k], rhs[i][j][k]);\n\tmatmul_sub(lhs[i][j][k][AA],\n\t\t   lhs[i-1][j][k][CC],\n\t\t   lhs[i][j][k][BB]);\n\tbinvcrhs( lhs[i][j][k][BB],\n\t\t  lhs[i][j][k][CC],\n\t\t  rhs[i][j][k] );\n\n      }\n    }\n  }\n\n#pragma omp for\n  for (j = 1; j < grid_points[1]-1; j++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      matvec_sub(lhs[isize][j][k][AA],\n\t\t rhs[isize-1][j][k], rhs[isize][j][k]);\n      matmul_sub(lhs[isize][j][k][AA],\n\t\t lhs[isize-1][j][k][CC],\n\t\t lhs[isize][j][k][BB]);\n      binvrhs( lhs[i][j][k][BB],\n\t       rhs[i][j][k] );\n\n    }\n  }\n}\n\nstatic void matvec_sub(double ablock[5][5], double avec[5], double bvec[5]) {\n  int i;\n\n  for (i = 0; i < 5; i++) {\n    bvec[i] = bvec[i] - ablock[i][0]*avec[0]\n      - ablock[i][1]*avec[1]\n      - ablock[i][2]*avec[2]\n      - ablock[i][3]*avec[3]\n      - ablock[i][4]*avec[4];\n  }\n}\nstatic void matmul_sub(double ablock[5][5], double bblock[5][5],\n\t\t       double cblock[5][5]) {\n  int j;\n\n  for (j = 0; j < 5; j++) {\n    cblock[0][j] = cblock[0][j] - ablock[0][0]*bblock[0][j]\n      - ablock[0][1]*bblock[1][j]\n      - ablock[0][2]*bblock[2][j]\n      - ablock[0][3]*bblock[3][j]\n      - ablock[0][4]*bblock[4][j];\n    cblock[1][j] = cblock[1][j] - ablock[1][0]*bblock[0][j]\n      - ablock[1][1]*bblock[1][j]\n      - ablock[1][2]*bblock[2][j]\n      - ablock[1][3]*bblock[3][j]\n      - ablock[1][4]*bblock[4][j];\n    cblock[2][j] = cblock[2][j] - ablock[2][0]*bblock[0][j]\n      - ablock[2][1]*bblock[1][j]\n      - ablock[2][2]*bblock[2][j]\n      - ablock[2][3]*bblock[3][j]\n      - ablock[2][4]*bblock[4][j];\n    cblock[3][j] = cblock[3][j] - ablock[3][0]*bblock[0][j]\n      - ablock[3][1]*bblock[1][j]\n      - ablock[3][2]*bblock[2][j]\n      - ablock[3][3]*bblock[3][j]\n      - ablock[3][4]*bblock[4][j];\n    cblock[4][j] = cblock[4][j] - ablock[4][0]*bblock[0][j]\n      - ablock[4][1]*bblock[1][j]\n      - ablock[4][2]*bblock[2][j]\n      - ablock[4][3]*bblock[3][j]\n      - ablock[4][4]*bblock[4][j];\n  }\n}\nstatic void binvcrhs(double lhs[5][5], double c[5][5], double r[5]) {\n  double pivot, coeff;\n  pivot = 1.00/lhs[0][0];\n  lhs[0][1] = lhs[0][1]*pivot;\n  lhs[0][2] = lhs[0][2]*pivot;\n  lhs[0][3] = lhs[0][3]*pivot;\n  lhs[0][4] = lhs[0][4]*pivot;\n  c[0][0] = c[0][0]*pivot;\n  c[0][1] = c[0][1]*pivot;\n  c[0][2] = c[0][2]*pivot;\n  c[0][3] = c[0][3]*pivot;\n  c[0][4] = c[0][4]*pivot;\n  r[0]   = r[0]  *pivot;\n\n  coeff = lhs[1][0];\n  lhs[1][1]= lhs[1][1] - coeff*lhs[0][1];\n  lhs[1][2]= lhs[1][2] - coeff*lhs[0][2];\n  lhs[1][3]= lhs[1][3] - coeff*lhs[0][3];\n  lhs[1][4]= lhs[1][4] - coeff*lhs[0][4];\n  c[1][0] = c[1][0] - coeff*c[0][0];\n  c[1][1] = c[1][1] - coeff*c[0][1];\n  c[1][2] = c[1][2] - coeff*c[0][2];\n  c[1][3] = c[1][3] - coeff*c[0][3];\n  c[1][4] = c[1][4] - coeff*c[0][4];\n  r[1]   = r[1]   - coeff*r[0];\n\n  coeff = lhs[2][0];\n  lhs[2][1]= lhs[2][1] - coeff*lhs[0][1];\n  lhs[2][2]= lhs[2][2] - coeff*lhs[0][2];\n  lhs[2][3]= lhs[2][3] - coeff*lhs[0][3];\n  lhs[2][4]= lhs[2][4] - coeff*lhs[0][4];\n  c[2][0] = c[2][0] - coeff*c[0][0];\n  c[2][1] = c[2][1] - coeff*c[0][1];\n  c[2][2] = c[2][2] - coeff*c[0][2];\n  c[2][3] = c[2][3] - coeff*c[0][3];\n  c[2][4] = c[2][4] - coeff*c[0][4];\n  r[2]   = r[2]   - coeff*r[0];\n\n  coeff = lhs[3][0];\n  lhs[3][1]= lhs[3][1] - coeff*lhs[0][1];\n  lhs[3][2]= lhs[3][2] - coeff*lhs[0][2];\n  lhs[3][3]= lhs[3][3] - coeff*lhs[0][3];\n  lhs[3][4]= lhs[3][4] - coeff*lhs[0][4];\n  c[3][0] = c[3][0] - coeff*c[0][0];\n  c[3][1] = c[3][1] - coeff*c[0][1];\n  c[3][2] = c[3][2] - coeff*c[0][2];\n  c[3][3] = c[3][3] - coeff*c[0][3];\n  c[3][4] = c[3][4] - coeff*c[0][4];\n  r[3]   = r[3]   - coeff*r[0];\n\n  coeff = lhs[4][0];\n  lhs[4][1]= lhs[4][1] - coeff*lhs[0][1];\n  lhs[4][2]= lhs[4][2] - coeff*lhs[0][2];\n  lhs[4][3]= lhs[4][3] - coeff*lhs[0][3];\n  lhs[4][4]= lhs[4][4] - coeff*lhs[0][4];\n  c[4][0] = c[4][0] - coeff*c[0][0];\n  c[4][1] = c[4][1] - coeff*c[0][1];\n  c[4][2] = c[4][2] - coeff*c[0][2];\n  c[4][3] = c[4][3] - coeff*c[0][3];\n  c[4][4] = c[4][4] - coeff*c[0][4];\n  r[4]   = r[4]   - coeff*r[0];\n\n\n  pivot = 1.00/lhs[1][1];\n  lhs[1][2] = lhs[1][2]*pivot;\n  lhs[1][3] = lhs[1][3]*pivot;\n  lhs[1][4] = lhs[1][4]*pivot;\n  c[1][0] = c[1][0]*pivot;\n  c[1][1] = c[1][1]*pivot;\n  c[1][2] = c[1][2]*pivot;\n  c[1][3] = c[1][3]*pivot;\n  c[1][4] = c[1][4]*pivot;\n  r[1]   = r[1]  *pivot;\n\n  coeff = lhs[0][1];\n  lhs[0][2]= lhs[0][2] - coeff*lhs[1][2];\n  lhs[0][3]= lhs[0][3] - coeff*lhs[1][3];\n  lhs[0][4]= lhs[0][4] - coeff*lhs[1][4];\n  c[0][0] = c[0][0] - coeff*c[1][0];\n  c[0][1] = c[0][1] - coeff*c[1][1];\n  c[0][2] = c[0][2] - coeff*c[1][2];\n  c[0][3] = c[0][3] - coeff*c[1][3];\n  c[0][4] = c[0][4] - coeff*c[1][4];\n  r[0]   = r[0]   - coeff*r[1];\n\n  coeff = lhs[2][1];\n  lhs[2][2]= lhs[2][2] - coeff*lhs[1][2];\n  lhs[2][3]= lhs[2][3] - coeff*lhs[1][3];\n  lhs[2][4]= lhs[2][4] - coeff*lhs[1][4];\n  c[2][0] = c[2][0] - coeff*c[1][0];\n  c[2][1] = c[2][1] - coeff*c[1][1];\n  c[2][2] = c[2][2] - coeff*c[1][2];\n  c[2][3] = c[2][3] - coeff*c[1][3];\n  c[2][4] = c[2][4] - coeff*c[1][4];\n  r[2]   = r[2]   - coeff*r[1];\n\n  coeff = lhs[3][1];\n  lhs[3][2]= lhs[3][2] - coeff*lhs[1][2];\n  lhs[3][3]= lhs[3][3] - coeff*lhs[1][3];\n  lhs[3][4]= lhs[3][4] - coeff*lhs[1][4];\n  c[3][0] = c[3][0] - coeff*c[1][0];\n  c[3][1] = c[3][1] - coeff*c[1][1];\n  c[3][2] = c[3][2] - coeff*c[1][2];\n  c[3][3] = c[3][3] - coeff*c[1][3];\n  c[3][4] = c[3][4] - coeff*c[1][4];\n  r[3]   = r[3]   - coeff*r[1];\n\n  coeff = lhs[4][1];\n  lhs[4][2]= lhs[4][2] - coeff*lhs[1][2];\n  lhs[4][3]= lhs[4][3] - coeff*lhs[1][3];\n  lhs[4][4]= lhs[4][4] - coeff*lhs[1][4];\n  c[4][0] = c[4][0] - coeff*c[1][0];\n  c[4][1] = c[4][1] - coeff*c[1][1];\n  c[4][2] = c[4][2] - coeff*c[1][2];\n  c[4][3] = c[4][3] - coeff*c[1][3];\n  c[4][4] = c[4][4] - coeff*c[1][4];\n  r[4]   = r[4]   - coeff*r[1];\n\n\n  pivot = 1.00/lhs[2][2];\n  lhs[2][3] = lhs[2][3]*pivot;\n  lhs[2][4] = lhs[2][4]*pivot;\n  c[2][0] = c[2][0]*pivot;\n  c[2][1] = c[2][1]*pivot;\n  c[2][2] = c[2][2]*pivot;\n  c[2][3] = c[2][3]*pivot;\n  c[2][4] = c[2][4]*pivot;\n  r[2]   = r[2]  *pivot;\n\n  coeff = lhs[0][2];\n  lhs[0][3]= lhs[0][3] - coeff*lhs[2][3];\n  lhs[0][4]= lhs[0][4] - coeff*lhs[2][4];\n  c[0][0] = c[0][0] - coeff*c[2][0];\n  c[0][1] = c[0][1] - coeff*c[2][1];\n  c[0][2] = c[0][2] - coeff*c[2][2];\n  c[0][3] = c[0][3] - coeff*c[2][3];\n  c[0][4] = c[0][4] - coeff*c[2][4];\n  r[0]   = r[0]   - coeff*r[2];\n\n  coeff = lhs[1][2];\n  lhs[1][3]= lhs[1][3] - coeff*lhs[2][3];\n  lhs[1][4]= lhs[1][4] - coeff*lhs[2][4];\n  c[1][0] = c[1][0] - coeff*c[2][0];\n  c[1][1] = c[1][1] - coeff*c[2][1];\n  c[1][2] = c[1][2] - coeff*c[2][2];\n  c[1][3] = c[1][3] - coeff*c[2][3];\n  c[1][4] = c[1][4] - coeff*c[2][4];\n  r[1]   = r[1]   - coeff*r[2];\n\n  coeff = lhs[3][2];\n  lhs[3][3]= lhs[3][3] - coeff*lhs[2][3];\n  lhs[3][4]= lhs[3][4] - coeff*lhs[2][4];\n  c[3][0] = c[3][0] - coeff*c[2][0];\n  c[3][1] = c[3][1] - coeff*c[2][1];\n  c[3][2] = c[3][2] - coeff*c[2][2];\n  c[3][3] = c[3][3] - coeff*c[2][3];\n  c[3][4] = c[3][4] - coeff*c[2][4];\n  r[3]   = r[3]   - coeff*r[2];\n\n  coeff = lhs[4][2];\n  lhs[4][3]= lhs[4][3] - coeff*lhs[2][3];\n  lhs[4][4]= lhs[4][4] - coeff*lhs[2][4];\n  c[4][0] = c[4][0] - coeff*c[2][0];\n  c[4][1] = c[4][1] - coeff*c[2][1];\n  c[4][2] = c[4][2] - coeff*c[2][2];\n  c[4][3] = c[4][3] - coeff*c[2][3];\n  c[4][4] = c[4][4] - coeff*c[2][4];\n  r[4]   = r[4]   - coeff*r[2];\n\n\n  pivot = 1.00/lhs[3][3];\n  lhs[3][4] = lhs[3][4]*pivot;\n  c[3][0] = c[3][0]*pivot;\n  c[3][1] = c[3][1]*pivot;\n  c[3][2] = c[3][2]*pivot;\n  c[3][3] = c[3][3]*pivot;\n  c[3][4] = c[3][4]*pivot;\n  r[3]   = r[3]  *pivot;\n\n  coeff = lhs[0][3];\n  lhs[0][4]= lhs[0][4] - coeff*lhs[3][4];\n  c[0][0] = c[0][0] - coeff*c[3][0];\n  c[0][1] = c[0][1] - coeff*c[3][1];\n  c[0][2] = c[0][2] - coeff*c[3][2];\n  c[0][3] = c[0][3] - coeff*c[3][3];\n  c[0][4] = c[0][4] - coeff*c[3][4];\n  r[0]   = r[0]   - coeff*r[3];\n\n  coeff = lhs[1][3];\n  lhs[1][4]= lhs[1][4] - coeff*lhs[3][4];\n  c[1][0] = c[1][0] - coeff*c[3][0];\n  c[1][1] = c[1][1] - coeff*c[3][1];\n  c[1][2] = c[1][2] - coeff*c[3][2];\n  c[1][3] = c[1][3] - coeff*c[3][3];\n  c[1][4] = c[1][4] - coeff*c[3][4];\n  r[1]   = r[1]   - coeff*r[3];\n\n  coeff = lhs[2][3];\n  lhs[2][4]= lhs[2][4] - coeff*lhs[3][4];\n  c[2][0] = c[2][0] - coeff*c[3][0];\n  c[2][1] = c[2][1] - coeff*c[3][1];\n  c[2][2] = c[2][2] - coeff*c[3][2];\n  c[2][3] = c[2][3] - coeff*c[3][3];\n  c[2][4] = c[2][4] - coeff*c[3][4];\n  r[2]   = r[2]   - coeff*r[3];\n\n  coeff = lhs[4][3];\n  lhs[4][4]= lhs[4][4] - coeff*lhs[3][4];\n  c[4][0] = c[4][0] - coeff*c[3][0];\n  c[4][1] = c[4][1] - coeff*c[3][1];\n  c[4][2] = c[4][2] - coeff*c[3][2];\n  c[4][3] = c[4][3] - coeff*c[3][3];\n  c[4][4] = c[4][4] - coeff*c[3][4];\n  r[4]   = r[4]   - coeff*r[3];\n\n\n  pivot = 1.00/lhs[4][4];\n  c[4][0] = c[4][0]*pivot;\n  c[4][1] = c[4][1]*pivot;\n  c[4][2] = c[4][2]*pivot;\n  c[4][3] = c[4][3]*pivot;\n  c[4][4] = c[4][4]*pivot;\n  r[4]   = r[4]  *pivot;\n\n  coeff = lhs[0][4];\n  c[0][0] = c[0][0] - coeff*c[4][0];\n  c[0][1] = c[0][1] - coeff*c[4][1];\n  c[0][2] = c[0][2] - coeff*c[4][2];\n  c[0][3] = c[0][3] - coeff*c[4][3];\n  c[0][4] = c[0][4] - coeff*c[4][4];\n  r[0]   = r[0]   - coeff*r[4];\n\n  coeff = lhs[1][4];\n  c[1][0] = c[1][0] - coeff*c[4][0];\n  c[1][1] = c[1][1] - coeff*c[4][1];\n  c[1][2] = c[1][2] - coeff*c[4][2];\n  c[1][3] = c[1][3] - coeff*c[4][3];\n  c[1][4] = c[1][4] - coeff*c[4][4];\n  r[1]   = r[1]   - coeff*r[4];\n\n  coeff = lhs[2][4];\n  c[2][0] = c[2][0] - coeff*c[4][0];\n  c[2][1] = c[2][1] - coeff*c[4][1];\n  c[2][2] = c[2][2] - coeff*c[4][2];\n  c[2][3] = c[2][3] - coeff*c[4][3];\n  c[2][4] = c[2][4] - coeff*c[4][4];\n  r[2]   = r[2]   - coeff*r[4];\n\n  coeff = lhs[3][4];\n  c[3][0] = c[3][0] - coeff*c[4][0];\n  c[3][1] = c[3][1] - coeff*c[4][1];\n  c[3][2] = c[3][2] - coeff*c[4][2];\n  c[3][3] = c[3][3] - coeff*c[4][3];\n  c[3][4] = c[3][4] - coeff*c[4][4];\n  r[3]   = r[3]   - coeff*r[4];\n}\n\n\nstatic void binvrhs( double lhs[5][5], double r[5] ) {\n\n\n  double pivot, coeff;\n\n\n  pivot = 1.00/lhs[0][0];\n  lhs[0][1] = lhs[0][1]*pivot;\n  lhs[0][2] = lhs[0][2]*pivot;\n  lhs[0][3] = lhs[0][3]*pivot;\n  lhs[0][4] = lhs[0][4]*pivot;\n  r[0]   = r[0]  *pivot;\n\n  coeff = lhs[1][0];\n  lhs[1][1]= lhs[1][1] - coeff*lhs[0][1];\n  lhs[1][2]= lhs[1][2] - coeff*lhs[0][2];\n  lhs[1][3]= lhs[1][3] - coeff*lhs[0][3];\n  lhs[1][4]= lhs[1][4] - coeff*lhs[0][4];\n  r[1]   = r[1]   - coeff*r[0];\n\n  coeff = lhs[2][0];\n  lhs[2][1]= lhs[2][1] - coeff*lhs[0][1];\n  lhs[2][2]= lhs[2][2] - coeff*lhs[0][2];\n  lhs[2][3]= lhs[2][3] - coeff*lhs[0][3];\n  lhs[2][4]= lhs[2][4] - coeff*lhs[0][4];\n  r[2]   = r[2]   - coeff*r[0];\n\n  coeff = lhs[3][0];\n  lhs[3][1]= lhs[3][1] - coeff*lhs[0][1];\n  lhs[3][2]= lhs[3][2] - coeff*lhs[0][2];\n  lhs[3][3]= lhs[3][3] - coeff*lhs[0][3];\n  lhs[3][4]= lhs[3][4] - coeff*lhs[0][4];\n  r[3]   = r[3]   - coeff*r[0];\n\n  coeff = lhs[4][0];\n  lhs[4][1]= lhs[4][1] - coeff*lhs[0][1];\n  lhs[4][2]= lhs[4][2] - coeff*lhs[0][2];\n  lhs[4][3]= lhs[4][3] - coeff*lhs[0][3];\n  lhs[4][4]= lhs[4][4] - coeff*lhs[0][4];\n  r[4]   = r[4]   - coeff*r[0];\n\n\n  pivot = 1.00/lhs[1][1];\n  lhs[1][2] = lhs[1][2]*pivot;\n  lhs[1][3] = lhs[1][3]*pivot;\n  lhs[1][4] = lhs[1][4]*pivot;\n  r[1]   = r[1]  *pivot;\n\n  coeff = lhs[0][1];\n  lhs[0][2]= lhs[0][2] - coeff*lhs[1][2];\n  lhs[0][3]= lhs[0][3] - coeff*lhs[1][3];\n  lhs[0][4]= lhs[0][4] - coeff*lhs[1][4];\n  r[0]   = r[0]   - coeff*r[1];\n\n  coeff = lhs[2][1];\n  lhs[2][2]= lhs[2][2] - coeff*lhs[1][2];\n  lhs[2][3]= lhs[2][3] - coeff*lhs[1][3];\n  lhs[2][4]= lhs[2][4] - coeff*lhs[1][4];\n  r[2]   = r[2]   - coeff*r[1];\n\n  coeff = lhs[3][1];\n  lhs[3][2]= lhs[3][2] - coeff*lhs[1][2];\n  lhs[3][3]= lhs[3][3] - coeff*lhs[1][3];\n  lhs[3][4]= lhs[3][4] - coeff*lhs[1][4];\n  r[3]   = r[3]   - coeff*r[1];\n\n  coeff = lhs[4][1];\n  lhs[4][2]= lhs[4][2] - coeff*lhs[1][2];\n  lhs[4][3]= lhs[4][3] - coeff*lhs[1][3];\n  lhs[4][4]= lhs[4][4] - coeff*lhs[1][4];\n  r[4]   = r[4]   - coeff*r[1];\n\n\n  pivot = 1.00/lhs[2][2];\n  lhs[2][3] = lhs[2][3]*pivot;\n  lhs[2][4] = lhs[2][4]*pivot;\n  r[2]   = r[2]  *pivot;\n\n  coeff = lhs[0][2];\n  lhs[0][3]= lhs[0][3] - coeff*lhs[2][3];\n  lhs[0][4]= lhs[0][4] - coeff*lhs[2][4];\n  r[0]   = r[0]   - coeff*r[2];\n\n  coeff = lhs[1][2];\n  lhs[1][3]= lhs[1][3] - coeff*lhs[2][3];\n  lhs[1][4]= lhs[1][4] - coeff*lhs[2][4];\n  r[1]   = r[1]   - coeff*r[2];\n\n  coeff = lhs[3][2];\n  lhs[3][3]= lhs[3][3] - coeff*lhs[2][3];\n  lhs[3][4]= lhs[3][4] - coeff*lhs[2][4];\n  r[3]   = r[3]   - coeff*r[2];\n\n  coeff = lhs[4][2];\n  lhs[4][3]= lhs[4][3] - coeff*lhs[2][3];\n  lhs[4][4]= lhs[4][4] - coeff*lhs[2][4];\n  r[4]   = r[4]   - coeff*r[2];\n\n\n  pivot = 1.00/lhs[3][3];\n  lhs[3][4] = lhs[3][4]*pivot;\n  r[3]   = r[3]  *pivot;\n\n  coeff = lhs[0][3];\n  lhs[0][4]= lhs[0][4] - coeff*lhs[3][4];\n  r[0]   = r[0]   - coeff*r[3];\n\n  coeff = lhs[1][3];\n  lhs[1][4]= lhs[1][4] - coeff*lhs[3][4];\n  r[1]   = r[1]   - coeff*r[3];\n\n  coeff = lhs[2][3];\n  lhs[2][4]= lhs[2][4] - coeff*lhs[3][4];\n  r[2]   = r[2]   - coeff*r[3];\n\n  coeff = lhs[4][3];\n  lhs[4][4]= lhs[4][4] - coeff*lhs[3][4];\n  r[4]   = r[4]   - coeff*r[3];\n\n\n  pivot = 1.00/lhs[4][4];\n  r[4]   = r[4]  *pivot;\n\n  coeff = lhs[0][4];\n  r[0]   = r[0]   - coeff*r[4];\n\n  coeff = lhs[1][4];\n  r[1]   = r[1]   - coeff*r[4];\n\n  coeff = lhs[2][4];\n  r[2]   = r[2]   - coeff*r[4];\n\n  coeff = lhs[3][4];\n  r[3]   = r[3]   - coeff*r[4];\n\n}\n\nstatic void y_solve(void) {\n  lhsy();\n  y_solve_cell();\n  y_backsubstitute();\n}\n\nstatic void y_backsubstitute(void) {\n  int i, j, k, m, n;\n      \n  for (j = grid_points[1]-2; j >= 0; j--) {\n#pragma omp for\n    for (i = 1; i < grid_points[0]-1; i++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\tfor (m = 0; m < BLOCK_SIZE; m++) {\n\t  for (n = 0; n < BLOCK_SIZE; n++) {\n\t    rhs[i][j][k][m] = rhs[i][j][k][m] \n\t      - lhs[i][j][k][CC][m][n]*rhs[i][j+1][k][n];\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nstatic void y_solve_cell(void) {\n  int i, j, k, jsize;\n\n  jsize = grid_points[1]-1;\n\n#pragma omp for  \n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      binvcrhs( lhs[i][0][k][BB],\n\t\tlhs[i][0][k][CC],\n\t\trhs[i][0][k] );\n    }\n  }\n  for (j = 1; j < jsize; j++) {\n#pragma omp for\n    for (i = 1; i < grid_points[0]-1; i++) {\n      for (k = 1; k < grid_points[2]-1; k++) {\n\tmatvec_sub(lhs[i][j][k][AA],\n\t\t   rhs[i][j-1][k], rhs[i][j][k]);\n\tmatmul_sub(lhs[i][j][k][AA],\n\t\t   lhs[i][j-1][k][CC],\n\t\t   lhs[i][j][k][BB]);\n\tbinvcrhs( lhs[i][j][k][BB],\n\t\t  lhs[i][j][k][CC],\n\t\t  rhs[i][j][k] );\n\n      }\n    }\n  }\n\n#pragma omp for  \n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (k = 1; k < grid_points[2]-1; k++) {\n      matvec_sub(lhs[i][jsize][k][AA],\n\t\t rhs[i][jsize-1][k], rhs[i][jsize][k]);\n      matmul_sub(lhs[i][jsize][k][AA],\n\t\t lhs[i][jsize-1][k][CC],\n\t\t lhs[i][jsize][k][BB]);\n      binvrhs( lhs[i][jsize][k][BB],\n\t       rhs[i][jsize][k] );\n\n    }\n  }\n}\n      \nstatic void z_solve(void) {\n  lhsz();\n  z_solve_cell();\n  z_backsubstitute();\n}\n\nstatic void z_backsubstitute(void) {\n  int i, j, k, m, n;\n\n#pragma omp for  \n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      for (k = grid_points[2]-2; k >= 0; k--) {\n\tfor (m = 0; m < BLOCK_SIZE; m++) {\n\t  for (n = 0; n < BLOCK_SIZE; n++) {\n\t    rhs[i][j][k][m] = rhs[i][j][k][m] \n\t      - lhs[i][j][k][CC][m][n]*rhs[i][j][k+1][n];\n\t  }\n\t}\n      }\n    }\n  }\n}\nstatic void z_solve_cell(void) {\n  int i,j,k,ksize;\n\n  ksize = grid_points[2]-1;\n#pragma omp for  \n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      binvcrhs( lhs[i][j][0][BB],\n\t\tlhs[i][j][0][CC],\n\t\trhs[i][j][0] );\n\n    }\n  }\n  for (k = 1; k < ksize; k++) {\n#pragma omp for\n      for (i = 1; i < grid_points[0]-1; i++) {\n\t  for (j = 1; j < grid_points[1]-1; j++) {\n\tmatvec_sub(lhs[i][j][k][AA],\n\t\t   rhs[i][j][k-1], rhs[i][j][k]);\n\tmatmul_sub(lhs[i][j][k][AA],\n\t\t   lhs[i][j][k-1][CC],\n\t\t   lhs[i][j][k][BB]);\n\tbinvcrhs( lhs[i][j][k][BB],\n\t\t  lhs[i][j][k][CC],\n\t\t  rhs[i][j][k] );\n\n      }\n    }\n  }\n#pragma omp for  \n  for (i = 1; i < grid_points[0]-1; i++) {\n    for (j = 1; j < grid_points[1]-1; j++) {\n      matvec_sub(lhs[i][j][ksize][AA],\n\t\t rhs[i][j][ksize-1], rhs[i][j][ksize]);\n      matmul_sub(lhs[i][j][ksize][AA],\n\t\t lhs[i][j][ksize-1][CC],\n\t\t lhs[i][j][ksize][BB]);\n      binvrhs( lhs[i][j][ksize][BB],\n\t       rhs[i][j][ksize] );\n\n    }\n  }\n}\n"}, {"prompt": "\n#include \"npb-C.h\"\n\n\nint main(int argc, char **argv) {\n\n\n    int i, ierr;\n      \n\n    static dcomplex u0[NZ][NY][NX];\n    static dcomplex pad1[3];\n    static dcomplex u1[NZ][NY][NX];\n    static dcomplex pad2[3];\n    static dcomplex u2[NZ][NY][NX];\n    static dcomplex pad3[3];\n    static int indexmap[NZ][NY][NX];\n    \n    int iter;\n    int nthreads = 1;\n    double total_time, mflops;\n    boolean verified;\n    char class;\n\n    for (i = 0; i < T_MAX; i++) {\n\ttimer_clear(i);\n    }\n    setup();\n\n    compute_indexmap(indexmap, dims[2]);\n  \n    compute_initial_conditions(u1, dims[0]);\n    fft_init (dims[0][0]);\n\n \n    fft(1, u1, u0);\n\n\n\n    for (i = 0; i < T_MAX; i++) {\n\ttimer_clear(i);\n    }\n\n    timer_start(T_TOTAL);\n    if (TIMERS_ENABLED == TRUE) timer_start(T_SETUP);\n\n    compute_indexmap(indexmap, dims[2]);\n\n    compute_initial_conditions(u1, dims[0]);    \n    fft_init (dims[0][0]);\n\n\n    if (TIMERS_ENABLED == TRUE) {\n      timer_stop(T_SETUP);\n    }\n    if (TIMERS_ENABLED == TRUE) {\n      timer_start(T_FFT);\n    }\n  \n    fft(1, u1, u0);\n    if (TIMERS_ENABLED == TRUE) {   \n      timer_stop(T_FFT);\n    }\n\n    for (iter = 1; iter <= niter; iter++) {\n\t    if (TIMERS_ENABLED == TRUE) {     \n\t      timer_start(T_EVOLVE);\n\t    }\n\n\t    evolve(u0, u1, iter, indexmap, dims[0]);\n\n            if (TIMERS_ENABLED == TRUE) {    \n\t      timer_stop(T_EVOLVE);\n\t    }\n            if (TIMERS_ENABLED == TRUE) {  \n\t      timer_start(T_FFT);\n\t    }\n\t\n            fft(-1, u1, u2);\n\t\n            if (TIMERS_ENABLED == TRUE) {      \n\t      timer_stop(T_FFT);\n\t    }\n            if (TIMERS_ENABLED == TRUE) {     \n\t      timer_start(T_CHECKSUM);\n\t    }\t\n            checksum(iter, u2, dims[0]);\n\t\n            if (TIMERS_ENABLED == TRUE) {   \n\t      timer_stop(T_CHECKSUM);\n\t    }\n        \n    }\n\n    verify(NX, NY, NZ, niter, &verified, &class);\n\n#pragma omp parallel \n  {\n    \n#if defined(_OPENMP)\n#pragma omp master    \n    nthreads = omp_get_num_threads();\n#endif /* _OPENMP */    \n#endif /* _OPENMP */    \n  } /* end parallel */\n  } /* end parallel */\n  \n    timer_stop(T_TOTAL);\n    total_time = timer_read(T_TOTAL);\n\n    if( total_time != 0.0) {\n\tmflops = 1.0e-6*(double)(NTOTAL) *\n\t    (14.8157+7.19641*log((double)(NTOTAL))\n\t     +  (5.23518+7.21113*log((double)(NTOTAL)))*niter)\n\t    /total_time;\n    } else {\n\tmflops = 0.0;\n    }\n    c_print_results(\"FT\", class, NX, NY, NZ, niter, nthreads,\n\t\t    total_time, mflops, \"          floating point\", verified, \n\t\t    NPBVERSION, COMPILETIME,\n\t\t    CS1, CS2, CS3, CS4, CS5, CS6, CS7);\n    if (TIMERS_ENABLED == TRUE) print_timers();\n}\n\n\nstatic void evolve(dcomplex u0[NZ][NY][NX], dcomplex u1[NZ][NY][NX],\n\t\t   int t, int indexmap[NZ][NY][NX], int d[3]) {\n\n\n\n    int i, j, k;\n\n#pragma omp parallel for default(shared) private(i,j,k)   \n    for (k = 0; k < d[2]; k++) {\n\tfor (j = 0; j < d[1]; j++) {\n            for (i = 0; i < d[0]; i++) {\n\t      crmul(u1[k][j][i], u0[k][j][i], ex[t*indexmap[k][j][i]]);\n\t    }\n\t}\n    }\n}\n\n\nstatic void compute_initial_conditions(dcomplex u0[NZ][NY][NX], int d[3]) {\n\n\n\n    int k;\n    double x0, start, an, dummy;\n    static double tmp[NX*2*MAXDIM+1];\n    int i,j,t;\n      \n    start = SEED;\n    ipow46(A, (zstart[0]-1)*2*NX*NY + (ystart[0]-1)*2*NX, &an);\n    dummy = randlc(&start, an);\n    ipow46(A, 2*NX*NY, &an);\n      \n    for (k = 0; k < dims[0][2]; k++) {\n\tx0 = start;\n        vranlc(2*NX*dims[0][1], &x0, A, tmp);\n\t\n\tt = 1;\n\tfor (j = 0; j < dims[0][1]; j++)\n\t  for (i = 0; i < NX; i++) {\n\t    u0[k][j][i].real = tmp[t++];\n\t    u0[k][j][i].imag = tmp[t++];\n\t  }\n\t      \n        if (k != dims[0][2]) dummy = randlc(&start, an);\n    }\n}\n\n\nstatic void ipow46(double a, int exponent, double *result) {\n\n\n\n    double dummy, q, r;\n    int n, n2;\n\n    *result = 1;\n    if (exponent == 0) return;\n    q = a;\n    r = 1;\n    n = exponent;\n\n    while (n > 1) {\n\tn2 = n/2;\n\tif (n2 * 2 == n) {\n            dummy = randlc(&q, q);\n            n = n2;\n\t} else {\n            dummy = randlc(&r, q);\n            n = n-1;\n\t}\n    }\n    dummy = randlc(&r, q);\n    *result = r;\n}\n\n\nstatic void setup(void) {\n\n\n    int ierr, i, j, fstatus;\n      \n    printf(\"\\n\\n NAS Parallel Benchmarks 3.0 structured OpenMP C version\"\n\t   \" - FT Benchmark\\n\\n\");\n\n    niter = NITER_DEFAULT;\n\n    printf(\" Size                : %3dx%3dx%3d\\n\", NX, NY, NZ);\n    printf(\" Iterations          :     %7d\\n\", niter);\n\n\n    for (i = 0;i < 3 ; i++) {\n\tdims[i][0] = NX;\n\tdims[i][1] = NY;\n\tdims[i][2] = NZ;\n    }\n\n\n    for (i = 0; i < 3; i++) {\n\txstart[i] = 1;\n\txend[i]   = NX;\n\tystart[i] = 1;\n        yend[i]   = NY;\n        zstart[i] = 1;\n        zend[i]   = NZ;\n    }\n\n\n    fftblock = FFTBLOCK_DEFAULT;\n    fftblockpad = FFTBLOCKPAD_DEFAULT;\n\n    if (fftblock != FFTBLOCK_DEFAULT) fftblockpad = fftblock+3;\n}\n      \n\nstatic void compute_indexmap(int indexmap[NZ][NY][NX], int d[3]) {\n\n\n\n    int i, j, k, ii, ii2, jj, ij2, kk;\n    double ap;\n\n\n#pragma omp parallel for default(shared) private(i,j,k,ii,ii2,jj,ij2,kk)    \n    for (i = 0; i < dims[2][0]; i++) {\n\tii =  (i+1+xstart[2]-2+NX/2)%NX - NX/2;\n\tii2 = ii*ii;\n\tfor (j = 0; j < dims[2][1]; j++) {\n            jj = (j+1+ystart[2]-2+NY/2)%NY - NY/2;\n            ij2 = jj*jj+ii2;\n            for (k = 0; k < dims[2][2]; k++) {\n\t\tkk = (k+1+zstart[2]-2+NZ/2)%NZ - NZ/2;\n\t\tindexmap[k][j][i] = kk*kk+ij2;\n\t    }\n\t}\n    }\n\n    ap = - 4.0 * ALPHA * PI * PI;\n\n    ex[0] = 1.0;\n    ex[1] = exp(ap);\n    for (i = 2; i <= EXPMAX; i++) {\n\tex[i] = ex[i-1]*ex[1];\n    }\n\n}\n\n\nstatic void print_timers(void) {\n\n\n    int i;\n    char *tstrings[] = { \"          total \",\n\t\t\t \"          setup \", \n\t\t\t \"            fft \", \n\t\t\t \"         evolve \", \n\t\t\t \"       checksum \", \n\t\t\t \"         fftlow \", \n\t\t\t \"        fftcopy \" };\n\n    for (i = 0; i < T_MAX; i++) {\n\tif (timer_read(i) != 0.0) {\n            printf(\"timer %2d(%16s( :%10.6f\\n\", i, tstrings[i], timer_read(i));\n\t}\n    }\n}\n\n\n\nstatic void fft(int dir, dcomplex x1[NZ][NY][NX], dcomplex x2[NZ][NY][NX]) {\n\n\n    dcomplex y0[NX][FFTBLOCKPAD];\n    dcomplex y1[NX][FFTBLOCKPAD];\n\n\n    if (dir == 1) {\n        cffts1(1, dims[0], x1, x1, y0, y1);\t/* x1 -> x1 */\n        cffts1(1, dims[0], x1, x1, y0, y1);\t/* x1 -> x1 */\n        cffts2(1, dims[1], x1, x1, y0, y1);\t/* x1 -> x1 */\n        cffts2(1, dims[1], x1, x1, y0, y1);\t/* x1 -> x1 */\n        cffts3(1, dims[2], x1, x2, y0, y1);\t/* x1 -> x2 */\n        cffts3(1, dims[2], x1, x2, y0, y1);\t/* x1 -> x2 */\n    } else {\n\tcffts3(-1, dims[2], x1, x1, y0, y1);\t/* x1 -> x1 */\n\tcffts3(-1, dims[2], x1, x1, y0, y1);\t/* x1 -> x1 */\n    cffts2(-1, dims[1], x1, x1, y0, y1);\t/* x1 -> x1 */\n    cffts2(-1, dims[1], x1, x1, y0, y1);\t/* x1 -> x1 */\n    cffts1(-1, dims[0], x1, x2, y0, y1);\t/* x1 -> x2 */\n    cffts1(-1, dims[0], x1, x2, y0, y1);\t/* x1 -> x2 */\n    }\n}\n\n\n\nstatic void cffts1(int is, int d[3], dcomplex x[NZ][NY][NX],\n\t\t   dcomplex xout[NZ][NY][NX],\n\t\t   dcomplex y0[NX][FFTBLOCKPAD],\n\t\t   dcomplex y1[NX][FFTBLOCKPAD]) {\n\n\n    int logd[3];\n    int i, j, k, jj;\n\n    for (i = 0; i < 3; i++) {\n\tlogd[i] = ilog2(d[i]);\n    }\n\n#pragma omp parallel default(shared) private(i,j,k,jj) shared(is)\n{\ndcomplex y0[NX][FFTBLOCKPAD];\ndcomplex y1[NX][FFTBLOCKPAD];\n\n#pragma omp for \t\n    for (k = 0; k < d[2]; k++) {\n\tfor (jj = 0; jj <= d[1] - fftblock; jj+=fftblock) {\n\nstatic void cffts2(int is, int d[3], dcomplex x[NZ][NY][NX],\n\t\t   dcomplex xout[NZ][NY][NX],\n\t\t   dcomplex y0[NX][FFTBLOCKPAD],\n\t\t   dcomplex y1[NX][FFTBLOCKPAD]) {\n\n\n    int logd[3];\n    int i, j, k, ii;\n\n    for (i = 0; i < 3; i++) {\n\tlogd[i] = ilog2(d[i]);\n    }\n#pragma omp parallel default(shared) private(i,j,k,ii) shared(is)\n{\ndcomplex y0[NX][FFTBLOCKPAD];\ndcomplex y1[NX][FFTBLOCKPAD];\n\n#pragma omp for \t\n    for (k = 0; k < d[2]; k++) {\n        for (ii = 0; ii <= d[0] - fftblock; ii+=fftblock) {\n\nstatic void cffts3(int is, int d[3], dcomplex x[NZ][NY][NX],\n\t\t   dcomplex xout[NZ][NY][NX],\n\t\t   dcomplex y0[NX][FFTBLOCKPAD],\n\t\t   dcomplex y1[NX][FFTBLOCKPAD]) {\n\n\n    int logd[3];\n    int i, j, k, ii;\n\n    for (i = 0;i < 3; i++) {\n\tlogd[i] = ilog2(d[i]);\n    }\n#pragma omp parallel default(shared) private(i,j,k,ii) shared(is)\n{\ndcomplex y0[NX][FFTBLOCKPAD];\ndcomplex y1[NX][FFTBLOCKPAD];\n\n#pragma omp for \t\n    for (j = 0; j < d[1]; j++) {\n        for (ii = 0; ii <= d[0] - fftblock; ii+=fftblock) {\n\nstatic void fft_init (int n) {\n\n\n\n    int m,nu,ku,i,j,ln;\n    double t, ti;\n\n\n    nu = n;\n    m = ilog2(n);\n    u[0].real = (double)m;\n    u[0].imag = 0.0;\n    ku = 1;\n    ln = 1;\n\n    for (j = 1; j <= m; j++) {\n\tt = PI / ln;\n         \n\tfor (i = 0; i <= ln - 1; i++) {\n            ti = i * t;\n            u[i+ku].real = cos(ti);\n\t    u[i+ku].imag = sin(ti);\n\t}\n         \n\tku = ku + ln;\n\tln = 2 * ln;\n    }\n}\n\n\n\nstatic void cfftz (int is, int m, int n, dcomplex x[NX][FFTBLOCKPAD],\n\t\t   dcomplex y[NX][FFTBLOCKPAD]) {\n\n\n\n    int i,j,l,mx;\n\n    mx = (int)(u[0].real);\n    if ((is != 1 && is != -1) || m < 1 || m > mx) {\n\tprintf(\"CFFTZ: Either U has not been initialized, or else\\n\"\n\t       \"one of the input parameters is invalid%5d%5d%5d\\n\",\n\t       is, m, mx);\n\texit(1);\n    }\n\n    for (l = 1; l <= m; l+=2) {\n        fftz2 (is, l, m, n, fftblock, fftblockpad, u, x, y);\n        if (l == m) break;\n\tfftz2 (is, l + 1, m, n, fftblock, fftblockpad, u, y, x);\n    }\n\n    if (m % 2 == 1) {\n\tfor (j = 0; j < n; j++) {\n\t    for (i = 0; i < fftblock; i++) {\n\t\tx[j][i].real = y[j][i].real;\n\t\tx[j][i].imag = y[j][i].imag;\n\t    }\n\t}\n    }\n}\n\n\n\nstatic void fftz2 (int is, int l, int m, int n, int ny, int ny1,\n\t\t   dcomplex u[NX], dcomplex x[NX][FFTBLOCKPAD],\n\t\t   dcomplex y[NX][FFTBLOCKPAD]) {\n\n\n\n    int k,n1,li,lj,lk,ku,i,j,i11,i12,i21,i22;\n    dcomplex u1,x11,x21;\n\n\n    n1 = n / 2;\n    if (l-1 == 0) {\n\tlk = 1;\n    } else {\n\tlk = 2 << ((l - 1)-1);\n    }\n    if (m-l == 0) {\n\tli = 1;\n    } else {\n\tli = 2 << ((m - l)-1);\n    }\n    lj = 2 * lk;\n    ku = li;\n\n    for (i = 0; i < li; i++) {\n      \n        i11 = i * lk;\n        i12 = i11 + n1;\n        i21 = i * lj;\n        i22 = i21 + lk;\n        if (is >= 1) {\n          u1.real = u[ku+i].real;\n          u1.imag = u[ku+i].imag;\n        } else {\n          u1.real = u[ku+i].real;\n          u1.imag = -u[ku+i].imag;\n        }\n\n        for (k = 0; k < lk; k++) {\n\t    for (j = 0; j < ny; j++) {\n\t\tdouble x11real, x11imag;\n\t\tdouble x21real, x21imag;\n\t\tx11real = x[i11+k][j].real;\n\t\tx11imag = x[i11+k][j].imag;\n\t\tx21real = x[i12+k][j].real;\n\t\tx21imag = x[i12+k][j].imag;\n\t\ty[i21+k][j].real = x11real + x21real;\n\t\ty[i21+k][j].imag = x11imag + x21imag;\n\t\ty[i22+k][j].real = u1.real * (x11real - x21real)\n\t\t    - u1.imag * (x11imag - x21imag);\n\t\ty[i22+k][j].imag = u1.real * (x11imag - x21imag)\n\t\t    + u1.imag * (x11real - x21real);\n\t    }\n\t}\n    }\n}\n\n\n\nstatic int ilog2(int n) {\n\n\n    int nn, lg;\n\n    if (n == 1) {\n\treturn 0;\n    }\n    lg = 1;\n    nn = 2;\n    while (nn < n) {\n\tnn = nn << 1;\n\tlg++;\n    }\n\n    return lg;\n}\n\n\n\nstatic void checksum(int i, dcomplex u1[NZ][NY][NX], int d[3]) {\n\n#pragma omp parallel default(shared) \n{\n\n\n    int j, q,r,s, ierr;\n    dcomplex chk,allchk;\n    \n    chk.real = 0.0;\n    chk.imag = 0.0;\n\n\n#pragma omp for nowait\n    for (j = 1; j <= 1024; j++) {\n\tq = j%NX+1;\n\tif (q >= xstart[0] && q <= xend[0]) {\n            r = (3*j)%NY+1;\n            if (r >= ystart[0] && r <= yend[0]) {\n\t\ts = (5*j)%NZ+1;\n\t\tif (s >= zstart[0] && s <= zend[0]) {\n\t\t  cadd(chk,chk,u1[s-zstart[0]][r-ystart[0]][q-xstart[0]]);\n\t\t}\n\t    }\n\t}\n    }\n#pragma omp critical\n    {\n\tsums[i].real += chk.real;\n\tsums[i].imag += chk.imag;\n    }\n#pragma omp barrier\n#pragma omp single\n  {    \n    /* complex % real */\n    /* complex % real */\n    sums[i].real = sums[i].real/(double)(NTOTAL);\n    sums[i].imag = sums[i].imag/(double)(NTOTAL);\n\n    printf(\"T = %5d     Checksum = %22.12e %22.12e\\n\",\n\t   i, sums[i].real, sums[i].imag);\n  }\n}\n}\n\n\nstatic void verify (int d1, int d2, int d3, int nt,\n\t\t    boolean *verified, char *class) {\n\n\n    int ierr, size, i;\n    double err, epsilon;\n\n    \n    double vdata_real_s[6+1] = { 0.0,\n\t\t\t\t 5.546087004964e+02,\n\t\t\t\t 5.546385409189e+02,\n\t\t\t\t 5.546148406171e+02,\n\t\t\t\t 5.545423607415e+02,\n\t\t\t\t 5.544255039624e+02,\n\t\t\t\t 5.542683411902e+02 };\n    double vdata_imag_s[6+1] = { 0.0,\n\t\t\t\t 4.845363331978e+02,\n\t\t\t\t 4.865304269511e+02,\n\t\t\t\t 4.883910722336e+02,\n\t\t\t\t 4.901273169046e+02,\n\t\t\t\t 4.917475857993e+02,\n\t\t\t\t 4.932597244941e+02 };\n    double vdata_real_w[6+1] = { 0.0,\n\t\t\t\t 5.673612178944e+02,\n\t\t\t\t 5.631436885271e+02,\n\t\t\t\t 5.594024089970e+02,\n\t\t\t\t 5.560698047020e+02,\n\t\t\t\t 5.530898991250e+02,\n\t\t\t\t 5.504159734538e+02 };\n    double vdata_imag_w[6+1] = { 0.0,\n\t\t\t\t 5.293246849175e+02,\n\t\t\t\t 5.282149986629e+02,\n\t\t\t\t 5.270996558037e+02, \n\t\t\t\t 5.260027904925e+02, \n\t\t\t\t 5.249400845633e+02,\n\t\t\t\t 5.239212247086e+02 };\n    double vdata_real_a[6+1] = { 0.0,\n\t\t\t\t 5.046735008193e+02,\n\t\t\t\t 5.059412319734e+02,\n\t\t\t\t 5.069376896287e+02,\n\t\t\t\t 5.077892868474e+02,\n\t\t\t\t 5.085233095391e+02,\n\t\t\t\t 5.091487099959e+02 };\n    double vdata_imag_a[6+1] = { 0.0,\n\t\t\t\t 5.114047905510e+02,\n\t\t\t\t 5.098809666433e+02,\n\t\t\t\t 5.098144042213e+02,\n\t\t\t\t 5.101336130759e+02,\n\t\t\t\t 5.104914655194e+02,\n\t\t\t\t 5.107917842803e+02 };\n    double vdata_real_b[20+1] = { 0.0,\n\t\t\t\t  5.177643571579e+02,\n\t\t\t\t  5.154521291263e+02,\n\t\t\t\t  5.146409228649e+02,\n\t\t\t\t  5.142378756213e+02,\n\t\t\t\t  5.139626667737e+02,\n\t\t\t\t  5.137423460082e+02,\n\t\t\t\t  5.135547056878e+02,\n\t\t\t\t  5.133910925466e+02,\n\t\t\t\t  5.132470705390e+02,\n\t\t\t\t  5.131197729984e+02,\n\t\t\t\t  5.130070319283e+02,\n\t\t\t\t  5.129070537032e+02,\n\t\t\t\t  5.128182883502e+02,\n\t\t\t\t  5.127393733383e+02,\n\t\t\t\t  5.126691062020e+02,\n\t\t\t\t  5.126064276004e+02,\n\t\t\t\t  5.125504076570e+02,\n\t\t\t\t  5.125002331720e+02,\n\t\t\t\t  5.124551951846e+02,\n\t\t\t\t  5.124146770029e+02 };\n    double vdata_imag_b[20+1] = { 0.0,\n\t\t\t\t  5.077803458597e+02,\n\t\t\t\t  5.088249431599e+02,                  \n\t\t\t\t  5.096208912659e+02,\n\t\t\t\t  5.101023387619e+02,                  \n\t\t\t\t  5.103976610617e+02,                  \n\t\t\t\t  5.105948019802e+02,                  \n\t\t\t\t  5.107404165783e+02,                  \n\t\t\t\t  5.108576573661e+02,                  \n\t\t\t\t  5.109577278523e+02,\n\t\t\t\t  5.110460304483e+02,                  \n\t\t\t\t  5.111252433800e+02,                  \n\t\t\t\t  5.111968077718e+02,                  \n\t\t\t\t  5.112616233064e+02,                  \n\t\t\t\t  5.113203605551e+02,                  \n\t\t\t\t  5.113735928093e+02,                  \n\t\t\t\t  5.114218460548e+02,\n\t\t\t\t  5.114656139760e+02,\n\t\t\t\t  5.115053595966e+02,\n\t\t\t\t  5.115415130407e+02,\n\t\t\t\t  5.115744692211e+02 };\n    double vdata_real_c[20+1] = { 0.0,\n\t\t\t\t  5.195078707457e+02,\n\t\t\t\t  5.155422171134e+02,\n\t\t\t\t  5.144678022222e+02,\n\t\t\t\t  5.140150594328e+02,\n\t\t\t\t  5.137550426810e+02,\n\t\t\t\t  5.135811056728e+02,\n\t\t\t\t  5.134569343165e+02,\n\t\t\t\t  5.133651975661e+02,\n\t\t\t\t  5.132955192805e+02,\n\t\t\t\t  5.132410471738e+02,\n\t\t\t\t  5.131971141679e+02,\n\t\t\t\t  5.131605205716e+02,\n\t\t\t\t  5.131290734194e+02,\n\t\t\t\t  5.131012720314e+02,\n\t\t\t\t  5.130760908195e+02,\n\t\t\t\t  5.130528295923e+02,\n\t\t\t\t  5.130310107773e+02,\n\t\t\t\t  5.130103090133e+02,\n\t\t\t\t  5.129905029333e+02,\n\t\t\t\t  5.129714421109e+02 };\n    double vdata_imag_c[20+1] = { 0.0,\n\t\t\t\t  5.149019699238e+02,\n\t\t\t\t  5.127578201997e+02,\n\t\t\t\t  5.122251847514e+02,\n\t\t\t\t  5.121090289018e+02,\n\t\t\t\t  5.121143685824e+02,\n\t\t\t\t  5.121496764568e+02,\n\t\t\t\t  5.121870921893e+02,\n\t\t\t\t  5.122193250322e+02,\n\t\t\t\t  5.122454735794e+02,\n\t\t\t\t  5.122663649603e+02,\n\t\t\t\t  5.122830879827e+02,\n\t\t\t\t  5.122965869718e+02,\n\t\t\t\t  5.123075927445e+02,\n\t\t\t\t  5.123166486553e+02,\n\t\t\t\t  5.123241541685e+02,\n\t\t\t\t  5.123304037599e+02,\n\t\t\t\t  5.123356167976e+02,\n\t\t\t\t  5.123399592211e+02,\n\t\t\t\t  5.123435588985e+02,\n\t\t\t\t  5.123465164008e+02 };\n\n    epsilon = 1.0e-12;\n    *verified = TRUE;\n    *class = 'U';\n\n    if (d1 == 64 &&\n\td2 == 64 &&\n\td3 == 64 &&\n\tnt == 6) {\n\t*class = 'S';\n\tfor (i = 1; i <= nt; i++) {\n            err = (get_real(sums[i]) - vdata_real_s[i]) / vdata_real_s[i];\n            if (fabs(err) > epsilon) {\n\t      *verified = FALSE;\n\t      break;\n\t    }\n            err = (get_imag(sums[i]) - vdata_imag_s[i]) / vdata_imag_s[i];\n            if (fabs(err) > epsilon) {\n\t      *verified = FALSE;\n\t      break;\n\t    }\n\t}\n    } else if (d1 == 128 &&\n\t       d2 == 128 &&\n\t       d3 == 32 &&\n\t       nt == 6) {\n\t*class = 'W';\n\tfor (i = 1; i <= nt; i++) {\n            err = (get_real(sums[i]) - vdata_real_w[i]) / vdata_real_w[i];\n            if (fabs(err) > epsilon) {\n\t      *verified = FALSE;\n\t      break;\n\t    }\n            err = (get_imag(sums[i]) - vdata_imag_w[i]) / vdata_imag_w[i];\n            if (fabs(err) > epsilon) {\n\t      *verified = FALSE;\n\t      break;\n\t    }\n\t}\n    } else if (d1 == 256 &&\n\t       d2 == 256 &&\n\t       d3 == 128 &&\n\t       nt == 6) {\n\t*class = 'A';\n\tfor (i = 1; i <= nt; i++) {\n            err = (get_real(sums[i]) - vdata_real_a[i]) / vdata_real_a[i];\n            if (fabs(err) > epsilon) {\n\t      *verified = FALSE;\n\t      break;\n\t    }\n            err = (get_imag(sums[i]) - vdata_imag_a[i]) / vdata_imag_a[i];\n            if (fabs(err) > epsilon) {\n\t      *verified = FALSE;\n\t      break;\n\t    }\n\t}\n    } else if (d1 == 512 &&\n\t       d2 == 256 &&\n\t       d3 == 256 &&\n\t       nt == 20) {\n\t*class = 'B';\n\tfor (i = 1; i <= nt; i++) {\n            err = (get_real(sums[i]) - vdata_real_b[i]) / vdata_real_b[i];\n            if (fabs(err) > epsilon) {\n\t      *verified = FALSE;\n\t      break;\n\t    }\n            err = (get_imag(sums[i]) - vdata_imag_b[i]) / vdata_imag_b[i];\n            if (fabs(err) > epsilon) {\n\t      *verified = FALSE;\n\t      break;\n\t    }\n\t}\n    } else if (d1 == 512 &&\n\t       d2 == 512 &&\n\t       d3 == 512 &&\n\t       nt == 20) {\n\t*class = 'C';\n\tfor (i = 1; i <= nt; i++) {\n            err = (get_real(sums[i]) - vdata_real_c[i]) / vdata_real_c[i];\n            if (fabs(err) > epsilon) {\n\t      *verified = FALSE;\n\t      break;\n\t    }\n            err = (get_imag(sums[i]) - vdata_imag_c[i]) / vdata_imag_c[i];\n            if (fabs(err) > epsilon) {\n\t      *verified = FALSE;\n\t      break;\n\t    }\n\t}\n    }\n    \n    if (*class != 'U') {\n\tprintf(\"Result verification successful\\n\");\n    } else {\n\tprintf(\"Result verification failed\\n\");\n    }\n    printf(\"class = %1c\\n\", *class);\n}\n\n"}, {"prompt": "\n#include \"npb-C.h\"\n\n#include \"globals.h\"\n\n\nint main(int argc, char *argv[]) {\n\n\n    int k, it;\n    double t, tinit, mflops;\n    int nthreads = 1;\n\n    \n    double ****u, ***v, ****r;\n    double a[4], c[4];\n\n    double rnm2, rnmu;\n    double epsilon = 1.0e-8;\n    int n1, n2, n3, nit;\n    double verify_value;\n    boolean verified;\n\n    int i, j, l;\n    FILE *fp;\n\n    timer_clear(T_BENCH);\n    timer_clear(T_INIT);\n\n    timer_start(T_INIT);\n\n\n    printf(\"\\n\\n NAS Parallel Benchmarks 3.0 structured OpenMP C version\"\n\t   \" - MG Benchmark\\n\\n\");\n\n    fp = fopen(\"mg.input\", \"r\");\n    if (fp != NULL) {\n\tprintf(\" Reading from input file mg.input\\n\");\n\tfscanf(fp, \"%d\", &lt);\n\twhile(fgetc(fp) != '\\n');\n\tfscanf(fp, \"%d%d%d\", &nx[lt], &ny[lt], &nz[lt]);\n\twhile(fgetc(fp) != '\\n');\n\tfscanf(fp, \"%d\", &nit);\n\twhile(fgetc(fp) != '\\n');\n\tfor (i = 0; i <= 7; i++) {\n\t    fscanf(fp, \"%d\", &debug_vec[i]);\n\t}\n\tfclose(fp);\n    } else {\n\tprintf(\" No input file. Using compiled defaults\\n\");\n    \n\tlt = LT_DEFAULT;\n\tnit = NIT_DEFAULT;\n\tnx[lt] = NX_DEFAULT;\n\tny[lt] = NY_DEFAULT;\n\tnz[lt] = NZ_DEFAULT;\n\n\tfor (i = 0; i <= 7; i++) {\n\t    debug_vec[i] = DEBUG_DEFAULT;\n\t}\n    }\n\n    if ( (nx[lt] != ny[lt]) || (nx[lt] != nz[lt]) ) {\n\tClass = 'U';\n    } else if( nx[lt] == 32 && nit == 4 ) {\n\tClass = 'S';\n    } else if( nx[lt] == 64 && nit == 40 ) {\n\tClass = 'W';\n    } else if( nx[lt] == 256 && nit == 20 ) {\n\tClass = 'B';\n    } else if( nx[lt] == 512 && nit == 20 ) {\n\tClass = 'C';\n    } else if( nx[lt] == 256 && nit == 4 ) {\n\tClass = 'A';\n    } else {\n\tClass = 'U';\n    }\n\n\n    a[0] = -8.0/3.0;\n    a[1] =  0.0;\n    a[2] =  1.0/6.0;\n    a[3] =  1.0/12.0;\n\n    if (Class == 'A' || Class == 'S' || Class =='W') {\n\tc[0] =  -3.0/8.0;\n\tc[1] =  1.0/32.0;\n\tc[2] =  -1.0/64.0;\n\tc[3] =   0.0;\n    } else {\n\tc[0] =  -3.0/17.0;\n\tc[1] =  1.0/33.0;\n\tc[2] =  -1.0/61.0;\n\tc[3] =   0.0;\n    }\n    \n    lb = 1;\n\n    setup(&n1,&n2,&n3,lt);\n      \n    u = (double ****)malloc((lt+1)*sizeof(double ***));\n    for (l = lt; l >=1; l--) {\n\tu[l] = (double ***)malloc(m3[l]*sizeof(double **));\n\tfor (k = 0; k < m3[l]; k++) {\n\t    u[l][k] = (double **)malloc(m2[l]*sizeof(double *));\n\t    for (j = 0; j < m2[l]; j++) {\n\t\tu[l][k][j] = (double *)malloc(m1[l]*sizeof(double));\n\t    }\n\t}\n    }\n    v = (double ***)malloc(m3[lt]*sizeof(double **));\n    for (k = 0; k < m3[lt]; k++) {\n\tv[k] = (double **)malloc(m2[lt]*sizeof(double *));\n\tfor (j = 0; j < m2[lt]; j++) {\n\t    v[k][j] = (double *)malloc(m1[lt]*sizeof(double));\n\t}\n    }\n    r = (double ****)malloc((lt+1)*sizeof(double ***));\n    for (l = lt; l >=1; l--) {\n\tr[l] = (double ***)malloc(m3[l]*sizeof(double **));\n\tfor (k = 0; k < m3[l]; k++) {\n\t    r[l][k] = (double **)malloc(m2[l]*sizeof(double *));\n\t    for (j = 0; j < m2[l]; j++) {\n\t\tr[l][k][j] = (double *)malloc(m1[l]*sizeof(double));\n\t    }\n\t}\n    }\n\n    zero3(u[lt],n1,n2,n3);\n    zran3(v,n1,n2,n3,nx[lt],ny[lt],lt);\n\n    norm2u3(v,n1,n2,n3,&rnm2,&rnmu,nx[lt],ny[lt],nz[lt]);\n\n\n    printf(\" Size: %3dx%3dx%3d (class %1c)\\n\",\n\t   nx[lt], ny[lt], nz[lt], Class);\n    printf(\" Iterations: %3d\\n\", nit);\n\n    resid(u[lt],v,r[lt],n1,n2,n3,a,lt);\n    norm2u3(r[lt],n1,n2,n3,&rnm2,&rnmu,nx[lt],ny[lt],nz[lt]);\n\n    mg3P(u,v,r,a,c,n1,n2,n3,lt);\n    resid(u[lt],v,r[lt],n1,n2,n3,a,lt);\n\n    setup(&n1,&n2,&n3,lt);\n\n    zero3(u[lt],n1,n2,n3); \n\n    zran3(v,n1,n2,n3,nx[lt],ny[lt],lt);\n    \n\n    timer_stop(T_INIT);\n    timer_start(T_BENCH);\n\n    resid(u[lt],v,r[lt],n1,n2,n3,a,lt);\n    norm2u3(r[lt],n1,n2,n3,&rnm2,&rnmu,nx[lt],ny[lt],nz[lt]);\n\n    for ( it = 1; it <= nit; it++) {\n\tmg3P(u,v,r,a,c,n1,n2,n3,lt);\n\tresid(u[lt],v,r[lt],n1,n2,n3,a,lt);\n    }\n    norm2u3(r[lt],n1,n2,n3,&rnm2,&rnmu,nx[lt],ny[lt],nz[lt]);\n\n#pragma omp parallel\n{   \n#if defined(_OPENMP)\n#pragma omp master  \n  nthreads = omp_get_num_threads();\n#endif /* _OPENMP */\n#endif /* _OPENMP */\n} /* end parallel */\n} /* end parallel */\n\n    timer_stop(T_BENCH);\n    t = timer_read(T_BENCH);\n    tinit = timer_read(T_INIT);\n\n    verified = FALSE;\n    verify_value = 0.0;\n\n    printf(\" Initialization time: %15.3f seconds\\n\", tinit);\n    printf(\" Benchmark completed\\n\");\n\n    if (Class != 'U') {\n\tif (Class == 'S') {\n            verify_value = 0.530770700573e-04;\n\t} else if (Class == 'W') {\n            verify_value = 0.250391406439e-17;  /* 40 iterations*/\n            verify_value = 0.250391406439e-17;  /* 40 iterations*/\n\nstatic void setup(int *n1, int *n2, int *n3, int lt) {\n\n\n    int k;\n\n    for ( k = lt-1; k >= 1; k--) {\n\tnx[k] = nx[k+1]/2;\n\tny[k] = ny[k+1]/2;\n\tnz[k] = nz[k+1]/2;\n    }\n\n    for (k = 1; k <= lt; k++) {\n\tm1[k] = nx[k]+2;\n\tm2[k] = nz[k]+2;\n\tm3[k] = ny[k]+2;\n    }\n\n    is1 = 1;\n    ie1 = nx[lt];\n    *n1 = nx[lt]+2;\n    is2 = 1;\n    ie2 = ny[lt];\n    *n2 = ny[lt]+2;\n    is3 = 1;\n    ie3 = nz[lt];\n    *n3 = nz[lt]+2;\n\n    if (debug_vec[1] >=  1 ) {\n\tprintf(\" in setup, \\n\");\n\tprintf(\"  lt  nx  ny  nz  n1  n2  n3 is1 is2 is3 ie1 ie2 ie3\\n\");\n\tprintf(\"%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d%4d\\n\",\n\t       lt,nx[lt],ny[lt],nz[lt],*n1,*n2,*n3,is1,is2,is3,ie1,ie2,ie3);\n    }\n}\n\n\nstatic void mg3P(double ****u, double ***v, double ****r, double a[4],\n\t\t double c[4], int n1, int n2, int n3, int k) {\n\n\n\n    int j;\n\n\n    for (k = lt; k >= lb+1; k--) {\n\tj = k-1;\n\trprj3(r[k], m1[k], m2[k], m3[k],\n\t      r[j], m1[j], m2[j], m3[j], k);\n    }\n\n    k = lb;\n    zero3(u[k], m1[k], m2[k], m3[k]);\n    psinv(r[k], u[k], m1[k], m2[k], m3[k], c, k);\n\n    for (k = lb+1; k <= lt-1; k++) {\n\tj = k-1;\n\tzero3(u[k], m1[k], m2[k], m3[k]);\n\tinterp(u[j], m1[j], m2[j], m3[j],\n\t       u[k], m1[k], m2[k], m3[k], k);\n\tresid(u[k], r[k], r[k], m1[k], m2[k], m3[k], a, k);\n\tpsinv(r[k], u[k], m1[k], m2[k], m3[k], c, k);\n    }\n\n    j = lt - 1;\n    k = lt;\n    interp(u[j], m1[j], m2[j], m3[j], u[lt], n1, n2, n3, k);\n    resid(u[lt], v, r[lt], n1, n2, n3, a, k);\n    psinv(r[lt], u[lt], n1, n2, n3, c, k);\n}\n\n\nstatic void psinv( double ***r, double ***u, int n1, int n2, int n3,\n\t\t   double c[4], int k) {\n\n\n\n    int i3, i2, i1;\n    double r1[M], r2[M];\n#pragma omp parallel for default(shared) private(i1,i2,i3,r1,r2)   \n    for (i3 = 1; i3 < n3-1; i3++) {\n\tfor (i2 = 1; i2 < n2-1; i2++) {\n            for (i1 = 0; i1 < n1; i1++) {\n\t\tr1[i1] = r[i3][i2-1][i1] + r[i3][i2+1][i1]\n\t\t    + r[i3-1][i2][i1] + r[i3+1][i2][i1];\n\t\tr2[i1] = r[i3-1][i2-1][i1] + r[i3-1][i2+1][i1]\n\t\t    + r[i3+1][i2-1][i1] + r[i3+1][i2+1][i1];\n\t    }\n            for (i1 = 1; i1 < n1-1; i1++) {\n\t\tu[i3][i2][i1] = u[i3][i2][i1]\n\t\t    + c[0] * r[i3][i2][i1]\n\t\t    + c[1] * ( r[i3][i2][i1-1] + r[i3][i2][i1+1]\n\t\t\t       + r1[i1] )\n\t\t    + c[2] * ( r2[i1] + r1[i1-1] + r1[i1+1] );\n\t    }\n\t}\n    }\n\n    comm3(u,n1,n2,n3,k);\n\n    if (debug_vec[0] >= 1 ) {\n\trep_nrm(u,n1,n2,n3,\"   psinv\",k);\n    }\n\n    if ( debug_vec[3] >= k ) {\n\tshowall(u,n1,n2,n3);\n    }\n}\n\n\nstatic void resid( double ***u, double ***v, double ***r,\n\t\t   int n1, int n2, int n3, double a[4], int k ) {\n\n\n\n    int i3, i2, i1;\n    double u1[M], u2[M];\n#pragma omp parallel for default(shared) private(i1,i2,i3,u1,u2)\n    for (i3 = 1; i3 < n3-1; i3++) {\n\tfor (i2 = 1; i2 < n2-1; i2++) {\n            for (i1 = 0; i1 < n1; i1++) {\n\t\tu1[i1] = u[i3][i2-1][i1] + u[i3][i2+1][i1]\n\t\t       + u[i3-1][i2][i1] + u[i3+1][i2][i1];\n\t\tu2[i1] = u[i3-1][i2-1][i1] + u[i3-1][i2+1][i1]\n\t\t       + u[i3+1][i2-1][i1] + u[i3+1][i2+1][i1];\n\t    }\n\t    for (i1 = 1; i1 < n1-1; i1++) {\n\t\tr[i3][i2][i1] = v[i3][i2][i1]\n\t\t    - a[0] * u[i3][i2][i1]\n\t\t- a[2] * ( u2[i1] + u1[i1-1] + u1[i1+1] )\n\t\t      - a[3] * ( u2[i1-1] + u2[i1+1] );\n\t    }\n\t}\n    }\n\n    comm3(r,n1,n2,n3,k);\n\n    if (debug_vec[0] >= 1 ) {\n\trep_nrm(r,n1,n2,n3,\"   resid\",k);\n    }\n\n    if ( debug_vec[2] >= k ) {\n\tshowall(r,n1,n2,n3);\n    }\n}\n\n\nstatic void rprj3( double ***r, int m1k, int m2k, int m3k,\n\t\t   double ***s, int m1j, int m2j, int m3j, int k ) {\n\n\n\n    int j3, j2, j1, i3, i2, i1, d1, d2, d3;\n\n    double x1[M], y1[M], x2, y2;\n\n\n    if (m1k == 3) {\n        d1 = 2;\n    } else {\n        d1 = 1;\n    }\n\n    if (m2k == 3) {\n        d2 = 2;\n    } else {\n        d2 = 1;\n    }\n\n    if (m3k == 3) {\n        d3 = 2;\n    } else {\n        d3 = 1;\n    }\n#pragma omp parallel for default(shared) private(j1,j2,j3,i1,i2,i3,x1,y1,x2,y2)\n    for (j3 = 1; j3 < m3j-1; j3++) {\n\ti3 = 2*j3-d3;\n\nstatic void interp( double ***z, int mm1, int mm2, int mm3,\n\t\t    double ***u, int n1, int n2, int n3, int k ) {\n\n\n\n    int i3, i2, i1, d1, d2, d3, t1, t2, t3;\n\n    double z1[M], z2[M], z3[M];\n\n    if ( n1 != 3 && n2 != 3 && n3 != 3 ) {\n#pragma omp parallel for default(shared) private(i1,i2,i3,z1,z2,z3)\n\tfor (i3 = 0; i3 < mm3-1; i3++) {\n            for (i2 = 0; i2 < mm2-1; i2++) {\n\t\tfor (i1 = 0; i1 < mm1; i1++) {\n\t\t    z1[i1] = z[i3][i2+1][i1] + z[i3][i2][i1];\n\t\t    z2[i1] = z[i3+1][i2][i1] + z[i3][i2][i1];\n\t\t    z3[i1] = z[i3+1][i2+1][i1] + z[i3+1][i2][i1] + z1[i1];\n\t\t}\n\t\tfor (i1 = 0; i1 < mm1-1; i1++) {\n\t\t    u[2*i3][2*i2][2*i1] = u[2*i3][2*i2][2*i1]\n\t\t\t+z[i3][i2][i1];\n\t\t    u[2*i3][2*i2][2*i1+1] = u[2*i3][2*i2][2*i1+1]\n\t\t\t+0.5*(z[i3][i2][i1+1]+z[i3][i2][i1]);\n\t\t}\n\t\tfor (i1 = 0; i1 < mm1-1; i1++) {\n\t\t    u[2*i3][2*i2+1][2*i1] = u[2*i3][2*i2+1][2*i1]\n\t\t\t+0.5 * z1[i1];\n\t\t    u[2*i3][2*i2+1][2*i1+1] = u[2*i3][2*i2+1][2*i1+1]\n\t\t\t+0.25*( z1[i1] + z1[i1+1] );\n\t\t}\n\t\tfor (i1 = 0; i1 < mm1-1; i1++) {\n\t\t    u[2*i3+1][2*i2][2*i1] = u[2*i3+1][2*i2][2*i1]\n\t\t\t+0.5 * z2[i1];\n\t\t    u[2*i3+1][2*i2][2*i1+1] = u[2*i3+1][2*i2][2*i1+1]\n\t\t\t+0.25*( z2[i1] + z2[i1+1] );\n\t\t}\n\t\tfor (i1 = 0; i1 < mm1-1; i1++) {\n\t\t    u[2*i3+1][2*i2+1][2*i1] = u[2*i3+1][2*i2+1][2*i1]\n\t\t\t+0.25* z3[i1];\n\t\t    u[2*i3+1][2*i2+1][2*i1+1] = u[2*i3+1][2*i2+1][2*i1+1]\n\t\t\t+0.125*( z3[i1] + z3[i1+1] );\n\t\t}\n\t    }\n\t}\n    } else {\n\tif (n1 == 3) {\n            d1 = 2;\n            t1 = 1;\n\t} else {\n            d1 = 1;\n            t1 = 0;\n\t}\n         \n\tif (n2 == 3) {\n            d2 = 2;\n            t2 = 1;\n\t} else {\n            d2 = 1;\n            t2 = 0;\n\t}\n         \n\tif (n3 == 3) {\n            d3 = 2;\n            t3 = 1;\n\t} else {\n            d3 = 1;\n            t3 = 0;\n\t}\n         \n#pragma omp parallel default(shared) private(i1,i2,i3)\n    {\n#pragma omp for\n\tfor ( i3 = d3; i3 <= mm3-1; i3++) {\n            for ( i2 = d2; i2 <= mm2-1; i2++) {\n\t\tfor ( i1 = d1; i1 <= mm1-1; i1++) {\n\t\t    u[2*i3-d3-1][2*i2-d2-1][2*i1-d1-1] =\n\t\t\tu[2*i3-d3-1][2*i2-d2-1][2*i1-d1-1]\n\t\t\t+z[i3-1][i2-1][i1-1];\n\t\t}\n\t\tfor ( i1 = 1; i1 <= mm1-1; i1++) {\n\t\t    u[2*i3-d3-1][2*i2-d2-1][2*i1-t1-1] =\n\t\t\tu[2*i3-d3-1][2*i2-d2-1][2*i1-t1-1]\n\t\t\t+0.5*(z[i3-1][i2-1][i1]+z[i3-1][i2-1][i1-1]);\n\t\t}\n\t    }\n            for ( i2 = 1; i2 <= mm2-1; i2++) {\n\t\tfor ( i1 = d1; i1 <= mm1-1; i1++) {\n\t\t    u[2*i3-d3-1][2*i2-t2-1][2*i1-d1-1] =\n\t\t\tu[2*i3-d3-1][2*i2-t2-1][2*i1-d1-1]\n\t\t\t+0.5*(z[i3-1][i2][i1-1]+z[i3-1][i2-1][i1-1]);\n\t\t}\n\t\tfor ( i1 = 1; i1 <= mm1-1; i1++) {\n\t\t    u[2*i3-d3-1][2*i2-t2-1][2*i1-t1-1] =\n\t\t\tu[2*i3-d3-1][2*i2-t2-1][2*i1-t1-1]\n\t\t\t+0.25*(z[i3-1][i2][i1]+z[i3-1][i2-1][i1]\n\t\t\t       +z[i3-1][i2][i1-1]+z[i3-1][i2-1][i1-1]);\n\t\t}\n\t    }\n\t}\n#pragma omp for nowait\n\tfor ( i3 = 1; i3 <= mm3-1; i3++) {\n            for ( i2 = d2; i2 <= mm2-1; i2++) {\n\t\tfor ( i1 = d1; i1 <= mm1-1; i1++) {\n\t\t    u[2*i3-t3-1][2*i2-d2-1][2*i1-d1-1] =\n\t\t\tu[2*i3-t3-1][2*i2-d2-1][2*i1-d1-1]\n\t\t\t+0.5*(z[i3][i2-1][i1-1]+z[i3-1][i2-1][i1-1]);\n\t\t}\n\t\tfor ( i1 = 1; i1 <= mm1-1; i1++) {\n\t\t    u[2*i3-t3-1][2*i2-d2-1][2*i1-t1-1] =\n\t\t\tu[2*i3-t3-1][2*i2-d2-1][2*i1-t1-1]\n\t\t\t+0.25*(z[i3][i2-1][i1]+z[i3][i2-1][i1-1]\n\t\t\t       +z[i3-1][i2-1][i1]+z[i3-1][i2-1][i1-1]);\n\t\t}\n\t    }\n\t    for ( i2 = 1; i2 <= mm2-1; i2++) {\n\t\tfor ( i1 = d1; i1 <= mm1-1; i1++) {\n\t\t    u[2*i3-t3-1][2*i2-t2-1][2*i1-d1-1] =\n\t\t\tu[2*i3-t3-1][2*i2-t2-1][2*i1-d1-1]\n\t\t\t+0.25*(z[i3][i2][i1-1]+z[i3][i2-1][i1-1]\n\t\t\t       +z[i3-1][i2][i1-1]+z[i3-1][i2-1][i1-1]);\n\t\t}\n\t\tfor ( i1 = 1; i1 <= mm1-1; i1++) {\n\t\t    u[2*i3-t3-1][2*i2-t2-1][2*i1-t1-1] =\n\t\t\tu[2*i3-t3-1][2*i2-t2-1][2*i1-t1-1]\n\t\t\t+0.125*(z[i3][i2][i1]+z[i3][i2-1][i1]\n\t\t\t\t+z[i3][i2][i1-1]+z[i3][i2-1][i1-1]\n\t\t\t\t+z[i3-1][i2][i1]+z[i3-1][i2-1][i1]\n\t\t\t\t+z[i3-1][i2][i1-1]+z[i3-1][i2-1][i1-1]);\n\t\t}\n\t    }\n\t}\n    }\n    }//end #pragma omp parallel\n    if (debug_vec[0] >= 1 ) {\n\trep_nrm(z,mm1,mm2,mm3,\"z: inter\",k-1);\n\trep_nrm(u,n1,n2,n3,\"u: inter\",k);\n    }\n\n    if ( debug_vec[5] >= k ) {\n\tshowall(z,mm1,mm2,mm3);\n\tshowall(u,n1,n2,n3);\n    }\n}\n\n\nstatic void norm2u3(double ***r, int n1, int n2, int n3,\n\t\t    double *rnm2, double *rnmu, int nx, int ny, int nz) {\n\n\n\n    double s = 0.0;\n    int i3, i2, i1, n;\n    double a = 0.0, tmp = 0.0;\n\n    n = nx*ny*nz;\n\n#pragma omp parallel for default(shared) private(i1,i2,i3,a) reduction(+:s) reduction(max:tmp)\n    for (i3 = 1; i3 < n3-1; i3++) {\n\tfor (i2 = 1; i2 < n2-1; i2++) {\n            for (i1 = 1; i1 < n1-1; i1++) {\n\t\ts = s + r[i3][i2][i1] * r[i3][i2][i1];\n\t\ta = fabs(r[i3][i2][i1]);\n\t\tif (a > tmp) tmp = a;\n\t    }\n\t}\n    }\n    *rnmu = tmp;\n\t*rnm2 = sqrt(s/(double)n);\n}\n\n\nstatic void rep_nrm(double ***u, int n1, int n2, int n3,\n\t\t    char *title, int kk) {\n\n\n\n    double rnm2, rnmu;\n\n\n    norm2u3(u,n1,n2,n3,&rnm2,&rnmu,nx[kk],ny[kk],nz[kk]);\n    printf(\" Level%2d in %8s: norms =%21.14e%21.14e\\n\",\n\t   kk, title, rnm2, rnmu);\n}\n\n\nstatic void comm3(double ***u, int n1, int n2, int n3, int kk) {\n\n\n\n    int i1, i2, i3;\n\n    /* axis = 1 */\n    /* axis = 1 */\n#pragma omp parallel default(shared) private(i1,i2,i3)\n{\n#pragma omp for\n    for ( i3 = 1; i3 < n3-1; i3++) {\n\tfor ( i2 = 1; i2 < n2-1; i2++) {\n\t    u[i3][i2][n1-1] = u[i3][i2][1];\n\t    u[i3][i2][0] = u[i3][i2][n1-2];\n\t}\n//    }\n\n    /* axis = 2 */\n    /* axis = 2 */\n//#pragma omp for\n//    for ( i3 = 1; i3 < n3-1; i3++) {\n\tfor ( i1 = 0; i1 < n1; i1++) {\n\t    u[i3][n2-1][i1] = u[i3][1][i1];\n\t    u[i3][0][i1] = u[i3][n2-2][i1];\n\t}\n    }\n\n    /* axis = 3 */\n    /* axis = 3 */\n#pragma omp for nowait\n    for ( i2 = 0; i2 < n2; i2++) {\n\tfor ( i1 = 0; i1 < n1; i1++) {\n\t    u[n3-1][i2][i1] = u[1][i2][i1];\n\t    u[0][i2][i1] = u[n3-2][i2][i1];\n\t}\n    }\n}//end #pragma omp parallel\n}\n\n\nstatic void zran3(double ***z, int n1, int n2, int n3, int nx, int ny, int k) {\n\n\n\n#define MM\t10\n#define\tA\tpow(5.0,13)\n#define\tX\t314159265.e0    \n    \n    int i0, m0, m1;\n    int i1, i2, i3, d1, e1, e2, e3;\n    double xx, x0, x1, a1, a2, ai;\n\n    double ten[MM][2], best;\n    int i, j1[MM][2], j2[MM][2], j3[MM][2];\n    int jg[4][MM][2];\n\n    double rdummy;\n\n    a1 = power( A, nx );\n    a2 = power( A, nx*ny );\n\n    zero3(z,n1,n2,n3);\n\n    i = is1-1+nx*(is2-1+ny*(is3-1));\n\n    ai = power( A, i );\n    d1 = ie1 - is1 + 1;\n    e1 = ie1 - is1 + 2;\n    e2 = ie2 - is2 + 2;\n    e3 = ie3 - is3 + 2;\n    x0 = X;\n    rdummy = randlc( &x0, ai );\n    \n    for (i3 = 1; i3 < e3; i3++) {\n\tx1 = x0;\n\tfor (i2 = 1; i2 < e2; i2++) {\n            xx = x1;\n            vranlc( d1, &xx, A, &(z[i3][i2][0]));\n            rdummy = randlc( &x1, a1 );\n\t}\n\trdummy = randlc( &x0, a2 );\n    }\n\n\n    for (i = 0; i < MM; i++) {\n\tten[i][1] = 0.0;\n\tj1[i][1] = 0;\n\tj2[i][1] = 0;\n\tj3[i][1] = 0;\n\tten[i][0] = 1.0;\n\tj1[i][0] = 0;\n\tj2[i][0] = 0;\n\tj3[i][0] = 0;\n    }\n    for (i3 = 1; i3 < n3-1; i3++) {\n\tfor (i2 = 1; i2 < n2-1; i2++) {\n            for (i1 = 1; i1 < n1-1; i1++) {\n\t\tif ( z[i3][i2][i1] > ten[0][1] ) {\n\t\t    ten[0][1] = z[i3][i2][i1];\n\t\t    j1[0][1] = i1;\n\t\t    j2[0][1] = i2;\n\t\t    j3[0][1] = i3;\n\t\t    bubble( ten, j1, j2, j3, MM, 1 );\n\t\t}\n\t\tif ( z[i3][i2][i1] < ten[0][0] ) {\n\t\t    ten[0][0] = z[i3][i2][i1];\n\t\t    j1[0][0] = i1;\n\t\t    j2[0][0] = i2;\n\t\t    j3[0][0] = i3;\n\t\t    bubble( ten, j1, j2, j3, MM, 0 );\n\t\t}\n\t    }\n\t}\n    }\n\n    i1 = MM - 1;\n    i0 = MM - 1;\n    for (i = MM - 1 ; i >= 0; i--) {\n\tbest = z[j3[i1][1]][j2[i1][1]][j1[i1][1]];\n\tif (best == z[j3[i1][1]][j2[i1][1]][j1[i1][1]]) {\n            jg[0][i][1] = 0;\n            jg[1][i][1] = is1 - 1 + j1[i1][1];\n            jg[2][i][1] = is2 - 1 + j2[i1][1];\n            jg[3][i][1] = is3 - 1 + j3[i1][1];\n            i1 = i1-1;\n\t} else {\n            jg[0][i][1] = 0;\n            jg[1][i][1] = 0;\n            jg[2][i][1] = 0;\n            jg[3][i][1] = 0;\n\t}\n\tten[i][1] = best;\n\tbest = z[j3[i0][0]][j2[i0][0]][j1[i0][0]];\n\tif (best == z[j3[i0][0]][j2[i0][0]][j1[i0][0]]) {\n            jg[0][i][0] = 0;\n            jg[1][i][0] = is1 - 1 + j1[i0][0];\n            jg[2][i][0] = is2 - 1 + j2[i0][0];\n            jg[3][i][0] = is3 - 1 + j3[i0][0];\n            i0 = i0-1;\n\t} else {\n            jg[0][i][0] = 0;\n            jg[1][i][0] = 0;\n            jg[2][i][0] = 0;\n            jg[3][i][0] = 0;\n\t}\n\tten[i][0] = best;\n    }\n    m1 = i1+1;\n    m0 = i0+1;\n\n\n#pragma omp parallel for private(i2, i1)    \n    for (i3 = 0; i3 < n3; i3++) {\n\tfor (i2 = 0; i2 < n2; i2++) {\n            for (i1 = 0; i1 < n1; i1++) {\n\t\tz[i3][i2][i1] = 0.0;\n\t    }\n\t}\n    }\n    for (i = MM-1; i >= m0; i--) {\n\tz[j3[i][0]][j2[i][0]][j1[i][0]] = -1.0;\n    }\n    for (i = MM-1; i >= m1; i--) {\n\tz[j3[i][1]][j2[i][1]][j1[i][1]] = 1.0;\n    } \n    comm3(z,n1,n2,n3,k);\n\n}\n\n\nstatic void showall(double ***z, int n1, int n2, int n3) {\n\n\n    int i1,i2,i3;\n    int m1, m2, m3;\n\n    m1 = min(n1,18);\n    m2 = min(n2,14);\n    m3 = min(n3,18);\n\n    printf(\"\\n\");\n    for (i3 = 0; i3 < m3; i3++) {\n\tfor (i1 = 0; i1 < m1; i1++) {\n\t    for (i2 = 0; i2 < m2; i2++) {\n\t\tprintf(\"%6.3f\", z[i3][i2][i1]);\n\t    }\n\t    printf(\"\\n\");\n\t}\n\tprintf(\" - - - - - - - \\n\");\n    }\n    printf(\"\\n\");\n}\n\n\nstatic double power( double a, int n ) {\n\n\n    double aj;\n    int nj;\n    double rdummy;\n    double power;\n\n    power = 1.0;\n    nj = n;\n    aj = a;\n\n    while (nj != 0) {\n\tif( (nj%2) == 1 ) rdummy =  randlc( &power, aj );\n\trdummy = randlc( &aj, aj );\n\tnj = nj/2;\n    }\n    \n    return (power);\n}\n\n\nstatic void bubble( double ten[M][2], int j1[M][2], int j2[M][2],\n\t\t    int j3[M][2], int m, int ind ) {\n\n\n\n    double temp;\n    int i, j_temp;\n\n    if ( ind == 1 ) {\n\tfor (i = 0; i < m-1; i++) {\n            if ( ten[i][ind] > ten[i+1][ind] ) {\n\n\t\ttemp = ten[i+1][ind];\n\t\tten[i+1][ind] = ten[i][ind];\n\t\tten[i][ind] = temp;\n\n\t\tj_temp = j1[i+1][ind];\n\t\tj1[i+1][ind] = j1[i][ind];\n\t\tj1[i][ind] = j_temp;\n\n\t\tj_temp = j2[i+1][ind];\n\t\tj2[i+1][ind] = j2[i][ind];\n\t\tj2[i][ind] = j_temp;\n\n\t\tj_temp = j3[i+1][ind];\n\t\tj3[i+1][ind] = j3[i][ind];\n\t\tj3[i][ind] = j_temp;\n\t    } else {\n\t\treturn;\n\t    }\n\t}\n    } else {\n\tfor (i = 0; i < m-1; i++) {\n            if ( ten[i][ind] < ten[i+1][ind] ) {\n\n\t\ttemp = ten[i+1][ind];\n\t\tten[i+1][ind] = ten[i][ind];\n\t\tten[i][ind] = temp;\n\n\t\tj_temp = j1[i+1][ind];\n\t\tj1[i+1][ind] = j1[i][ind];\n\t\tj1[i][ind] = j_temp;\n\n\t\tj_temp = j2[i+1][ind];\n\t\tj2[i+1][ind] = j2[i][ind];\n\t\tj2[i][ind] = j_temp;\n\n\t\tj_temp = j3[i+1][ind];\n\t\tj3[i+1][ind] = j3[i][ind];\n\t\tj3[i][ind] = j_temp;\n\t    } else {\n\t\treturn;\n\t    }\n\t}\n    }\n}\n\n\nstatic void zero3(double ***z, int n1, int n2, int n3) {\n\n\n    int i1, i2, i3;\n#pragma omp parallel for private(i1,i2,i3)\n    for (i3 = 0;i3 < n3; i3++) {\n\tfor (i2 = 0; i2 < n2; i2++) {\n            for (i1 = 0; i1 < n1; i1++) {\n\t\tz[i3][i2][i1] = 0.0;\n\t    }\n\t}\n    }\n}\n\n"}]