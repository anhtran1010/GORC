[{"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define N 10000\n#define C 512\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n    for(int j=0; j<N; j++){\n        \n        #pragma omp critical(addlock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        \n        #pragma omp critical(sublock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i] -= 2;\n        }\n        \n        \n    }\n    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!= -N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){    \n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=0; i<N; i++){\n\t\t\t#pragma omp atomic update\n            countervar++;\n        }\n    return 0;\n}\n\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams distribute\n        for (int i=1; i<N; i++){\n            countervar[i]=countervar[i-1]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<N; i++){\n        if(countervar[i]!=i){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define C 4096\n\n\nfloat a;\nfloat x[C];\nfloat y[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        a=5;\n        x[i]=0;\n        y[i]=3;\n    }\n        return 0;\n}\n\n\nint saxpy(){\n    \n    float res;\n    #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) nowait device(0)\n    {\n        for(int i=0; i<C; i++){\n            #pragma omp task depend(inout:x[i])\n            {\n                x[i] = a * x[i];                \n            }\n            #pragma omp task depend(inout:x[i])\n            {\n                x[i] = x[i] + y[i];\n            }\n            res = x[i] + 1;\n        }\n    }        \n    \n    return res;\n}\n\nint main(){\n    init();\n    saxpy();\n\t#pragma omp taskwait\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 512\n\n\nint *a;\nint *b;\nint *c;\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        for(int j=0; j<C; j++){\n            b[j+i*C]=1;\n        }\n        a[i]=1;\n        c[i]=0;\n    }\n        return 0;\n}\n\n\nint Mult(){\n    #pragma omp parallel sections num_threads(2)\n    {\n        #pragma omp target map(to:a[0:C],b[0:C*C]) map(from:c[0:C]) device(0)\n            {\n                #pragma omp teams distribute parallel for\n                for(int i=0; i<C; i++){\n                    for(int j=0; j<C; j++){\n                        c[i]+=b[j+i*C]*a[j];\n                    }\n                }\n            }\n        #pragma omp section\n        #pragma omp parallel num_threads(4)\n            #pragma omp for\n            for(int i=C; i>0; i--){\n                a[i]=3;    \n                #pragma omp target update to(a[i]) device(0)\n            }    \n    }\n    return 0;\n}\n\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(c[i]!=C){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    a = malloc(C*sizeof(int));\n    b = malloc(C*C*sizeof(int));\n    c = malloc(C*sizeof(int));\n    init();\n    omp_set_nested(1);\n    Mult();\n    check();\n    free(a);\n    free(b);\n    free(c);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 100\n#define C 512\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint init(){\n    for(int i=0; i<C; i++){\n        b[i]=0;\n        c[i]=2;\n        temp[i]=0;\n    }\n    a=2;\n    return 0;\n}\n\n\nint add_Mult(){\n#pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n    {\n        #pragma omp teams \n        for(int i =0; i<N; i++){\n        #pragma omp distribute simd\n        {\n            for(int i=0; i<C; i++){\n                temp[i] = b[i] + c[i];\n            }    \n        }\n        #pragma omp distribute simd\n        {\n            for(int i=C; i>0; i--){\n                b[i] = temp[i] * a;\n            }    \n            \n        }\n        }\n    }    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    int val = 0;\n    for(int i=0; i<N; i++){\n        val = val + 2;\n        val = val * 2;\n    }\n    for(int i=0; i<C; i++){\n        if(b[i]!=val){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    add_Mult();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 100\n#define C 512\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint init(){\n    for(int i=0; i<C; i++){\n        b[i]=0;\n        c[i]=2;\n        temp[i]=0;\n    }\n    a=2;\n    return 0;\n}\n\n\nint add_Mult(){\n#pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n#pragma omp parallel\n    {\n        for(int i=0; i<N; i++){\n        #pragma omp for nowait\n            for(int i=0; i<C; i++){\n                temp[i] = b[i] + c[i];\n            }    \n        \n        #pragma omp for nowait\n            for(int i=C; i>0; i--){\n                b[i] = temp[i] * a;\n            }    \n        }    \n    }    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    int val = 0;\n    for(int i=0; i<N; i++){\n        val = val + 2;\n        val = val * 2;\n    }\n    for(int i=0; i<C; i++){\n        if(b[i]!=val){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    add_Mult();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=1; i<N; i++){\n            countervar[i]=countervar[i-1]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<N; i++){\n        if(countervar[i]!=i){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n\t#pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n\t\t\t#pragma omp atomic update\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100000\n\nint countervar = 0;\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n    for(int i=0; i<N; i++){\n        \n        #pragma omp critical(addlock)\n        countervar++;\n        \n        \n        #pragma omp critical(sublock)\n        countervar -= 2;\n        \n        \n    }\n    \n    return 0;\n}\n\nint main(){\n    \n\n    count();\n    printf(\"counter: %i expected: -%i\\n\",countervar,N);\n    \n    return countervar;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n#define C 16\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams distribute simd safelen(C)\n        for (int i=C; i<N; i++){\n            countervar[i]=countervar[i-C]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=C; i<N; i++){\n        if(countervar[i]!=i-C+1){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n#define C 16\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for simd safelen(C)\n        for (int i=C; i<N; i++){\n            countervar[i]=countervar[i-C]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=C; i<N; i++){\n        if(countervar[i]!=i-C+1){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n#define C 16\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams distribute parallel for simd safelen(C)\n        for (int i=C; i<N; i++){\n            countervar[i]=countervar[i-C]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=C; i<N; i++){\n        if(countervar[i]!=i-C+1){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100000\n\nint countervar = 0;\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute\n    for(int i=0; i<N; i++){\n        \n        #pragma omp critical(addlock)\n        countervar++;\n        \n        \n        #pragma omp critical(sublock)\n        countervar -= 2;\n        \n        \n    }\n    \n    return 0;\n}\n\nint main(){\n    \n\n    count();\n    \n    printf(\"counter: %i expected: -%i\\n\",countervar,N);\n    return countervar;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint countervar = 0;\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams\n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n\n    #pragma omp distribute parallel for\n    for(int i=0; i<N; i++){\n        \n        omp_set_lock(&addlock);\n        countervar++;\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        countervar -= 2;\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint main(){\n    \n    \n    \n    count();\n    printf(\"counter: %i expected: -%i\\n \",countervar,N);\n    \n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=0; i<N*2; i++){\n            if(countervar<N){\n                #pragma omp atomic\n                countervar++;\n            }\n        }\n    return 0;\n}\n\n\nint main(){\n    count();\n    printf(\"counter: %i expected: %i\\n \",countervar,N);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100000\n\nint countervar = 0;\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for\n    for(int i=0; i<N; i++){\n        \n        #pragma omp critical(addlock)\n        countervar++;\n        \n        \n        #pragma omp critical(sublock)\n        countervar -= 2;\n        \n        \n    }\n    \n    return 0;\n}\n\nint main(){\n    \n\n    count();\n    printf(\"counter: %i expected: -%i\\n\",countervar,N);\n    \n    return countervar;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint countervar = 0;\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\n\n\nint count(){\n    printf(\"start \\n\");\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams num_teams(1)\n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n    #pragma omp distribute parallel for\n    for(int i=0; i<N; i++){\n        \n        omp_set_lock(&addlock);\n        countervar++;\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        countervar -= 2;\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint main(){\n    \n    \n    \n    count();\n    printf(\"counter: %i expected: -%i\\n \",countervar,N);\n    \n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n#define N 100\n#define C 512\n\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams \n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n    #pragma omp distribute\n    for(int j=0; j<N; j++){\n        \n        omp_set_lock(&addlock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]-=2;\n        }\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=-N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    \n    init();\n    \n    \n    \n    count();\n    check();\n    \n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 64\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=0; i<N; i++){\n            #pragma omp simd\n            for(int i=0; i<C; i++){\n                countervar[i]++;\n            }\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=100000){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 64\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams distribute\n        for (int i=0; i<N; i++){\n            #pragma omp simd\n            for(int i=0; i<C; i++){\n                countervar[i]++;\n            }\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=100000){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 64\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n            #pragma omp simd\n            for(int i=0; i<C; i++){\n                countervar[i]++;\n            }\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=100000){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint countervar = 0;\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams \n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n    #pragma omp distribute\n    for(int i=0; i<N; i++){\n        \n        omp_set_lock(&addlock);\n        countervar++;\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        countervar -= 2;\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint main(){\n    \n    \n    \n    count();\n    printf(\"counter: %i expected: -%i\\n \",countervar,N);\n    \n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n#define N 100\n#define C 512\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams num_teams(1)\n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n    #pragma omp distribute parallel for\n    for(int j=0; j<N; j++){\n        \n        omp_set_lock(&addlock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]-=2;\n        }\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=-N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    \n    init();\n    \n    \n    \n    count();\n    check();\n    \n    return 0;\n}"}, {"prompt": "#include <stdio.h>   \n#include <stdlib.h> \n#include <stdbool.h>\n#include <stdint.h>\n#define C 51200L\n\n\nint64_t *a;\nint64_t *b;\nint64_t *c;\n\n\nint init(){\n    for(int64_t i=0; i<C; i++){\n        for(int64_t j=0; j<C; j++){\n            a[j+i*C]=1;\n            b[j+i*C]=1;\n            c[j+i*C]=0;\n        }\n        \n    }\n        return 0;\n}\n\n\nint add(){\n    #pragma omp target map(to:a[0:C*C],b[0:C*C]) map(from:c[0:C*C]) device(0)\n    {\n        // #pragma omp teams\n        // printf(\"Executed on host: %s\\n\",omp_is_initial_device() ? \"true\" : \"false\");\n        #pragma omp teams distribute parallel for collapse(2)\n        for(int64_t i=0; i<C; i++){\n            for(int64_t j=0; j<C; j++){\n                c[j+i*C]=b[j+i*C] + a[j+i*C];\n            }\n        }\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int64_t i=0; i<C*C; i++){\n        if(c[i]!=2){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    a = (int64_t *) malloc(C*C*sizeof(int64_t));\n    b = (int64_t *) malloc(C*C*sizeof(int64_t));\n    c = (int64_t *) malloc(C*C*sizeof(int64_t));\n    init();\n    add();\n    check();\n    free(a);\n    free(b);\n    free(c);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 64\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams num_teams(1) thread_limit(1048)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n            #pragma omp simd\n            for(int i=0; i<C; i++){\n                countervar[i]++;\n            }\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for reduction(+:countervar)\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define N 100000\n#define C 512\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams distribute\n    for(int j=0; j<N; j++){\n        \n        #pragma omp critical(addlock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        \n        #pragma omp critical(sublock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i] -= 2;\n        }\n        \n        \n    }\n    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!= -N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){    \n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=1; i<N; i++){\n            countervar[i]=countervar[i-1]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<N; i++){\n        if(countervar[i]!=i){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams num_teams(1) thread_limit(1048)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: %i\\n\",countervar,N);\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 512\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams distribute parallel for\n    for(int j=0; j<N; j++){\n        \n        #pragma omp critical(addlock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        \n        #pragma omp critical(sublock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i] -= 2;\n        }\n        \n        \n    }\n    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=-N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){    \n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n\t#pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n\t\t\t#pragma omp critical\n            countervar++;\n\t\t\t\n\t\t\t#pragma omp critical\n\t\t\tcountervar -= 2;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: -100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#define C 512\n\n\nint *a;\nint *b;\nint *c;\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        for(int j=0; j<C; j++){\n            b[j+i*C]=1;\n        }\n        a[i]=1;\n        c[i]=0;\n    }\n        return 0;\n}\n\n\nint Mult(){\n\t#pragma omp target map(to:a[0:C],b[0:C*C]) map(from:c[0:C])\n    #pragma omp teams distribute parallel for\n    for(int i=0; i<C; i++){\n        for(int j=0; j<C; j++){\n            c[i]+=b[j+i*C]*a[j];\n        }\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(c[i]!=C){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    a = malloc(C*sizeof(int));\n    b = malloc(C*C*sizeof(int));\n    c = malloc(C*sizeof(int));\n    init();\n    Mult();\n    check();\n    free(a);\n    free(b);\n    free(c);\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n#define N 100\n#define C 512\n\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams\n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);    \n    #pragma omp distribute parallel for\n    for(int j=0; j<N; j++){\n        \n        omp_set_lock(&addlock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]-=2;\n        }\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=-N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    \n    init();\n    \n    \n    \n    count();\n    check();\n    \n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define C 20000\n\n\nfloat a;\nfloat x[C];\nfloat y[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        a=5;\n        x[i]=0;\n        y[i]=3;\n    }\n        return 0;\n}\n\n\nint saxpy(){\n    \n    #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) device(0)\n    {\n        #pragma omp teams distribute        \n        for(int i=0; i<C; i++){\n            #pragma omp task \n            {\n                x[i] = a * x[i];                \n            }\n            #pragma omp task \n            {\n                x[i] = x[i] + y[i];\n            }\n        }\n        \n    }        \n    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(x[i]!=3){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    saxpy();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute\n        for (int i=0; i<N; i++){\n\t\t\t#pragma omp atomic update\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 100\n#define C 512\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint init(){\n    for(int i=0; i<C; i++){\n        b[i]=0;\n        c[i]=2;\n        temp[i]=0;\n    }\n    a=2;\n    return 0;\n}\n\n\nint add_Mult(){\n#pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n    {\n        #pragma omp teams \n        for(int i=0; i<N ;i++){\n            #pragma omp distribute\n            for(int i=0; i<C; i++){\n                temp[i] = b[i] + c[i];\n            }    \n        \n            #pragma omp distribute\n            for(int i=C; i>0; i--){\n                b[i] = temp[i] * a;\n            }    \n        \n        }\n        \n    }    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    int val = 0;\n    for(int i=0; i<N; i++){\n        val = val + 2;\n        val = val * 2;\n    }\n    for(int i=0; i<C; i++){\n        if(b[i]!=val){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    add_Mult();\n    check();\n    return 0;\n}"}]