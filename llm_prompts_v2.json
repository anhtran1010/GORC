[{"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define N 10000\n#define C 512\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n    for(int j=0; j<N; j++){\n        \n        #pragma omp critical(addlock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        \n        #pragma omp critical(sublock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i] -= 2;\n        }\n        \n        \n    }\n    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!= -N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){    \n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=0; i<N; i++){\n\t\t\t#pragma omp atomic update\n            countervar++;\n        }\n    return 0;\n}\n\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams distribute\n        for (int i=1; i<N; i++){\n            countervar[i]=countervar[i-1]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<N; i++){\n        if(countervar[i]!=i){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define C 4096\n\n\nfloat a;\nfloat x[C];\nfloat y[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        a=5;\n        x[i]=0;\n        y[i]=3;\n    }\n        return 0;\n}\n\n\nint saxpy(){\n    \n    float res;\n    #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) nowait device(0)\n    {\n        for(int i=0; i<C; i++){\n            #pragma omp task depend(inout:x[i])\n            {\n                x[i] = a * x[i];                \n            }\n            #pragma omp task depend(inout:x[i])\n            {\n                x[i] = x[i] + y[i];\n            }\n            res = x[i] + 1;\n        }\n    }        \n    \n    return res;\n}\n\nint main(){\n    init();\n    saxpy();\n\t#pragma omp taskwait\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 512\n\n\nint *a;\nint *b;\nint *c;\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        for(int j=0; j<C; j++){\n            b[j+i*C]=1;\n        }\n        a[i]=1;\n        c[i]=0;\n    }\n        return 0;\n}\n\n\nint Mult(){\n    #pragma omp parallel sections num_threads(2)\n    {\n        #pragma omp target map(to:a[0:C],b[0:C*C]) map(from:c[0:C]) device(0)\n            {\n                #pragma omp teams distribute parallel for\n                for(int i=0; i<C; i++){\n                    for(int j=0; j<C; j++){\n                        c[i]+=b[j+i*C]*a[j];\n                    }\n                }\n            }\n        #pragma omp section\n        #pragma omp parallel num_threads(4)\n            #pragma omp for\n            for(int i=C; i>0; i--){\n                a[i]=3;    \n                #pragma omp target update to(a[i]) device(0)\n            }    \n    }\n    return 0;\n}\n\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(c[i]!=C){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    a = malloc(C*sizeof(int));\n    b = malloc(C*C*sizeof(int));\n    c = malloc(C*sizeof(int));\n    init();\n    omp_set_nested(1);\n    Mult();\n    check();\n    free(a);\n    free(b);\n    free(c);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 100\n#define C 512\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint init(){\n    for(int i=0; i<C; i++){\n        b[i]=0;\n        c[i]=2;\n        temp[i]=0;\n    }\n    a=2;\n    return 0;\n}\n\n\nint add_Mult(){\n#pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n    {\n        #pragma omp teams \n        for(int i =0; i<N; i++){\n        #pragma omp distribute simd\n        {\n            for(int i=0; i<C; i++){\n                temp[i] = b[i] + c[i];\n            }    \n        }\n        #pragma omp distribute simd\n        {\n            for(int i=C; i>0; i--){\n                b[i] = temp[i] * a;\n            }    \n            \n        }\n        }\n    }    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    int val = 0;\n    for(int i=0; i<N; i++){\n        val = val + 2;\n        val = val * 2;\n    }\n    for(int i=0; i<C; i++){\n        if(b[i]!=val){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    add_Mult();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 100\n#define C 512\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint init(){\n    for(int i=0; i<C; i++){\n        b[i]=0;\n        c[i]=2;\n        temp[i]=0;\n    }\n    a=2;\n    return 0;\n}\n\n\nint add_Mult(){\n#pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n#pragma omp parallel\n    {\n        for(int i=0; i<N; i++){\n        #pragma omp for nowait\n            for(int i=0; i<C; i++){\n                temp[i] = b[i] + c[i];\n            }    \n        \n        #pragma omp for nowait\n            for(int i=C; i>0; i--){\n                b[i] = temp[i] * a;\n            }    \n        }    \n    }    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    int val = 0;\n    for(int i=0; i<N; i++){\n        val = val + 2;\n        val = val * 2;\n    }\n    for(int i=0; i<C; i++){\n        if(b[i]!=val){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    add_Mult();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=1; i<N; i++){\n            countervar[i]=countervar[i-1]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<N; i++){\n        if(countervar[i]!=i){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n\t#pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n\t\t\t#pragma omp atomic update\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100000\n\nint countervar = 0;\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n    for(int i=0; i<N; i++){\n        \n        #pragma omp critical(addlock)\n        countervar++;\n        \n        \n        #pragma omp critical(sublock)\n        countervar -= 2;\n        \n        \n    }\n    \n    return 0;\n}\n\nint main(){\n    \n\n    count();\n    printf(\"counter: %i expected: -%i\\n\",countervar,N);\n    \n    return countervar;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n#define C 16\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams distribute simd safelen(C)\n        for (int i=C; i<N; i++){\n            countervar[i]=countervar[i-C]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=C; i<N; i++){\n        if(countervar[i]!=i-C+1){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n#define C 16\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for simd safelen(C)\n        for (int i=C; i<N; i++){\n            countervar[i]=countervar[i-C]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=C; i<N; i++){\n        if(countervar[i]!=i-C+1){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n#define C 16\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams distribute parallel for simd safelen(C)\n        for (int i=C; i<N; i++){\n            countervar[i]=countervar[i-C]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=C; i<N; i++){\n        if(countervar[i]!=i-C+1){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100000\n\nint countervar = 0;\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute\n    for(int i=0; i<N; i++){\n        \n        #pragma omp critical(addlock)\n        countervar++;\n        \n        \n        #pragma omp critical(sublock)\n        countervar -= 2;\n        \n        \n    }\n    \n    return 0;\n}\n\nint main(){\n    \n\n    count();\n    \n    printf(\"counter: %i expected: -%i\\n\",countervar,N);\n    return countervar;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint countervar = 0;\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams\n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n\n    #pragma omp distribute parallel for\n    for(int i=0; i<N; i++){\n        \n        omp_set_lock(&addlock);\n        countervar++;\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        countervar -= 2;\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint main(){\n    \n    \n    \n    count();\n    printf(\"counter: %i expected: -%i\\n \",countervar,N);\n    \n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=0; i<N*2; i++){\n            if(countervar<N){\n                #pragma omp atomic\n                countervar++;\n            }\n        }\n    return 0;\n}\n\n\nint main(){\n    count();\n    printf(\"counter: %i expected: %i\\n \",countervar,N);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100000\n\nint countervar = 0;\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for\n    for(int i=0; i<N; i++){\n        \n        #pragma omp critical(addlock)\n        countervar++;\n        \n        \n        #pragma omp critical(sublock)\n        countervar -= 2;\n        \n        \n    }\n    \n    return 0;\n}\n\nint main(){\n    \n\n    count();\n    printf(\"counter: %i expected: -%i\\n\",countervar,N);\n    \n    return countervar;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint countervar = 0;\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\n\n\nint count(){\n    printf(\"start \\n\");\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams num_teams(1)\n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n    #pragma omp distribute parallel for\n    for(int i=0; i<N; i++){\n        \n        omp_set_lock(&addlock);\n        countervar++;\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        countervar -= 2;\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint main(){\n    \n    \n    \n    count();\n    printf(\"counter: %i expected: -%i\\n \",countervar,N);\n    \n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n#define N 100\n#define C 512\n\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams \n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n    #pragma omp distribute\n    for(int j=0; j<N; j++){\n        \n        omp_set_lock(&addlock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]-=2;\n        }\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=-N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    \n    init();\n    \n    \n    \n    count();\n    check();\n    \n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 64\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=0; i<N; i++){\n            #pragma omp simd\n            for(int i=0; i<C; i++){\n                countervar[i]++;\n            }\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=100000){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 64\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams distribute\n        for (int i=0; i<N; i++){\n            #pragma omp simd\n            for(int i=0; i<C; i++){\n                countervar[i]++;\n            }\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=100000){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 64\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n            #pragma omp simd\n            for(int i=0; i<C; i++){\n                countervar[i]++;\n            }\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=100000){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint countervar = 0;\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams \n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n    #pragma omp distribute\n    for(int i=0; i<N; i++){\n        \n        omp_set_lock(&addlock);\n        countervar++;\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        countervar -= 2;\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint main(){\n    \n    \n    \n    count();\n    printf(\"counter: %i expected: -%i\\n \",countervar,N);\n    \n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n#define N 100\n#define C 512\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams num_teams(1)\n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n    #pragma omp distribute parallel for\n    for(int j=0; j<N; j++){\n        \n        omp_set_lock(&addlock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]-=2;\n        }\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=-N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    \n    init();\n    \n    \n    \n    count();\n    check();\n    \n    return 0;\n}"}, {"prompt": "#include <stdio.h>   \n#include <stdlib.h> \n#include <stdbool.h>\n#include <stdint.h>\n#define C 51200L\n\n\nint64_t *a;\nint64_t *b;\nint64_t *c;\n\n\nint init(){\n    for(int64_t i=0; i<C; i++){\n        for(int64_t j=0; j<C; j++){\n            a[j+i*C]=1;\n            b[j+i*C]=1;\n            c[j+i*C]=0;\n        }\n        \n    }\n        return 0;\n}\n\n\nint add(){\n    #pragma omp target map(to:a[0:C*C],b[0:C*C]) map(from:c[0:C*C]) device(0)\n    {\n        // #pragma omp teams\n        // printf(\"Executed on host: %s\\n\",omp_is_initial_device() ? \"true\" : \"false\");\n        #pragma omp teams distribute parallel for collapse(2)\n        for(int64_t i=0; i<C; i++){\n            for(int64_t j=0; j<C; j++){\n                c[j+i*C]=b[j+i*C] + a[j+i*C];\n            }\n        }\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int64_t i=0; i<C*C; i++){\n        if(c[i]!=2){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    a = (int64_t *) malloc(C*C*sizeof(int64_t));\n    b = (int64_t *) malloc(C*C*sizeof(int64_t));\n    c = (int64_t *) malloc(C*C*sizeof(int64_t));\n    init();\n    add();\n    check();\n    free(a);\n    free(b);\n    free(c);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 64\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams num_teams(1) thread_limit(1048)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n            #pragma omp simd\n            for(int i=0; i<C; i++){\n                countervar[i]++;\n            }\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for reduction(+:countervar)\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define N 100000\n#define C 512\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams distribute\n    for(int j=0; j<N; j++){\n        \n        #pragma omp critical(addlock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        \n        #pragma omp critical(sublock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i] -= 2;\n        }\n        \n        \n    }\n    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!= -N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){    \n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=1; i<N; i++){\n            countervar[i]=countervar[i-1]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<N; i++){\n        if(countervar[i]!=i){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams num_teams(1) thread_limit(1048)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: %i\\n\",countervar,N);\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 512\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams distribute parallel for\n    for(int j=0; j<N; j++){\n        \n        #pragma omp critical(addlock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        \n        #pragma omp critical(sublock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i] -= 2;\n        }\n        \n        \n    }\n    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=-N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){    \n    init();\n    count();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n\t#pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n\t\t\t#pragma omp critical\n            countervar++;\n\t\t\t\n\t\t\t#pragma omp critical\n\t\t\tcountervar -= 2;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: -100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#define C 512\n\n\nint *a;\nint *b;\nint *c;\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        for(int j=0; j<C; j++){\n            b[j+i*C]=1;\n        }\n        a[i]=1;\n        c[i]=0;\n    }\n        return 0;\n}\n\n\nint Mult(){\n\t#pragma omp target map(to:a[0:C],b[0:C*C]) map(from:c[0:C])\n    #pragma omp teams distribute parallel for\n    for(int i=0; i<C; i++){\n        for(int j=0; j<C; j++){\n            c[i]+=b[j+i*C]*a[j];\n        }\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(c[i]!=C){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    a = malloc(C*sizeof(int));\n    b = malloc(C*C*sizeof(int));\n    c = malloc(C*sizeof(int));\n    init();\n    Mult();\n    check();\n    free(a);\n    free(b);\n    free(c);\n    return 0;\n}"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n#define N 100\n#define C 512\n\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams\n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);    \n    #pragma omp distribute parallel for\n    for(int j=0; j<N; j++){\n        \n        omp_set_lock(&addlock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]-=2;\n        }\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=-N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    \n    init();\n    \n    \n    \n    count();\n    check();\n    \n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define C 20000\n\n\nfloat a;\nfloat x[C];\nfloat y[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        a=5;\n        x[i]=0;\n        y[i]=3;\n    }\n        return 0;\n}\n\n\nint saxpy(){\n    \n    #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) device(0)\n    {\n        #pragma omp teams distribute        \n        for(int i=0; i<C; i++){\n            #pragma omp task \n            {\n                x[i] = a * x[i];                \n            }\n            #pragma omp task \n            {\n                x[i] = x[i] + y[i];\n            }\n        }\n        \n    }        \n    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(x[i]!=3){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    saxpy();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute\n        for (int i=0; i<N; i++){\n\t\t\t#pragma omp atomic update\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}"}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 100\n#define C 512\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint init(){\n    for(int i=0; i<C; i++){\n        b[i]=0;\n        c[i]=2;\n        temp[i]=0;\n    }\n    a=2;\n    return 0;\n}\n\n\nint add_Mult(){\n#pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n    {\n        #pragma omp teams \n        for(int i=0; i<N ;i++){\n            #pragma omp distribute\n            for(int i=0; i<C; i++){\n                temp[i] = b[i] + c[i];\n            }    \n        \n            #pragma omp distribute\n            for(int i=C; i>0; i--){\n                b[i] = temp[i] * a;\n            }    \n        \n        }\n        \n    }    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    int val = 0;\n    for(int i=0; i<N; i++){\n        val = val + 2;\n        val = val * 2;\n    }\n    for(int i=0; i<C; i++){\n        if(b[i]!=val){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    add_Mult();\n    check();\n    return 0;\n}"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf(\"a[50]=%d\\n\", a[50]);   \n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 20x1000. */\n#include \"polybench/jacobi-2d-imper.h\"\n/* Array initialization. */\n\nstatic void init_array(int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c1;\n    int c2;\n    int c4;\n    int c3;\n    if (n >= 1) {\n#pragma omp parallel for private(c3, c4, c2)\n      for (c1 = 0; c1 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n          for (c3 = 16 * c2; c3 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c1; c4 <= ((16 * c1 + 15 < n + -1?16 * c1 + 15 : n + -1)); c4++) {\n              A[c4][c3] = (((double )c4) * (c3 + 2) + 2) / n;\n              B[c4][c3] = (((double )c4) * (c3 + 3) + 3) / n;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int n,double A[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",A[i][j]);\n      if ((i * n + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_jacobi_2d_imper(int tsteps,int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int t;\n  //int i;\n  //int j;\n  \n  //#pragma scop\n{\n    int c0;\n    int c1;\n    int c3;\n    int c2;\n    int c4;\n    int c5;\n    if (n >= 3 && tsteps >= 1) {\n      for (c0 = 0; c0 <= (((n + 3 * tsteps + -4) * 16 < 0?((16 < 0?-((-(n + 3 * tsteps + -4) + 16 + 1) / 16) : -((-(n + 3 * tsteps + -4) + 16 - 1) / 16))) : (n + 3 * tsteps + -4) / 16)); c0++) {\n#pragma omp parallel for private(c5, c4, c2, c3)\n        for (c1 = (((2 * c0 * 3 < 0?-(-(2 * c0) / 3) : ((3 < 0?(-(2 * c0) + - 3 - 1) / - 3 : (2 * c0 + 3 - 1) / 3)))) > (((16 * c0 + -1 * tsteps + 1) * 16 < 0?-(-(16 * c0 + -1 * tsteps + 1) / 16) : ((16 < 0?(-(16 * c0 + -1 * tsteps + 1) + - 16 - 1) / - 16 : (16 * c0 + -1 * tsteps + 1 + 16 - 1) / 16))))?((2 * c0 * 3 < 0?-(-(2 * c0) / 3) : ((3 < 0?(-(2 * c0) + - 3 - 1) / - 3 : (2 * c0 + 3 - 1) / 3)))) : (((16 * c0 + -1 * tsteps + 1) * 16 < 0?-(-(16 * c0 + -1 * tsteps + 1) / 16) : ((16 < 0?(-(16 * c0 + -1 * tsteps + 1) + - 16 - 1) / - 16 : (16 * c0 + -1 * tsteps + 1 + 16 - 1) / 16))))); c1 <= (((((((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) < (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48))?(((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) : (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48)))) < c0?(((((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) < (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48))?(((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) : (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48)))) : c0)); c1++) {\n          for (c2 = ((((16 * c1 + -1 * n + -12) * 16 < 0?-(-(16 * c1 + -1 * n + -12) / 16) : ((16 < 0?(-(16 * c1 + -1 * n + -12) + - 16 - 1) / - 16 : (16 * c1 + -1 * n + -12 + 16 - 1) / 16)))) > 2 * c0 + -2 * c1?(((16 * c1 + -1 * n + -12) * 16 < 0?-(-(16 * c1 + -1 * n + -12) / 16) : ((16 < 0?(-(16 * c1 + -1 * n + -12) + - 16 - 1) / - 16 : (16 * c1 + -1 * n + -12 + 16 - 1) / 16)))) : 2 * c0 + -2 * c1); c2 <= (((((((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) < (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16))?(((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) : (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)))) < (((32 * c0 + -32 * c1 + n + 29) * 16 < 0?((16 < 0?-((-(32 * c0 + -32 * c1 + n + 29) + 16 + 1) / 16) : -((-(32 * c0 + -32 * c1 + n + 29) + 16 - 1) / 16))) : (32 * c0 + -32 * c1 + n + 29) / 16))?(((((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) < (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16))?(((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) : (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)))) : (((32 * c0 + -32 * c1 + n + 29) * 16 < 0?((16 < 0?-((-(32 * c0 + -32 * c1 + n + 29) + 16 + 1) / 16) : -((-(32 * c0 + -32 * c1 + n + 29) + 16 - 1) / 16))) : (32 * c0 + -32 * c1 + n + 29) / 16)))); c2++) {\n            if (c0 <= (((32 * c1 + 16 * c2 + -1 * n + 1) * 32 < 0?((32 < 0?-((-(32 * c1 + 16 * c2 + -1 * n + 1) + 32 + 1) / 32) : -((-(32 * c1 + 16 * c2 + -1 * n + 1) + 32 - 1) / 32))) : (32 * c1 + 16 * c2 + -1 * n + 1) / 32)) && c1 <= c2 + -1) {\n              if ((n + 1) % 2 == 0) {\n                for (c4 = (16 * c1 > 16 * c2 + -1 * n + 3?16 * c1 : 16 * c2 + -1 * n + 3); c4 <= 16 * c1 + 15; c4++) {\n                  A[-16 * c2 + c4 + n + -2][n + -2] = B[-16 * c2 + c4 + n + -2][n + -2];\n                }\n              }\n            }\n            if (c0 <= (((48 * c1 + -1 * n + 1) * 32 < 0?((32 < 0?-((-(48 * c1 + -1 * n + 1) + 32 + 1) / 32) : -((-(48 * c1 + -1 * n + 1) + 32 - 1) / 32))) : (48 * c1 + -1 * n + 1) / 32)) && c1 >= c2) {\n              if ((n + 1) % 2 == 0) {\n                for (c5 = (16 * c2 > 16 * c1 + -1 * n + 3?16 * c2 : 16 * c1 + -1 * n + 3); c5 <= ((16 * c1 < 16 * c2 + 15?16 * c1 : 16 * c2 + 15)); c5++) {\n                  A[n + -2][-16 * c1 + c5 + n + -2] = B[n + -2][-16 * c1 + c5 + n + -2];\n                }\n              }\n            }\n            for (c3 = ((((((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) > (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2))))?(((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) : (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2)))))) > 16 * c0 + -16 * c1?(((((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) > (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2))))?(((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) : (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2)))))) : 16 * c0 + -16 * c1); c3 <= ((((((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) < tsteps + -1?((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) : tsteps + -1)) < 16 * c0 + -16 * c1 + 15?((((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) < tsteps + -1?((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) : tsteps + -1)) : 16 * c0 + -16 * c1 + 15)); c3++) {\n              if (c1 <= ((c3 * 8 < 0?((8 < 0?-((-c3 + 8 + 1) / 8) : -((-c3 + 8 - 1) / 8))) : c3 / 8))) {\n                for (c5 = (16 * c2 > 2 * c3 + 1?16 * c2 : 2 * c3 + 1); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -2?16 * c2 + 15 : 2 * c3 + n + -2)); c5++) {\n                  B[1][-2 * c3 + c5] = 0.2 * (A[1][-2 * c3 + c5] + A[1][-2 * c3 + c5 - 1] + A[1][1 + (-2 * c3 + c5)] + A[1 + 1][-2 * c3 + c5] + A[1 - 1][-2 * c3 + c5]);\n                }\n              }\n              for (c4 = (16 * c1 > 2 * c3 + 2?16 * c1 : 2 * c3 + 2); c4 <= ((16 * c1 + 15 < 2 * c3 + n + -2?16 * c1 + 15 : 2 * c3 + n + -2)); c4++) {\n                if (c2 <= ((c3 * 8 < 0?((8 < 0?-((-c3 + 8 + 1) / 8) : -((-c3 + 8 - 1) / 8))) : c3 / 8))) {\n                  B[-2 * c3 + c4][1] = 0.2 * (A[-2 * c3 + c4][1] + A[-2 * c3 + c4][1 - 1] + A[-2 * c3 + c4][1 + 1] + A[1 + (-2 * c3 + c4)][1] + A[-2 * c3 + c4 - 1][1]);\n                }\n                for (c5 = (16 * c2 > 2 * c3 + 2?16 * c2 : 2 * c3 + 2); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -2?16 * c2 + 15 : 2 * c3 + n + -2)); c5++) {\n                  B[-2 * c3 + c4][-2 * c3 + c5] = 0.2 * (A[-2 * c3 + c4][-2 * c3 + c5] + A[-2 * c3 + c4][-2 * c3 + c5 - 1] + A[-2 * c3 + c4][1 + (-2 * c3 + c5)] + A[1 + (-2 * c3 + c4)][-2 * c3 + c5] + A[-2 * c3 + c4 - 1][-2 * c3 + c5]);\n                  A[-2 * c3 + c4 + -1][-2 * c3 + c5 + -1] = B[-2 * c3 + c4 + -1][-2 * c3 + c5 + -1];\n                }\n                if (c2 >= (((2 * c3 + n + -16) * 16 < 0?-(-(2 * c3 + n + -16) / 16) : ((16 < 0?(-(2 * c3 + n + -16) + - 16 - 1) / - 16 : (2 * c3 + n + -16 + 16 - 1) / 16))))) {\n                  A[-2 * c3 + c4 + -1][n + -2] = B[-2 * c3 + c4 + -1][n + -2];\n                }\n              }\n              if (c1 >= (((2 * c3 + n + -16) * 16 < 0?-(-(2 * c3 + n + -16) / 16) : ((16 < 0?(-(2 * c3 + n + -16) + - 16 - 1) / - 16 : (2 * c3 + n + -16 + 16 - 1) / 16))))) {\n                for (c5 = (16 * c2 > 2 * c3 + 2?16 * c2 : 2 * c3 + 2); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -1?16 * c2 + 15 : 2 * c3 + n + -1)); c5++) {\n                  A[n + -2][-2 * c3 + c5 + -1] = B[n + -2][-2 * c3 + c5 + -1];\n                }\n              }\n            }\n            if (c0 >= (((2 * c1 + c2 + -1) * 2 < 0?-(-(2 * c1 + c2 + -1) / 2) : ((2 < 0?(-(2 * c1 + c2 + -1) + - 2 - 1) / - 2 : (2 * c1 + c2 + -1 + 2 - 1) / 2)))) && c1 >= c2 + 1 && c2 <= (((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8))) {\n              for (c4 = 16 * c1; c4 <= ((16 * c1 + 15 < 16 * c2 + n + 12?16 * c1 + 15 : 16 * c2 + n + 12)); c4++) {\n                B[-16 * c2 + c4 + -14][1] = 0.2 * (A[-16 * c2 + c4 + -14][1] + A[-16 * c2 + c4 + -14][1 - 1] + A[-16 * c2 + c4 + -14][1 + 1] + A[1 + (-16 * c2 + c4 + -14)][1] + A[-16 * c2 + c4 + -14 - 1][1]);\n              }\n            }\n            if (c0 >= (((3 * c1 + -1) * 2 < 0?-(-(3 * c1 + -1) / 2) : ((2 < 0?(-(3 * c1 + -1) + - 2 - 1) / - 2 : (3 * c1 + -1 + 2 - 1) / 2)))) && c1 <= (((((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8)) < c2?(((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8)) : c2))) {\n              for (c5 = (16 * c2 > 16 * c1 + 15?16 * c2 : 16 * c1 + 15); c5 <= ((16 * c2 + 15 < 16 * c1 + n + 12?16 * c2 + 15 : 16 * c1 + n + 12)); c5++) {\n                B[1][-16 * c1 + c5 + -14] = 0.2 * (A[1][-16 * c1 + c5 + -14] + A[1][-16 * c1 + c5 + -14 - 1] + A[1][1 + (-16 * c1 + c5 + -14)] + A[1 + 1][-16 * c1 + c5 + -14] + A[1 - 1][-16 * c1 + c5 + -14]);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int n = 500;\n  int tsteps = 10;\n/* Variable declaration/allocation. */\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(n, *A, *B);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_jacobi_2d_imper(tsteps,n, *A, *B);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *A);\n/* Be clean. */\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp taskwait depend(in: x)                  // 1st taskwait\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n  #pragma omp taskwait                                // 2nd taskwait\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n"}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }     \n  return 0;      \n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n//#pragma omp threadprivate(sum0)\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n/*  reference calculation */\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n//  assert(sum==sum1);\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE;\ndouble alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n  /* Initialize initial condition and RHS */\n#pragma omp parallel for private(i,j,xx,yy)\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       /* -1 < x < 1 */\n      yy = (int) (-1.0 + dy * (j - 1));       /* -1 < y < 1 */\n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nint main()\n{\n  initialize();\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <assert.h>\nunsigned int input = 30;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n#pragma omp taskwait\n    return i+j;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf (\"Fib(%d)=%d\\n\", input, result);\n  assert (result==832040);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h> \n#include <assert.h> \n#include <unistd.h>\n#include \"signaling.h\"\nint main()\n{\n  int i=0, j, k;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      delay(10000);\n      i = 1;    \n    }\n#pragma omp task depend (in:i)\n    j =i; \n#pragma omp task depend (in:i)\n    k =i; \n  }\n  printf (\"j=%d k=%d\\n\", j, k);\n  assert (j==1 && k==1);\n  return 0;\n} \n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\n\nvoid incr_b(pair *p){\n  p->b += 1;\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf(\"%d\\n\",p->b);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  float u[len][len];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5;\n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n  printf (\"sum = %f\\n\", sum); \n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         //2nd child task\n\n  #pragma omp task depend(in: x) if(0)                             // 1st taskwait\n  {}\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n\n  #pragma omp taskwait\t\t                                         // 2nd taskwait\n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#define N 100\n#define M 100 \n#define K 100\ndouble a[N][M],b[M][K],c[N][K];\n            \nint mmm()   \n{           \n  int i,j,k;\n#pragma omp parallel for private(j,k)\n  for (i = 0; i < N; i++) \n    for (k = 0; k < K; k++) \n      for (j = 0; j < M; j++)\n        c[i][j]= c[i][j]+a[i][k]*b[k][j];\n  return 0; \n} \n\nint main()\n{\n  mmm();\n  return 0;\n}  \n"}, {"prompt": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 10x1024x1024. */\n#include \"polybench/adi.h\"\n/* Array initialization. */\n\nstatic void init_array(int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c1;\n    int c3;\n    int c2;\n    int c4;\n    if (n >= 1) {\n#pragma omp parallel for private(c4, c2, c3)\n      for (c1 = 0; c1 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < n + -1?16 * c1 + 15 : n + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c4++) {\n              X[c3][c4] = (((double )c3) * (c4 + 1) + 1) / n;\n              A[c3][c4] = (((double )c3) * (c4 + 2) + 2) / n;\n              B[c3][c4] = (((double )c3) * (c4 + 3) + 3) / n;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int n,double X[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",X[i][j]);\n      if ((i * 500 + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_adi(int tsteps,int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int t;\n  //int i1;\n  //int i2;\n  \n  //#pragma scop\n{\n    int c0;\n    int c2;\n    int c8;\n    int c9;\n    int c15;\n    if (n >= 1 && tsteps >= 1) {\n      for (c0 = 0; c0 <= tsteps + -1; c0++) {\n        if (n >= 2) {\n#pragma omp parallel for private(c15, c9, c8)\n          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  B[c15][c9] = B[c15][c9] - A[c15][c9] * A[c15][c9] / B[c15][c9 - 1];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c15][c9] = X[c15][c9] - X[c15][c9 - 1] * A[c15][c9] / B[c15][c9 - 1];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c15][n - c9 - 2] = (X[c15][n - 2 - c9] - X[c15][n - 2 - c9 - 1] * A[c15][n - c9 - 3]) / B[c15][n - 3 - c9];\n                }\n              }\n            }\n          }\n        }\n#pragma omp parallel for private(c15)\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n#pragma omp simd\n          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n            X[c15][n - 1] = X[c15][n - 1] / B[c15][n - 1];\n          }\n        }\n        if (n >= 2) {\n#pragma omp parallel for private(c15, c9, c8)\n          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  B[c9][c15] = B[c9][c15] - A[c9][c15] * A[c9][c15] / B[c9 - 1][c15];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c9][c15] = X[c9][c15] - X[c9 - 1][c15] * A[c9][c15] / B[c9 - 1][c15];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[n - 2 - c9][c15] = (X[n - 2 - c9][c15] - X[n - c9 - 3][c15] * A[n - 3 - c9][c15]) / B[n - 2 - c9][c15];\n                }\n              }\n            }\n          }\n        }\n#pragma omp parallel for private(c15)\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n#pragma omp simd\n          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n            X[n - 1][c15] = X[n - 1][c15] / B[n - 1][c15];\n          }\n        }\n      }\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int n = 500;\n  int tsteps = 10;\n/* Variable declaration/allocation. */\n  double (*X)[500 + 0][500 + 0];\n  X = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(n, *X, *A, *B);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_adi(tsteps,n, *X, *A, *B);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *X);\n/* Be clean. */\n  free(((void *)X));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#define N 100\n\ndouble a[N][N],v[N],v_out[N];\nint mv()\n{           \n  int i,j;\n#pragma omp parallel for private (i,j)\n  for (i = 0; i < N; i++)\n  {         \n    float sum = 0.0;\n    for (j = 0; j < N; j++)\n    { \n      sum += a[i][j]*v[j];\n    }  \n    v_out[i] = sum;\n  }         \n  return 0; \n}\n\nint main()\n{\n  mv();\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int ret;\n  FILE* pfile;\n  int len=1000;\n\n  int A[1000];\n\n  for (i=0; i<len; i++)\n    A[i]=i;\n\n  pfile = fopen(\"mytempfile.txt\",\"a+\");\n  if (pfile ==NULL)\n  {\n    fprintf(stderr,\"Error in fopen()\\n\");\n  }\n\n#pragma omp parallel for\n  for (i=0; i<len; ++i)\n  {\n    fprintf(pfile, \"%d\\n\", A[i] );\n  }\n\n  fclose(pfile);\n  ret = remove(\"mytempfile.txt\");\n  if (ret != 0)\n  {\n    fprintf(stderr, \"Error: unable to delete mytempfile.txt\\n\");\n  }\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  int a[1000];\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n\n#pragma omp target map(a[0:len])\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n/*\nTwo-dimensional array computation using loops: missing private(j).\nReferences to j in the loop cause data races.\nData race pairs (we allow multiple ones to preserve the pattern):\n  Write_set = {j@61:10, j@61:20}\n  Read_set = {j@62:20, j@62:12, j@61:14, j@61:20}\n  Any pair from Write_set vs. Write_set  and Write_set vs. Read_set is a data race pair.\n*/\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n\n  printf (\"error = %d\\n\", error);\n  return 0;\n}  \n"}, {"prompt": "#include <stdio.h>\n/*\n * This is a program based on a dataset contributed by \n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n \n * sync with busy wait loop using atomic. No data race pair.\n */\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp atomic write seq_cst\n      s = 1;\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp atomic read seq_cst\n        done = s;\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n"}, {"prompt": "#include <stdlib.h>  \nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int numNodes=len, numNodes2=0; \n  int x[len]; \n\n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }         \n  return 0;\n} \n"}, {"prompt": "#include <assert.h> \n#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task\n    i = 1;    \n#pragma omp task\n    i = 2;    \n  }\n\n  printf (\"i=%d\\n\",i);\n  return 0;\n} \n"}, {"prompt": "#include <stdlib.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  return 0;\n}\n"}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n/*\nuse of omp target + map + array sections derived from pointers\n*/\nvoid foo (double* a, double* b, int N)\n{\n  int i; \n#pragma omp target map(to:a[0:N]) map(from:b[0:N])\n#pragma omp parallel for\n  for (i=0;i< N ;i++)\n    b[i]=a[i]*(double)i;\n}\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  double a[len], b[len];\n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]=0.0;\n  }\n\n  foo(a, b, len);\n\n  printf(\"b[50]=%f\\n\",b[50]);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l0);\n    else if (tid == 1)\n      omp_set_lock(&l1);\n#pragma omp barrier\n    if (tid == 0)\n      x = 0;\n    if (tid == 0)\n    {\n      omp_unset_lock(&l0);\n      omp_set_lock(&l1);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l0);\n      omp_unset_lock(&l1);\n    }\n    if (tid == 1)\n      x = 1;\n#pragma omp barrier\n    if (tid == 0)\n      omp_unset_lock(&l1);\n    else if (tid == 1)\n      omp_unset_lock(&l0);\n  } // end of parallel construct\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  printf(\"Done: x=%d\\n\", x);\n}\n"}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define N 100\n#define C 8\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  #pragma omp parallel\n  {\n    for(int i=0; i<N ;i++){\n      #pragma omp for\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp for\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf(\"expected %d real %d \\n\",val, b[i]);\n      return 0;\n    }\n  }\n\n  return 0;\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n  int section_count = 0;\n  omp_set_dynamic(0);\n  \n  omp_set_num_threads(1);\n\n  #pragma omp parallel\n  #pragma omp sections firstprivate( section_count )\n  {\n    #pragma omp section\n    {\n      section_count++;\n      printf(\"%d\\n\",section_count);\n    }\n    #pragma omp section\n    {\n      section_count++;\n      printf(\"%d\\n\",section_count);\n    }\n  }\n  return 0;\n}\n"}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  return 0;\n} \n"}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100], b[100];\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n\n#pragma omp simd \n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+b[i];\n\n  for (i=0;i<len;i++)\n    printf(\"i=%d a[%d]=%d\\n\",i,i,a[i]);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint n=100, m=100;\ndouble b[100][100];\n\nvoid foo()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<n;i++)\n    for (j=0;j<m-1;j++) // Be careful about bounds of j\n      b[i][j]=b[i][j+1];\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  int len = 20000;\n\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[len], b[len];\n\n  for (int i = 0; i < len; i++) {\n    a[i] = i;\n    b[i] = i + 1;\n  }\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len; i++)\n    a[i] = a[i] + b[i];\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n\n  return 0;\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n    tp=2;\n  }\n\n  if(var==2) printf(\"%d\\n\",var);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp critical(A)\n      {\n        s = 1;\n      }\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp critical(B)\n        {\n          if (s)\n            done = 1;\n        }\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n"}, {"prompt": "#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n  /*  reference calculation */\n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int i,j,k,m;\n  double tmp1;\n\n  double a[12][12][12];\n\n  m = 3.0;\n\n  #pragma omp parallel for private(j,k,tmp1)   \n  for (i = 0; i < 12; i++) {\n    for (j = 0; j < 12; j++) {\n      for (k = 0; k < 12; k++) {\n        tmp1 = 6.0/m;\n        a[i][j][k] = tmp1+4;\n      }\n    }\n  }\n\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  int var = 0;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf(\"%d\\n \",var);\n  return 0;\n}\n"}, {"prompt": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 533, 525, 527, 529, 531, // 521+12=533\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for // default static even scheduling may not trigger data race!\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n"}, {"prompt": "#include<stdio.h>\n#include<assert.h>\n/*  argument pass-by-value */\nvoid f1(int q)\n{\n  q += 1;\n}\n\nint main()\n{\n  int i=0;\n  #pragma omp parallel \n  {\n     f1(i);\n  }\n  assert (i==0);\n  printf (\"i=%d\\n\",i);\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n/*  reference calculation */\n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var) \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=100){\n      printf(\"%d\\n\",var[i]);\n    }\n  }\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid load_from_input(int *data, int size)\n{\n  for(int i = 0; i < size; i++) {\n    data[i] = size-i;\n  } \n}\n\n\nint main(int argc, char *argv[]) {\n\n  int *A; \n  int N = 100;\n\n  if (argc>1)\n    N = atoi(argv[1]);\n\n  A = (int*) malloc(sizeof(int) * N);\n\n  load_from_input(A, N);\n  \n#pragma omp parallel for shared(A)\n  for(int i = 0; i < N; i++) {\n    A[i] = i;\n    if (N > 10000) \n    { \n      A[0] = 1; \n    }\n  }\n\n  free(A);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint main(int argc, char** argv)\n{\n  double pi = 0.0;\n  long int i;\n  double x, interval_width;\n  interval_width = 1.0/(double)num_steps;\n\n#pragma omp parallel for reduction(+:pi) private(x)\n  for (i = 0; i < num_steps; i++) {\n    x = (i+ 0.5) * interval_width;\n    pi += 1.0 / (x*x + 1.0);\n  }\n\n  pi = pi * 4.0 * interval_width;\n  printf (\"PI=%f\\n\", pi);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint main()\n{\n  int i,j;\n  int n=100, m=100;\n  double b[n][m];\n\n  for(i=0;i<n; i++) \n    for(j=0;j<n; j++) \n      b[i][j]=(double)(i*j);\n\n  for (i=1;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l);\n#pragma omp barrier\n    if (tid == 0)\n    {\n      x = 0;\n      omp_unset_lock(&l);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l);\n      omp_unset_lock(&l);\n      x = 1;\n    }\n#pragma omp barrier\n  } // end of parallel construct\n  omp_destroy_lock(&l);\n  printf(\"Done: x=%d\\n\", x);\n}"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  if (argc>1)\n    inLen= atoi(argv[1]);\n\n  int input[inLen]; \n  int output[inLen];\n  for (i=0; i<inLen; ++i) \n    input[i]=i; \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf(\"output[0]=%d\\n\", output[0]);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i = 1;\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      #pragma omp critical (name)\n      {\n        #pragma omp parallel\n        {\n          #pragma omp single\n          {\n            i++;\n          }\n        }\n      }\n    }\n  }\n\n  printf(\"%d\\n\",i);\n  return 0;\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n    }\n\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n    }\n  }\n\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef long long num_sz;\n\nint max_num_blocks;\nint num_refine;\nint num_vars;\nint x_block_size, y_block_size, z_block_size;\nint error_tol;\n\ndouble tol;\n\ntypedef struct {\n   num_sz number;\n   int level;\n   int refine;\n   int new_proc;\n   num_sz parent;       // if original block -1,\n                     // else if on node, number in structure\n                     // else (-2 - parent->number)\n   double ****array;\n} block;\n\nblock *blocks;\n\nvoid stencil_calc(int var, int stencil_in)\n{\n   int i, j, k, in;\n   double sb, sm, sf, work[x_block_size+2][y_block_size+2][z_block_size+2];\n   block *bp;\n\n   int tid;\n\n#pragma omp parallel default(shared) private(i, j, k, bp)\n  {\n      for (in = 0; in < max_num_blocks; ++in) {\n         bp = &blocks[in];\n         for (i = 1; i <= x_block_size; i++)\n            for (j = 1; j <= y_block_size; j++)\n               for (k = 1; k <= z_block_size; k++)\n                  work[i][j][k] = (bp->array[var][i-1][j  ][k  ] +\n                                   bp->array[var][i  ][j-1][k  ] +\n                                   bp->array[var][i  ][j  ][k-1] +\n                                   bp->array[var][i  ][j  ][k  ] +\n                                   bp->array[var][i  ][j  ][k+1] +\n                                   bp->array[var][i  ][j+1][k  ] +\n                                   bp->array[var][i+1][j  ][k  ])/7.0;\n         for (i = 1; i <= x_block_size; i++)\n            for (j = 1; j <= y_block_size; j++)\n               for (k = 1; k <= z_block_size; k++)\n                  bp->array[var][i][j][k] = work[i][j][k];\n      }\n  }\n}\n\n\nvoid allocate(void)\n{\n   int i, j, k, m, n;\n\n   blocks = (block *) malloc(max_num_blocks*sizeof(block));\n\n   for (n = 0; n < max_num_blocks; n++) {\n      blocks[n].number = -1;\n      blocks[n].array = (double ****) malloc(num_vars*sizeof(double ***));\n      for (m = 0; m < num_vars; m++) {\n         blocks[n].array[m] = (double ***)\n                              malloc((x_block_size+2)*sizeof(double **));\n         for (i = 0; i < x_block_size+2; i++) {\n            blocks[n].array[m][i] = (double **)\n                                   malloc((y_block_size+2)*sizeof(double *));\n            for (j = 0; j < y_block_size+2; j++)\n               blocks[n].array[m][i][j] = (double *)\n                                     malloc((z_block_size+2)*sizeof(double));\n         }\n      }\n   }\n}\n\nvoid deallocate(void)\n{\n   int i, j, m, n;\n\n   for (n = 0; n < max_num_blocks; n++) {\n      for (m = 0; m < num_vars; m++) {\n         for (i = 0; i < x_block_size+2; i++) {\n            for (j = 0; j < y_block_size+2; j++)\n               free(blocks[n].array[m][i][j]);\n            free(blocks[n].array[m][i]);\n         }\n         free(blocks[n].array[m]);\n      }\n      free(blocks[n].array);\n   }\n   free(blocks);\n}\n\nvoid init(void)\n{\n   int n, var, i, j, k, l, m, o, size, dir, i1, i2, j1, j2, k1, k2, ib, jb, kb;\n   num_sz num;\n   block *bp;\n\n\n   /* Determine position of each core in initial mesh */\n   // initialize\n   for (o = n = k1 = k = 0; k < 1; k++)\n      for (k2 = 0; k2 < 1; k1++, k2++)\n         for (j1 = j = 0; j < 1; j++)\n            for (j2 = 0; j2 < 1; j1++, j2++)\n               for (i1 = i = 0; i < 1; i++)\n                  for (i2 = 0; i2 < 1; i1++, i2++, n++) {\n                     bp = &blocks[o];\n                     bp->level = 0;\n                     bp->number = n;\n                     //add_sorted_list(o, n, 0);\n                     for (var = 0; var < num_vars; var++)\n                        for (ib = 1; ib <= x_block_size; ib++)\n                           for (jb = 1; jb <= y_block_size; jb++)\n                              for (kb = 1; kb <= z_block_size; kb++)\n                                 bp->array[var][ib][jb][kb] =\n                                    ((double) rand())/((double) RAND_MAX);\n                    o++;\n                  }\n}\n\n\n\nvoid driver(void)\n{\n  int start, number, var;\n\n  init();\n\n  for (var = 0; var < num_vars; var ++) {\n     stencil_calc(var, 7);\n  }\n}\n\n\nint main(int argc, char* argv[])\n{   \n  max_num_blocks = 500;\n  num_refine = 5;\n  num_vars = 40;\n  x_block_size = 10;\n  y_block_size = 10;\n  z_block_size = 10;\n\n  allocate();\n \n  driver();\n\n  deallocate();\n  return 0;\n} \n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n    int thrd = omp_get_thread_num();\n    if (thrd == 0) {\n      #pragma omp critical\n      { x = 10; }\n      #pragma omp atomic write\n      y = 1;\n    } else {\n      int tmp = 0;\n      while (tmp == 0) {\n        #pragma omp atomic read acquire\n        tmp = y;\n    }\n    #pragma omp critical\n    { if (x!=10) printf(\"x = %d\\n\", x); }\n    }\n  }\n  return 0;\n}\n"}, {"prompt": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 533, // 521+12=533\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for // default static even scheduling may not trigger data race!\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n\nvoid foo()\n{\n  int i,x;\n#pragma omp parallel for private (i) lastprivate (x)\n  for (i=0;i<100;i++)\n    x=i;\n  printf(\"x=%d\",x);\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0, i, res;\n  int sum1 = 0;\n  int sum2 = 0;\n\n  res = omp_get_max_threads();\n\n  #pragma omp parallel reduction(+: var)\n  {\n    #pragma omp for schedule(static) reduction(+: sum1)\n    for (i=0; i<5; i++)\n    sum1+=i;\n    #pragma omp for schedule(static) reduction(+: sum2)\n    for (i=0; i<5; i++)\n    sum2+=i;\n\n    var = sum1 + sum2;\n  }\n\n  int error = (var != 20*res);\n  if (error) printf(\"%d %d\\n\",var,20*res);\n  return error;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <assert.h>\n#include <unistd.h>\n#include \"signaling.h\"\n\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskgroup\n      {\n#pragma omp task\n        {\n          delay(10000);\n          result = 1; \n        }\n      }\n#pragma omp task\n      {\n        result = 2; \n      }\n    }\n  }\n  printf (\"result=%d\\n\", result);\n  assert (result==2);\n  return 0;\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n\n  #pragma omp parallel shared(var)\n  {\n    #pragma omp single\n    var++;\n\n    #pragma omp barrier\n\n    #pragma omp single\n    var++;\n  }\n\n  if(var != 2) printf(\"%d\\n\",var);\n  int error = (var != 2);\n  return error;\n}\n"}, {"prompt": "#include <stdio.h>\nchar a[100];\nint main()\n{\n  int i;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    a[i]=a[i]+1;\n  return 0;\n} \n"}, {"prompt": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 4000. */\n#include \"polybench/3mm.h\"\n/* Array initialization. */\n\nstatic void init_array(int ni,int nj,int nk,int nl,int nm,double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c2;\n    int c1;\n    if (nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) < nm + -1?((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)) < nm + -1?((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nl > nm?nl : nm); c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((((nk + -1 < nl + -1?nk + -1 : nl + -1)) < nm + -1?((nk + -1 < nl + -1?nk + -1 : nl + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nj > nl?nj : nl)) > nm?((nj > nl?nj : nl)) : nm); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= ((((nj + -1 < nl + -1?nj + -1 : nl + -1)) < nm + -1?((nj + -1 < nl + -1?nj + -1 : nl + -1)) : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nk > nl?nk : nl); c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nk > nm?nk : nm); c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nk > nl?nk : nl)) > nm?((nk > nl?nk : nl)) : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = (nj > nk?nj : nk); c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nj > nk?nj : nk)) > nl?((nj > nk?nj : nk)) : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) < nm + -1?((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nk > nm?nk : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = (nj > nk?nj : nk); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nm; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nj; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nj; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nm?nj : nm); c1 <= ((ni + -1 < nk + -1?ni + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj <= 0 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > nm?0 : nm); c1 <= ((ni + -1 < nk + -1?ni + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nm + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nk; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nk > nl?nk : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nm + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nk; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nk > nm?nk : nm); c1 <= ((ni + -1 < nj + -1?ni + -1 : nj + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((ni + -1 < nj + -1?ni + -1 : nj + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nk?nj : nk); c1 <= ((ni + -1 < nm + -1?ni + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nk?nj : nk); c1 <= ((ni + -1 < nm + -1?ni + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c1 <= ni + -1; c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((nj + -1 < nl + -1?nj + -1 : nl + -1)) < nm + -1?((nj + -1 < nl + -1?nj + -1 : nl + -1)) : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nl > nm?nl : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nm?ni : nm); c1 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nj?ni : nj); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nj?ni : nj); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nj?ni : nj)) > nm?((ni > nj?ni : nj)) : nm); c1 <= nk + -1; c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nk?ni : nk); c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nk?ni : nk); c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nk?ni : nk)) > nm?((ni > nk?ni : nk)) : nm); c1 <= nj + -1; c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk <= 0 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk <= 0 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nm; c1 <= nj + -1; c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nj <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nj?ni : nj)) > nk?((ni > nj?ni : nj)) : nk); c1 <= nm + -1; c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > nj?0 : nj); c1 <= nm + -1; c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int ni,int nl,double G[128 + 0][128 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < ni; i++) \n    for (j = 0; j < nl; j++) {\n      fprintf(stderr,\"%0.2lf \",G[i][j]);\n      if ((i * ni + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[128 + 0][128 + 0],double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double F[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0],double G[128 + 0][128 + 0])\n{\n  //int i;\n  //int j;\n  //int k;\n  \n  //#pragma scop\n{\n    int c1;\n    int c2;\n    int c5;\n#pragma omp parallel for private(c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        G[c1][c2] = 0;\n        F[c1][c2] = 0;\n      }\n    }\n#pragma omp parallel for private(c5, c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        for (c5 = 0; c5 <= 127; c5++) {\n          F[c1][c2] += C[c1][c5] * D[c5][c2];\n        }\n      }\n    }\n#pragma omp parallel for private(c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        E[c1][c2] = 0;\n      }\n    }\n#pragma omp parallel for private(c5, c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        for (c5 = 0; c5 <= 127; c5++) {\n          E[c1][c2] += A[c1][c5] * B[c5][c2];\n        }\n        for (c5 = 0; c5 <= 127; c5++) {\n          G[c1][c5] += E[c1][c2] * F[c2][c5];\n        }\n      }\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int ni = 128;\n  int nj = 128;\n  int nk = 128;\n  int nl = 128;\n  int nm = 128;\n/* Variable declaration/allocation. */\n  double (*E)[128 + 0][128 + 0];\n  E = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[128 + 0][128 + 0];\n  A = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[128 + 0][128 + 0];\n  B = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*F)[128 + 0][128 + 0];\n  F = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*C)[128 + 0][128 + 0];\n  C = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*D)[128 + 0][128 + 0];\n  D = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*G)[128 + 0][128 + 0];\n  G = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(ni,nj,nk,nl,nm, *A, *B, *C, *D);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_3mm(ni,nj,nk,nl,nm, *E, *A, *B, *F, *C, *D, *G);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(ni,nl, *G);\n/* Be clean. */\n  free(((void *)E));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  free(((void *)F));\n  ;\n  free(((void *)C));\n  ;\n  free(((void *)D));\n  ;\n  free(((void *)G));\n  ;\n  return 0;\n}\n"}, {"prompt": "#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n\nvoid foo()\n{\n   (*counter)++; \n}\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, \"malloc() fails\\n\");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n     foo();\n  }\n  printf(\"%d \\n\", *counter);\n  free (counter);\n  return 0;   \n}\n\n"}, {"prompt": "#include <stdio.h>\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp critical\n      {\n        s = 1;\n      }\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp critical\n        {\n          if (s)\n            done = 1;\n        }\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n"}, {"prompt": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 533, 529, 531, // 521+12=533\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for // default static even scheduling may not trigger data race!\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n"}, {"prompt": "#include<iostream>\n#include<cassert>\nusing namespace std;\n\nclass A {\npublic:\n  static int counter; \n  static int pcounter; \n#pragma omp threadprivate(pcounter)\n};\n\nint A::counter=0; \nint A::pcounter=0; \n\nA a; \n\nint main()\n{ \n  #pragma omp parallel \n  {\n   a.counter++; \n   a.pcounter++; \n  }\n  assert (A::pcounter == 1);\n  cout<<A::counter <<\" \"<< A::pcounter<<endl;\n  return 0;   \n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         //2nd child task\n\n  #pragma omp taskwait depend(in: x)                               // 1st taskwait\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n\n  #pragma omp taskwait\t\t                                         // 2nd taskwait\n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n"}, {"prompt": "#include <string.h>\nint main(int argc,char *argv[])\n{\n  int i;\n  int j;\n  double a[20][20];\n  memset(a,0,(sizeof(a)));\n\n  for (i = 0; i < 20 -1; i += 1) {\n#pragma omp parallel for\n    for (j = 0; j < 20; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char* argv[])\n{\n  int len=100; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf(\"x=%d, a[0]=%d\\n\",x,a[0]);    \n  return 0;\n} \n\n"}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len], b[len];\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n#pragma omp simd\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]*b[i];\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i, m=2, n=4;\n  int b[4] = {};\n\n  #pragma omp simd safelen(2)\n  for (i = m; i<n; i++)\n    b[i] = b[i-m] - 1.0f;\n\n  printf(\"Expected: -1; Real: %d\\n\",b[3]);\n  return 0;\n}\n\n\n"}, {"prompt": "#include <stdio.h>\n/*\n *  loop missing the linear clause\n *  Data race pairs (race on j allows wrong indexing of c):  \n     j@70:7:R vs. j@71:5:W\n     j@71:5:W vs. j@71:5:W \n     c[j]@70:5:W vs. c[j]@70:5:W\n*/\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf (\"c[50]=%f\\n\",c[50]);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n\nint cap = 10, size = 0;\nunsigned r = 0;\n\nint main()\n{\n#pragma omp parallel sections shared(size, cap) firstprivate(r) num_threads(2)\n  {\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical(A)\n      {\n        if (size < cap)\n        {\n          size++; // produce\n          printf(\"Produced! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical(B)\n      {\n        if (size > 0)\n        {\n          size--; // consume\n          printf(\"Consumed! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n  }\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\nvoid incr_b(pair *p){\n  omp_set_nest_lock(&p->lck);\n    p->b += 1;\n  omp_unset_nest_lock(&p->lck);\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf(\"%d\\n\",p->b);\n  return 0;\n}\n"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble *u1, *u2, c = 0.2;\nint n = 10, nsteps = 10;\n\nint main()\n{\n  u1 = malloc(n * sizeof(double));\n  u2 = malloc(n * sizeof(double));\n  for (int i = 1; i < n - 1; i++)\n    u2[i] = u1[i] = 1.0 * rand() / RAND_MAX;\n  u1[0] = u1[n - 1] = u2[0] = u2[n - 1] = 0.5;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u2[i] = u1[i] + c * (u1[i - 1] + u1[i + 1] - 2 * u1[i]);\n    }\n    double *tmp = u1;\n    u1 = u2; // u2 = tmp;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u1[i]);\n  printf(\"\\n\");\n  free(u1);\n  free(u2);\n}\n"}, {"prompt": "#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\ntypedef _Bool flag_t;\n\nflag_t f0, f1;\nconst int n = 100;\nint x = 1;\n\nvoid init(flag_t *f)\n{\n  *f = 0;\n}\n\nvoid raise(flag_t *f)\n{\n#pragma omp critical\n  {\n    assert(*f == 0);\n    *f = 1;\n  }\n}\n\nvoid lower(flag_t *f)\n{\n  _Bool done = 0;\n  while (!done)\n  {\n#pragma omp critical\n    if (*f == 1)\n    {\n      *f = 0;\n      done = 1;\n    }\n  }\n}\n\nvoid mybarrier(int tid)\n{\n  if (tid == 0)\n  {\n    raise(&f0);\n    lower(&f1);\n  }\n  else if (tid == 1)\n  {\n    lower(&f0);\n    raise(&f1);\n  }\n}\n\nint main()\n{\n  init(&f0);\n  init(&f1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 1);\n      mybarrier(tid);\n      if (tid == 0)\n        x = 0;\n      mybarrier(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 0);\n      mybarrier(tid);\n      if (tid == 1)\n        x = 1;\n      mybarrier(tid);\n    }\n  } // end of parallel construct\n  printf(\"Done: x=%d\\n\", x);\n}"}, {"prompt": "#include <stdio.h>\n#include <assert.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp barrier\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n  assert (error == 51);\n  printf (\"error = %d\\n\", error);\n  return 0;\n}  \n"}, {"prompt": "#include <stdio.h>\n \nfloat x=0.0;\nint y=0;\n#pragma omp threadprivate(x,y)\n\nint main (int argc, char * argv[])\n{\n#pragma omp parallel\n  {\n#pragma omp single copyprivate(x,y)\n    {\n      x=1.0;\n      y=1;\n    }\n  }\n  printf (\"x=%f y=%d\\n\", x, y);\n  return 0;\n}\n"}, {"prompt": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999,\n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf(\"Error, malloc() returns NULL. End execution. \\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = base + 12;\n  int i;\n\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.0;\n  }\n\n#pragma omp parallel for\n  for (i =0; i< N; ++i) // this level of loop has no loop carried dependence\n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n\n  // verify the results, no overlapping of xa1 vs. xa2, no addition happens to the same element twice\n  for (i =521; i<= 2025; ++i)\n  {\n    //printf (\"%f  \", base[i]);\n    assert (base[i]!=4.0);\n  }\n\n  free (base);\n  return  0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  omp_lock_t lck;\n  int var=0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf(\"%d\\n\",var);\n  return 0;\n}\n"}, {"prompt": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 923, // change original 921 to 923 = 911+12\n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  // max index value is 2013. +12 to obtain a valid xa2[idx] after xa1+12.\n  // +1 to ensure a reference like base[2015] is within the bound.\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n// default static even scheduling may not trigger data race, using static,1 instead.\n#pragma omp parallel for schedule(static,1)\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0 + i;\n    xa2[idx]+= 3.0 + i;\n  }\n\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  double a[20][20];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n\n  printf (\"a[10][10]=%f\\n\", a[10][10]);\n  return 0;\n}\n\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp critical(addlock)\n    var++;\n\n    #pragma omp critical(sublock)\n    var -= 2;\n  }\n\n  printf(\"%d\\n\",var);\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N*2; i++){\n    #pragma omp critical\n    var++;\n  }\n\n  printf(\"%d\\n \",var);\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n/*\n * Test if atomic can be recognized properly. No data races.\n * */\nint main (void)\n{\n  int a=0;\n#pragma omp parallel \n  {\n#pragma omp atomic\n    a+=1;\n  }\n  printf (\"a=%d\\n\",a);\n  return 0;\n}\n\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n  {\n#pragma omp task depend(inout : a) shared(a)\n    a++;\n  }\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf(\"%d\\n \",var[i]);\n  }\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  int len = 20000;\n\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[2 * len], b[len];\n\n  for (int i = 0; i < 2 * len; i++)\n    a[i] = i;\n  for (int i = 0; i < len; i++)\n    b[i] = i + 1;\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len; i++)\n    a[i * 2] = a[i + 64] + b[i];\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint n=100, m=100;\ndouble b[100][100];\n\nvoid foo()\n{\n  int i,j;\n#pragma omp parallel for private(j)\n  for (i=0;i<n;i++)\n    for (j=1;j<m;j++) // Be careful about bounds of j\n      b[i][j]=b[i][j-1];\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n\n  float u[100][100];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5; \n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n\n  printf (\"sum = %f\\n\", sum);  \n  return 0;\n}\n"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int n=1000, m=1000;\n  double b[1000][1000];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  printf(\"b[500][500]=%f\\n\", b[500][500]);  \n  return 0;\n}\n"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n   \n  srand(time(NULL));\n#pragma omp parallel for if (rand()%2)\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf(\"a[50]=%d\\n\", a[50]);   \n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint nprod = 4, ncons = 4;\nint cap = 5, size = 0, packages = 1000;\nint main()\n{\n  int nthread = nprod + ncons;\n#pragma omp parallel for shared(size, cap, nprod, ncons, nthread) firstprivate(packages) num_threads(nthread)\n  for (int i = 0; i < nthread; i++)\n  {\n    if (i < nprod)\n      while (packages)\n      { // I am a producer\n#pragma omp critical(A)\n        if (size < cap)\n        {\n          size++; // produce\n          packages--; // produced a package\n          printf(\"Producer %d produced! size=%d\\n\", i, size);\n          fflush(stdout);\n        }\n      }\n    else\n      while (packages)\n      { // I am a consumer\n#pragma omp critical(B)\n        if (size > 0)\n        {\n          size--; // consume\n          packages--; // consumed a package\n          printf(\"Consumer %d consumed! size=%d\\n\", i - nprod, size);\n          fflush(stdout);\n        }\n      }\n  }\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  {\n    #pragma omp teams\n    for(int i=0; i<N ;i++){\n      #pragma omp distribute\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp distribute\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf(\"index: %d val: %d\\n\",i, b[i]);\n    }\n  }\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for linear(j)\n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf (\"c[50]=%f\\n\",c[50]);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel for ordered(2)\n  for (i = 0; i < 100; i++)\n    for (j = 0; j < 100; j++)\n    {\n      a[i][j] = a[i][j] + 1;\n#pragma omp ordered depend(sink:i-1,j) depend (sink:i,j-1)\n      printf (\"test i=%d j=%d\\n\",i,j);\n#pragma omp ordered depend(source)\n    }\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\n\nint main(int argc, char *argv[]) {\n\n  int *A; \n  int N = 100;\n\n  A = (int*) malloc(sizeof(int) * N);\n\n  \n#pragma omp parallel for shared(A)\n  for(int i = 0; i < N; i++) {\n    A[i] = i;\n    if (i == 1) \n    { \n      A[0] = 1; \n    }\n  }\n\n  free(A);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\nint main(int argc, char *argv[]) {\n  int len = 20000;\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[len];\n  for (int i = 0; i < len; i++)\n    a[i] = i;\n  double c = M_PI;\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len; i++)\n    a[i] = a[i] + a[64];\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp task depend(in: x) if(0)                // 1st taskwait\n  {}\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                // 2nd taskwait\n\n  printf(\"y=%d\\n\",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  printf(\"%d\\n\",var[63]);\n\n  return 0;\n}\n"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble *u1, *u2, c = 0.2;\nint n = 10, nsteps = 10;\n\nint main()\n{\n  u1 = malloc(n * sizeof(double));\n  u2 = malloc(n * sizeof(double));\n  for (int i = 1; i < n - 1; i++)\n    u2[i] = u1[i] = 1.0 * rand() / RAND_MAX;\n  u1[0] = u1[n - 1] = u2[0] = u2[n - 1] = 0.5;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u2[i] = u1[i] + c * (u1[i - 1] + u1[i + 1] - 2 * u1[i]);\n    }\n    double *tmp = u1;\n    u1 = u2;\n    u2 = tmp;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u1[i]);\n  printf(\"\\n\");\n  free(u1);\n  free(u2);\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1, l2;\nconst int n = 2;\nint x = 1;\n\nvoid barrier_init()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n  omp_init_lock(&l2);\n}\n\nvoid barrier_destroy()\n{\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  omp_destroy_lock(&l2);\n}\n\nvoid barrier_start(int tid)\n{\n  if (tid == 0)\n  {\n    omp_set_lock(&l0);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l1);\n  }\n}\n\nvoid barrier_stop(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_unset_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_unset_lock(&l1);\n  }\n}\n\nvoid barrier_wait(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    // omp_unset_lock(&l2);\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    // omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    // omp_set_lock(&l2);\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    // omp_unset_lock(&l2);\n  }\n}\n\nint main()\n{\n  barrier_init();\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    barrier_start(tid);\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      // assert(x==1);\n      barrier_wait(tid);\n      if (tid == 0)\n        x = 0;\n      barrier_wait(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      // assert(x==0);\n      barrier_wait(tid);\n      if (tid == 1)\n        x = 1;\n      barrier_wait(tid);\n    }\n#pragma omp barrier\n    barrier_stop(tid);\n  } // end of parallel construct\n  barrier_destroy();\n  printf(\"Done: x=%d\\n\", x);\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp atomic\n    var++;\n\n    #pragma omp atomic\n    var -= 2;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  int a[100];\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }\n\n  printf(\"a[50]=%d\\n\", a[50]);\n  return 0;      \n}\n\n"}, {"prompt": "#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop collapse(2)\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf (\"a[50][50]=%d\\n\", a[50][50]);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 4000. */\n#include \"polybench/3mm.h\"\n/* Array initialization. */\n\nstatic void init_array(int ni,int nj,int nk,int nl,int nm,double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c3;\n    int c4;\n    int c1;\n    int c2;\n    if (ni >= ((0 > -1 * nj + -1 * nm + 1?0 : -1 * nj + -1 * nm + 1)) && nj >= 0 && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + ni + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + ni + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + ni + nj + nm + -1) + 16 - 1) / 16))) : (nk + ni + nj + nm + -1) / 16)) < (((nk + ni + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + ni + nj + 2 * nm + -2) / 16))?(((nk + ni + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + ni + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + ni + nj + nm + -1) + 16 - 1) / 16))) : (nk + ni + nj + nm + -1) / 16)) : (((nk + ni + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + ni + nj + 2 * nm + -2) / 16)))); c1++) {\n        if (c1 <= (((((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)) < nm + -1?((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)) < nm + -1?((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nl?nj : nl)) > nm?((nj > nl?nj : nl)) : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nk > nl?nk : nl)) > nm?((nk > nl?nk : nl)) : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nk?nj : nk)) > nl?((nj > nk?nj : nk)) : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nl + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nl + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n            }\n            for (c3 = nk; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)) < nm + -1?((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)) : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= nk + -1; c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= nm + -1; c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((ni > nj?ni : nj)) > nm?((ni > nj?ni : nj)) : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((ni > nk?ni : nk)) > nm?((ni > nk?ni : nk)) : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (((ni > nj?ni : nj)) > nk?((ni > nj?ni : nj)) : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) && c1 >= ((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nk; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nk; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= ((0 > -1 * nj + 1?0 : -1 * nj + 1)) && nj >= 0 && nk >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + ni + -1) * 16 < 0?((16 < 0?-((-(nk + ni + -1) + 16 + 1) / 16) : -((-(nk + ni + -1) + 16 - 1) / 16))) : (nk + ni + -1) / 16)) < (((nk + ni + nj + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + -2) + 16 - 1) / 16))) : (nk + ni + nj + -2) / 16))?(((nk + ni + -1) * 16 < 0?((16 < 0?-((-(nk + ni + -1) + 16 + 1) / 16) : -((-(nk + ni + -1) + 16 - 1) / 16))) : (nk + ni + -1) / 16)) : (((nk + ni + nj + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + -2) + 16 - 1) / 16))) : (nk + ni + nj + -2) / 16)))); c1++) {\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj <= -1 && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((ni + nm + -1) * 16 < 0?((16 < 0?-((-(ni + nm + -1) + 16 + 1) / 16) : -((-(ni + nm + -1) + 16 - 1) / 16))) : (ni + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (nj <= -1 && nk >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n              A[c3][c4] = ((double )c3) * c4 / ni;\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj >= 0 && nk <= -1 && nm >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nj + nm + -1) * 16 < 0?((16 < 0?-((-(nj + nm + -1) + 16 + 1) / 16) : -((-(nj + nm + -1) + 16 - 1) / 16))) : (nj + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj <= -1 && nk <= -1 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + nj + nm + -1) + 16 - 1) / 16))) : (nk + nj + nm + -1) / 16)) < (((nk + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + nj + 2 * nm + -2) / 16))?(((nk + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + nj + nm + -1) + 16 - 1) / 16))) : (nk + nj + nm + -1) / 16)) : (((nk + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + nj + 2 * nm + -2) / 16)))); c1++) {\n        if (c1 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n              B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj <= -1 && nk >= 0 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= 0 && nk <= -1 && nm >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nj + nm + -1) * 16 < 0?((16 < 0?-((-(nj + nm + -1) + 16 + 1) / 16) : -((-(nj + nm + -1) + 16 - 1) / 16))) : (nj + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj <= -1 && nk <= -1 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int ni,int nl,double G[128 + 0][128 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < ni; i++) \n    for (j = 0; j < nl; j++) {\n      fprintf(stderr,\"%0.2lf \",G[i][j]);\n      if ((i * ni + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[128 + 0][128 + 0],double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double F[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0],double G[128 + 0][128 + 0])\n{\n  // int i;\n  // int j;\n  // int k;\n  \n  //#pragma scop\n{\n    int c5;\n    int c10;\n    int c2;\n    int c1;\n    int c6;\n    int c7;\n    if (ni >= 0 && nj >= 0 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((nj + ni + -1) * 16 < 0?((16 < 0?-((-(nj + ni + -1) + 16 + 1) / 16) : -((-(nj + ni + -1) + 16 - 1) / 16))) : (nj + ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n            for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n              for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                G[c10][c7] = 0;\n              }\n            }\n          }\n          if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n            for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n              for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n                F[c10][c7] = 0;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n              F[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nj <= -1 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n              G[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nl >= 1 && nm >= 1) {\n#pragma omp parallel for private(c7, c6, c2, c10, c5)\n      for (c1 = 0; c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c5 = 0; c5 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nm + -1?16 * c5 + 15 : nm + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n                  F[c10][c7] += C[c10][c6] * D[c6][c7];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n              E[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c7, c6, c2, c10, c5)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c5 = 0; c5 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nk + -1?16 * c5 + 15 : nk + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                  E[c10][c7] += A[c10][c6] * B[c6][c7];\n                }\n              }\n            }\n          }\n          for (c5 = 0; c5 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nl + -1?16 * c5 + 15 : nl + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                  G[c10][c6] += E[c10][c7] * F[c7][c6];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  //#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int ni = 128;\n  int nj = 128;\n  int nk = 128;\n  int nl = 128;\n  int nm = 128;\n/* Variable declaration/allocation. */\n  double (*E)[128 + 0][128 + 0];\n  E = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[128 + 0][128 + 0];\n  A = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[128 + 0][128 + 0];\n  B = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*F)[128 + 0][128 + 0];\n  F = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*C)[128 + 0][128 + 0];\n  C = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*D)[128 + 0][128 + 0];\n  D = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*G)[128 + 0][128 + 0];\n  G = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(ni,nj,nk,nl,nm, *A, *B, *C, *D);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_3mm(ni,nj,nk,nl,nm, *E, *A, *B, *F, *C, *D, *G);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(ni,nl, *G);\n/* Be clean. */\n  free(((void *)E));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  free(((void *)F));\n  ;\n  free(((void *)C));\n  ;\n  free(((void *)D));\n  ;\n  free(((void *)G));\n  ;\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp single\n    {\n    init = 10;\n    }\n    local = init;\n  }\n\n  return 0;\n}\n\n\n"}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n\n  printf(\"x=%d\",x);\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\nvoid foo1(double o1[], double c[], int len)\n{ \n  int i ;\n#pragma omp parallel for\n  for (i = 0; i < len; ++i) {\n    double volnew_o8 = 0.5 * c[i];\n    o1[i] = volnew_o8;\n  } \n}\n\ndouble o1[100];\ndouble c[100];\nint main()\n{\n  foo1 (o1, c, 100);\n  return 0;\n}\n"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\ndouble b[1000][1000];\n\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=1000, m=1000;\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  printf(\"b[500][500]=%f\\n\", b[500][500]);\n  return 0;\n}\n\n"}, {"prompt": "#include <stdlib.h>\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  double a[len][len];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <omp.h>\n#include <time.h>\n\n\n/*--------------------------------------------------------------------\n * Constants\n */\n#define PATH -1\n#define NONE 0\n#define UP 1\n#define LEFT 2\n#define DIAGONAL 3\n/* End of constants */\n\n/*--------------------------------------------------------------------\n* Helpers\n*/\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n#define max(a,b) ((a) > (b) ? a : b)\n\n// #define DEBUG\n/* End of Helpers */\n\n/*--------------------------------------------------------------------\n * Global Variables\n */\n//Defines size of strings to be compared\nlong long int m ; //Columns - Size of string a\nlong long int n ;  //Lines - Size of string b\n\n//Defines scores\nint matchScore = 5;\nint missmatchScore = -3;\nint gapScore = -4;\n\n//Strings over the Alphabet Sigma\nchar *a, *b;\n\n/* End of global variables */\nvoid generate() {\n    //Random seed\n    srand(time(NULL));\n\n    //Generates the values of a\n    long long int i;\n    for (i = 0; i < m; i++) {\n        int aux = rand() % 4;\n        if (aux == 0)\n            a[i] = 'A';\n        else if (aux == 2)\n            a[i] = 'C';\n        else if (aux == 3)\n            a[i] = 'G';\n        else\n            a[i] = 'T';\n    }\n\n    //Generates the values of b\n    for (i = 0; i < n; i++) {\n        int aux = rand() % 4;\n        if (aux == 0)\n            b[i] = 'A';\n        else if (aux == 2)\n            b[i] = 'C';\n        else if (aux == 3)\n            b[i] = 'G';\n        else\n            b[i] = 'T';\n    }\n} /* End of generate */\n\n\n/*--------------------------------------------------------------------\n * Function:    nElement\n * Purpose:     Calculate the number of i-diagonal elements\n */\nlong long int nElement(long long int i) {\n    if (i < m && i < n) {\n        //Number of elements in the diagonal is increasing\n        return i;\n    }\n    else if (i < max(m, n)) {\n        //Number of elements in the diagonal is stable\n        long long int min = min(m, n);\n        return min - 1;\n    }\n    else {\n        //Number of elements in the diagonal is decreasing\n        long long int min = min(m, n);\n        return 2 * min - i + labs(m - n) - 2;\n    }\n}\n\n/*--------------------------------------------------------------------\n * Function:    matchMissmatchScore\n * Purpose:     Similarity function on the alphabet for match/missmatch\n */\nint matchMissmatchScore(long long int i, long long int j) {\n    if (a[j - 1] == b[i - 1])\n        return matchScore;\n    else\n        return missmatchScore;\n}  /* End of matchMissmatchScore */\n\n\nvoid similarityScore(long long int i, long long int j, int* H, int* P, long long int* maxPos) {\n\n    int up, left, diag;\n\n    //Stores index of element\n    long long int index = m * i + j;\n\n    //Get element above\n    up = H[index - m] + gapScore;\n\n    //Get element on the left\n    left = H[index - 1] + gapScore;\n\n    //Get element on the diagonal\n    diag = H[index - m - 1] + matchMissmatchScore(i, j);\n\n    //Calculates the maximum\n    int max = NONE;\n    int pred = NONE;\n    /* === Matrix ===\n     *      a[0] ... a[n]\n     * b[0]\n     * ...\n     * b[n]\n     *\n     * generate 'a' from 'b', if '\u2190' insert e '\u2191' remove\n     * a=GAATTCA\n     * b=GACTT-A\n     *\n     * generate 'b' from 'a', if '\u2190' insert e '\u2191' remove\n     * b=GACTT-A\n     * a=GAATTCA\n    */\n\n    if (diag > max) { //same letter \u2196\n        max = diag;\n        pred = DIAGONAL;\n    }\n\n    if (up > max) { //remove letter \u2191\n        max = up;\n        pred = UP;\n    }\n\n    if (left > max) { //insert letter \u2190\n        max = left;\n        pred = LEFT;\n    }\n    //Inserts the value in the similarity and predecessor matrixes\n    H[index] = max;\n    P[index] = pred;\n\n    //Updates maximum score to be used as seed on backtrack\n    if (max > H[*maxPos]) {        \n    #pragma omp critical\n        *maxPos = index;\n    }\n\n}  /* End of similarityScore */\n\n/*--------------------------------------------------------------------\n * Function:    calcElement\n * Purpose:     Calculate the position of (si, sj)-element\n */\nvoid calcFirstDiagElement(long long int *i, long long int *si, long long int *sj) {\n    // Calculate the first element of diagonal\n    if (*i < n) {\n        *si = *i;\n        *sj = 1;\n    } else {\n        *si = n - 1;\n        *sj = *i - n + 2;\n    }\n}\n\n\nint main(int argc, char* argv[]) {\n    m = 2048;\n    n = 2048;\n\n#ifdef DEBUG\n    printf(\"\\nMatrix[%lld][%lld]\\n\", n, m);\n#endif\n\n    //Allocates a and b\n    a = malloc(m * sizeof(char));\n    b = malloc(n * sizeof(char));\n\n    //Because now we have zeros\n    m++;\n    n++;\n\n    //Allocates similarity matrix H\n    int *H;\n    H = calloc(m * n, sizeof(int));\n\n    //Allocates predecessor matrix P\n    int *P;\n    P = calloc(m * n, sizeof(int));\n\n\n    //Gen rand arrays a and b\n    generate();\n\n\n    //Start position for backtrack\n    long long int maxPos = 0;\n    //Calculates the similarity matrix\n    long long int i, j;\n\n    //Gets Initial time\n    double initialTime = omp_get_wtime();\n\n    long long int si, sj, ai, aj;\n\n    //Because now we have zeros ((m-1) + (n-1) - 1)\n    long long int nDiag = m + n - 3;\n    long long int nEle;\n\n    #pragma omp parallel \\\n    default(none) shared(H, P, maxPos, nDiag) private(nEle, i, si, sj, ai, aj)\n    {\n        for (i = 1; i <= nDiag; ++i)\n        {\n            nEle = nElement(i);\n            calcFirstDiagElement(&i, &si, &sj);\n            #pragma omp for\n            for (j = 1; j <= nEle; ++j)\n            {\n                ai = si - j + 1;\n                aj = sj + j - 1;\n                similarityScore(ai, aj, H, P, &maxPos);\n            }\n        }\n    }\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n  }\n  printf (\"numThreads=%d\\n\", numThreads);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\ntypedef _Bool flag_t;\n\nflag_t f0, f1;\nconst int n = 2;\nint x = 1;\n\nvoid init(flag_t *f)\n{\n  *f = 0;\n}\n\nvoid raise(flag_t *f)\n{\n#pragma omp critical\n  {\n    assert(*f == 0);\n    *f = 1;\n  }\n}\n\nvoid lower(flag_t *f)\n{\n  _Bool done = 0;\n  while (!done)\n  {\n#pragma omp critical\n    if (*f == 1)\n    {\n      *f = 0;\n      done = 1;\n    }\n  }\n}\n\nvoid mybarrier(int tid)\n{\n  if (tid == 0)\n  {\n    raise(&f0);\n    lower(&f0);\n  }\n  else if (tid == 1)\n  {\n    raise(&f1);\n    lower(&f1);\n  }\n}\n\nint main()\n{\n  init(&f0);\n  init(&f1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      // assert(x==1);\n      mybarrier(tid);\n      if (tid == 0)\n        x = 0;\n      mybarrier(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      // assert(x==0);\n      mybarrier(tid);\n      if (tid == 1)\n        x = 1;\n      mybarrier(tid);\n    }\n  } // end of parallel construct\n  printf(\"Done: x=%d\\n\", x);\n}\n"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint input[1000]; \nint output[1000];\n\nint main()\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  for (i=0; i<inLen; ++i) \n    input[i]= i;  \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) \n  {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf(\"output[500]=%d\\n\",output[500]);\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int i)\n{\n#pragma omp task\n  {\n    a[i]= i+1;\n  }\n}\n\nint main()\n{\n  int i=0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n      for (i=0; i<MYLEN; i++)\n      {\n        gen_task(i);\n      }\n    }\n  }\n  \n  /* correctness checking */\n  for (i=0; i<MYLEN; i++)\n  {\n    //assert (a[i]==i+1);\n    if (a[i]!= i+1)\n    {\n      printf(\"warning: a[%d] = %d, not expected %d\\n\", i, a[i], i+1);\n    }\n  }\n  return 0;\n}\n\n"}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=2000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<len/2;i++)\n    a[2*i+1]=a[i]+1;\n\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 20x1000. */\n#include \"polybench/jacobi-2d-imper.h\"\n/* Array initialization. */\n\nstatic void init_array(int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c2;\n    int c1;\n    if (n >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= n + -1; c1++) {\n        for (c2 = 0; c2 <= n + -1; c2++) {\n          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int n,double A[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",A[i][j]);\n      if ((i * n + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_jacobi_2d_imper(int tsteps,int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int t;\n  //int i;\n  //int j;\n  \n  //#pragma scop\n{\n    int c2;\n    int c1;\n    int c0;\n    for (c2 = 1; c2 <= 498; c2++) {\n      B[1][c2] = 0.2 * (A[1][c2] + A[1][c2 - 1] + A[1][1 + c2] + A[1 + 1][c2] + A[1 - 1][c2]);\n    }\n    for (c0 = 2; c0 <= 525; c0++) {\n      if (c0 <= 28) {\n        if ((2 * c0 + 1) % 3 == 0) {\n          for (c2 = ((2 * c0 + 1) * 3 < 0?-(-(2 * c0 + 1) / 3) : ((3 < 0?(-(2 * c0 + 1) + - 3 - 1) / - 3 : (2 * c0 + 1 + 3 - 1) / 3))); c2 <= (((2 * c0 + 1492) * 3 < 0?((3 < 0?-((-(2 * c0 + 1492) + 3 + 1) / 3) : -((-(2 * c0 + 1492) + 3 - 1) / 3))) : (2 * c0 + 1492) / 3)); c2++) {\n            B[1][(-2 * c0 + 3 * c2 + 2) / 3] = 0.2 * (A[1][(-2 * c0 + 3 * c2 + 2) / 3] + A[1][(-2 * c0 + 3 * c2 + 2) / 3 - 1] + A[1][1 + (-2 * c0 + 3 * c2 + 2) / 3] + A[1 + 1][(-2 * c0 + 3 * c2 + 2) / 3] + A[1 - 1][(-2 * c0 + 3 * c2 + 2) / 3]);\n          }\n        }\n      }\n#pragma omp parallel for private(c2)\n      for (c1 = ((((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) > c0 + -9?(((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) : c0 + -9); c1 <= (((((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) < c0?(((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) : c0)); c1++) {\n        B[-2 * c0 + 3 * c1][1] = 0.2 * (A[-2 * c0 + 3 * c1][1] + A[-2 * c0 + 3 * c1][1 - 1] + A[-2 * c0 + 3 * c1][1 + 1] + A[1 + (-2 * c0 + 3 * c1)][1] + A[-2 * c0 + 3 * c1 - 1][1]);\n        for (c2 = 2 * c0 + -2 * c1 + 2; c2 <= 2 * c0 + -2 * c1 + 498; c2++) {\n          A[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1] = B[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1];\n          B[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] = 0.2 * (A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2 - 1] + A[-2 * c0 + 3 * c1][1 + (-2 * c0 + 2 * c1 + c2)] + A[1 + (-2 * c0 + 3 * c1)][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1 - 1][-2 * c0 + 2 * c1 + c2]);\n        }\n        A[-2 * c0 + 3 * c1 + -1][498] = B[-2 * c0 + 3 * c1 + -1][498];\n      }\n      if (c0 >= 499) {\n        if ((2 * c0 + 1) % 3 == 0) {\n          for (c2 = ((2 * c0 + -992) * 3 < 0?-(-(2 * c0 + -992) / 3) : ((3 < 0?(-(2 * c0 + -992) + - 3 - 1) / - 3 : (2 * c0 + -992 + 3 - 1) / 3))); c2 <= (((2 * c0 + 499) * 3 < 0?((3 < 0?-((-(2 * c0 + 499) + 3 + 1) / 3) : -((-(2 * c0 + 499) + 3 - 1) / 3))) : (2 * c0 + 499) / 3)); c2++) {\n            A[498][(-2 * c0 + 3 * c2 + 995) / 3] = B[498][(-2 * c0 + 3 * c2 + 995) / 3];\n          }\n        }\n      }\n    }\n    for (c2 = 20; c2 <= 517; c2++) {\n      A[498][c2 + -19] = B[498][c2 + -19];\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int n = 500;\n  int tsteps = 10;\n/* Variable declaration/allocation. */\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(n, *A, *B);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_jacobi_2d_imper(tsteps,n, *A, *B);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *A);\n/* Be clean. */\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              //2nd child task\n\n  #pragma omp taskwait depend(in: x)                                    // 1st taskwait\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                                  // 2nd taskwait\n\n  printf(\"y=%d\\n\",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n) {\n  int i, j, s;\n  if (n < 2)\n    return n;\n#pragma omp task shared(i) depend(out : i)\n  i = fib(n - 1);\n#pragma omp task shared(j) depend(out : j)\n  j = fib(n - 2);\n#pragma omp task shared(i, j, s) depend(in : i, j)\n  s = i + j;\n#pragma omp taskwait\n  return s;\n}\n\nint main(int argc, char **argv) {\n  int n = 10;\n  if (argc > 1)\n    n = atoi(argv[1]);\n#pragma omp parallel sections\n  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n  return 0;\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf(\"%d\\n\",x);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  omp_lock_t lck;\n  int var = 0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute reduction(+:var)\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf(\"%d\\n \",var);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint a[100];\n\nint main()\n{\n  int len=100; \n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf(\"x=%d\",x);    \n  return 0;\n} \n\n"}, {"prompt": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 10x1024x1024. */\n#include \"polybench/adi.h\"\n/* Array initialization. */\n\nstatic void init_array(int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c1;\n    int c2;\n    if (n >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= n + -1; c1++) {\n        for (c2 = 0; c2 <= n + -1; c2++) {\n          X[c1][c2] = (((double )c1) * (c2 + 1) + 1) / n;\n          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int n,double X[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",X[i][j]);\n      if ((i * 500 + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_adi(int tsteps,int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int t;\n  //int i1;\n  //int i2;\n  \n  //#pragma scop\n{\n    int c0;\n    int c2;\n    int c8;\n    for (c0 = 0; c0 <= 9; c0++) {\n#pragma omp parallel for private(c8)\n      for (c2 = 0; c2 <= 499; c2++) {\n        for (c8 = 1; c8 <= 499; c8++) {\n          B[c2][c8] = B[c2][c8] - A[c2][c8] * A[c2][c8] / B[c2][c8 - 1];\n        }\n        for (c8 = 1; c8 <= 499; c8++) {\n          X[c2][c8] = X[c2][c8] - X[c2][c8 - 1] * A[c2][c8] / B[c2][c8 - 1];\n        }\n        for (c8 = 0; c8 <= 497; c8++) {\n          X[c2][500 - c8 - 2] = (X[c2][500 - 2 - c8] - X[c2][500 - 2 - c8 - 1] * A[c2][500 - c8 - 3]) / B[c2][500 - 3 - c8];\n        }\n      }\n#pragma omp parallel for\n      for (c2 = 0; c2 <= 499; c2++) {\n        X[c2][500 - 1] = X[c2][500 - 1] / B[c2][500 - 1];\n      }\n#pragma omp parallel for private(c8)\n      for (c2 = 0; c2 <= 499; c2++) {\n        for (c8 = 1; c8 <= 499; c8++) {\n          B[c8][c2] = B[c8][c2] - A[c8][c2] * A[c8][c2] / B[c8 - 1][c2];\n        }\n        for (c8 = 1; c8 <= 499; c8++) {\n          X[c8][c2] = X[c8][c2] - X[c8 - 1][c2] * A[c8][c2] / B[c8 - 1][c2];\n        }\n        for (c8 = 0; c8 <= 497; c8++) {\n          X[500 - 2 - c8][c2] = (X[500 - 2 - c8][c2] - X[500 - c8 - 3][c2] * A[500 - 3 - c8][c2]) / B[500 - 2 - c8][c2];\n        }\n      }\n#pragma omp parallel for\n      for (c2 = 0; c2 <= 499; c2++) {\n        X[500 - 1][c2] = X[500 - 1][c2] / B[500 - 1][c2];\n      }\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int n = 500;\n  int tsteps = 10;\n/* Variable declaration/allocation. */\n  double (*X)[500 + 0][500 + 0];\n  X = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(n, *X, *A, *B);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_adi(tsteps,n, *X, *A, *B);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *X);\n/* Be clean. */\n  free(((void *)X));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections \n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var) if(0)\n      {\n        var++;\n      }\n    }\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n  printf(\"x=%d\",x);\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\nint nprod = 4, ncons = 4;\nint cap = 5, size = 0, packages = 1000;\nint main()\n{\n  int nthread = nprod + ncons;\n#pragma omp parallel for shared(size, cap, nprod, ncons, nthread) firstprivate(packages) num_threads(nthread)\n  for (int i = 0; i < nthread; i++)\n  {\n    if (i < nprod)\n      while (packages)\n      { // I am a producer\n#pragma omp critical\n        if (size < cap)\n        {\n          size++; // produce\n          packages--; // produced a package\n          printf(\"Producer %d produced! size=%d\\n\", i, size);\n          fflush(stdout);\n        }\n      }\n    else\n      while (packages)\n      { // I am a consumer\n#pragma omp critical\n        if (size > 0)\n        {\n          size--; // consume\n          packages--; // consumed a package\n          printf(\"Consumer %d consumed! size=%d\\n\", i - nprod, size);\n          fflush(stdout);\n        }\n      }\n  }\n}\n"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble c = 0.2;\nint n = 20, nsteps = 100;\n\nint main()\n{\n  double *b = malloc(2 * n * sizeof(double));\n  double *u[2] = {&b[0], &b[n]};\n  for (int i = 1; i < n - 1; i++)\n    u[0][i] = u[1][i] = 1.0 * rand() / RAND_MAX;\n  u[0][0] = u[0][n - 1] = u[1][0] = u[1][n - 1] = 0.5;\n  int p = 0;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u[1 - p][i] = u[p][i] + c * (u[p][i - 1] + u[p][i + 1] - 2 * u[p][i]);\n    }\n    p = 1 - p;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u[p][i]);\n  printf(\"\\n\");\n  free(b);\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  omp_lock_t lck;\n  int var=0,i;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n"}, {"prompt": "#include <assert.h> \n#include <stdio.h>\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Proper user of ordered directive and clause, no data races\n * */\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n#pragma omp ordered\n    {\n      x++;\n    }\n  }\n  assert (x==100);\n  printf (\"x=%d\\n\",x);\n  return 0;\n} \n"}, {"prompt": "#include <stdio.h>\nvoid foo()\n{\n  int q=0; \n  q += 1;\n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  return 0;   \n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\n#define N 8\n\nint main()\n{\n  int i,j,k;\n  double r1[N], r[N][N][N];\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) {\n      for (k = 0; k < N; k++) {\n        r[i][j][k] = i;\n      }\n    }\n  }\n\n\n  #pragma omp parallel for default(shared) private(j,k)\n  for (i = 1; i < N-1; i++) {\n    for (j = 1; j < N-1; j++) {\n      for (k = 0; k < N; k++) {\n        r1[k] = r[i][j-1][k] + r[i][j+1][k] + r[i-1][j][k] + r[i+1][j][k];\n      }\n    }\n  }\n\n  for (k = 0; k < N; k++) printf(\"%f \",r1[k]);\n\n  printf(\"\\n\");\n\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n  int var[N];\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=1; i<N; i++){\n    var[i]=var[i-1]+1;\n  }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf(\"Data Race Present\\n\");\n      return 0;\n    }\n  }\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a)\n      c += a;\n    #pragma omp task depend(in: b)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf(\"%d\\n\",d);\n  return 0;\n}\n"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\nvoid foo(int n, int * restrict  a, int * restrict b, int * restrict  c)\n{\n  int i;\n#pragma omp parallel for \n  for (i = 0; i < n; i++)\n    a[i] = b[i] + c[i];  \n}\n\nint main()\n{\n  int n = 1000;\n  int * a , *b, *c;\n\n  a = (int*) malloc (n* sizeof (int));\n  if (a ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  b = (int*) malloc (n* sizeof (int));\n  if (b ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  c = (int*) malloc (n* sizeof (int));\n  if (c ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  foo (n, a, b,c);\n\n  free (a);\n  free (b);\n  free (c);\n  return 0;\n}  \n\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n  }\n  return 0;\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n  int i;\n  double q[10], qq[10];\n\n  for (i = 0; i < 10; i++) qq[i] = (double)i;\n  for (i = 0; i < 10; i++) q[i] = (double)i;\n\n  #pragma omp parallel default(shared)\n  {\n    #pragma omp for private(i)\n    for (i = 0; i < 10; i++)\n      q[i] += qq[i];\n\n    #pragma omp critical\n    {\n      q[9] += 1.0;\n    }\n    #pragma omp barrier\n    #pragma omp single\n    {\n      q[9] = q[9] - 1.0;\n    }\n\n  } \n\n  for (i = 0; i < 10; i++)printf(\"%f %f\\n\",qq[i],q[i]);\n\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp master\n    {\n      init = 10;\n    }\n\n    local = init;\n  }\n\n  return 0;\n}\n\n\n"}, {"prompt": "#include <stdio.h>\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Classic Fibonacci calculation using task but missing taskwait. \n * Data races pairs: i@61:5:W vs. i@65:14:R\n *                   j@63:5:W vs. j@65:16:R\n * */\nunsigned int input = 10;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n\n    int res= i+j; \n/* We move the original taskwait to a location after i+j to \n * simulate the missing taskwait mistake.\n * Directly removing the taskwait may cause a child task to write to i or j\n * within the stack of a parent task which may already be gone, causing seg fault.\n * This change is suggested by Joachim Protze @RWTH-Aachen. \n * */\n#pragma omp taskwait\n    return res;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf (\"Fib(%d)=%d (correct answer should be 55)\\n\", input, result);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel sections\n  {\n#pragma omp section\n    i = 1;    \n#pragma omp section\n    i = 2;    \n  }\n  printf(\"i=%d\\n\",i);\n  return 0;\n} \n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n) {\n  int i, j, s;\n  if (n < 2)\n    return n;\n#pragma omp task shared(i) depend(out : i)\n  i = fib(n - 1);\n#pragma omp task shared(j) depend(out : j)\n  j = fib(n - 2);\n#pragma omp task shared(i, j) depend(in : j)\n  s = i + j;\n#pragma omp taskwait\n  return i + j;\n}\n\nint main(int argc, char **argv) {\n  int n = 10;\n  if (argc > 1)\n    n = atoi(argv[1]);\n#pragma omp parallel sections\n  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n  return 0;\n}\n"}, {"prompt": "#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n#pragma omp threadprivate(counter)\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, \"malloc() fails\\n\");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n    (*counter)++; \n  }\n  printf(\"%d \\n\", *counter);\n  free (counter);\n  return 0;   \n}\n\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n    else\n    {\n      printf(\"numThreads=%d\\n\", numThreads);\n    }\n  }\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\nint main(int argc, char *argv[]) {\n  int len = 20000;\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[len];\n  for (int i = 0; i < len; i++)\n    a[i] = i;\n  double c = M_PI;\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len; i++)\n    a[i] = a[i] + c;\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  int len = 20000;\n\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[2 * len], b[len];\n\n  for (int i = 0; i < 2 * len; i++)\n    a[i] = i;\n  for (int i = 0; i < len; i++)\n    b[i] = i + 1;\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len; i++)\n    a[i * 2] = a[i * 2] + b[i];\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(){\n\n  int a[4];\n  int psum[2];\n  int sum;\n\n  #pragma omp parallel num_threads(2)\n  {\n    #pragma omp for schedule(dynamic, 1)\n    for (int i=0; i < 4; ++i){\n      a[i] = i;\n      int s;\n      s = (- 3 - 3) / - 3;\n    }\n\n    #pragma omp single\n    {\n      #pragma omp task\n      {\n       #pragma omp task\n       {\n         psum[1] = a[2] + a[3];\n       }\n        psum[0] = a[0] + a[1];\n      }\n\n      #pragma omp taskwait\n      sum = psum[1] + psum[0];\n    }\n  }\n\n  printf(\"sum = %d\\n\", sum);\n  return 0;\n }\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1, l2;\nconst int n = 100;\nint x = 1;\n\nvoid barrier_init()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n  omp_init_lock(&l2);\n}\n\nvoid barrier_destroy()\n{\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  omp_destroy_lock(&l2);\n}\n\nvoid barrier_start(int tid)\n{\n  if (tid == 0)\n  {\n    omp_set_lock(&l0);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l1);\n  }\n}\n\nvoid barrier_stop(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_unset_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_unset_lock(&l1);\n  }\n}\n\nvoid barrier_wait(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    omp_unset_lock(&l2);\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    omp_set_lock(&l2);\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    omp_unset_lock(&l2);\n  }\n}\n\nint main()\n{\n  barrier_init();\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    barrier_start(tid);\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 1);\n      barrier_wait(tid);\n      if (tid == 0)\n        x = 0;\n      barrier_wait(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 0);\n      barrier_wait(tid);\n      if (tid == 1)\n        x = 1;\n      barrier_wait(tid);\n    }\n#pragma omp barrier\n    barrier_stop(tid);\n  } // end of parallel construct\n  barrier_destroy();\n  printf(\"Done: x=%d\\n\", x);\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              //2nd child task\n\n  #pragma omp task depend(in: x) if(0)                                  // 1st taskwait\n  {}\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                                  // 2nd taskwait\n\n  printf(\"y=%d\\n\",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\nint main(){\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for simd safelen(C)\n  for (int i=C; i<N; i++){\n    var[i]=var[i-C]+1;\n  }\n\n  printf(\"%d\\n\",var[97]);\n\n  return 0;\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int k;\n\n#pragma omp parallel\n  {\n#pragma omp master\n    {\n      k = omp_get_num_threads();\n      printf (\"Number of Threads requested = %i\\n\",k);\n    }\n  }\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n\n/*\nuse of omp target + teams \nWithout protection, master threads from two teams cause data races.\nData race pair: a[50]@66:5:W vs. a[50]@66:5:W\n*/\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 100;\n  double a[len];\n\n  /*Initialize with some values*/\n  for (i=0; i<len; i++)\n    a[i]= ((double)i)/2.0;\n\n#pragma omp target map(tofrom: a[0:len]) \n#pragma omp teams num_teams(2) \n  {\n    a[50]*=2.0;\n  }\n\n  printf (\"a[50]=%f\\n\", a[50]);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  int len = 20000;\n\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[len], b[len];\n\n  for (int i = 0; i < len; i++) {\n    a[i] = i;\n    b[i] = i + 1;\n  }\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len - 64; i++)\n    a[i + 64] = a[i] + b[i];\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n/*\n * This is a program based on a dataset contributed by \n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n \n * Race because the write to s is not protected by atomic\n * Data race pair: s@26:7:W vs. s@34:16:R\n */\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n      s = 1;\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp atomic read seq_cst\n        done = s;\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n"}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) // Note there will be out of bound access\n      b[i][j]=b[i][j-1];\n\n return 0;     \n}\n  \n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n    #pragma omp parallel for ordered\n    for (int i=1; i<N; i++){\n      #pragma omp ordered\n      {\n        var[i]=var[i-1]+1;\n      }\n    }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf(\"Data Race Present\");\n      return 0;\n    }\n  }\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n/*\nTwo-dimension array computation with a vectorization directive\ncollapse(2) makes simd associate with 2 loops.\nLoop iteration variables should be predetermined as lastprivate. \n*/\nint main()\n{\n  int len=100;\n  double a[len][len], b[len][len], c[len][len];\n  int i,j;\n\n  for (i=0;i<len;i++)\n    for (j=0;j<len;j++)\n    {\n      a[i][j]=((double)i)/2.0; \n      b[i][j]=((double)i)/3.0; \n      c[i][j]=((double)i)/7.0; \n    }\n\n#pragma omp simd collapse(2)\n  for (i=0;i<len;i++)\n    for (j=0;j<len;j++)\n      c[i][j]=a[i][j]*b[i][j];\n\n  printf (\"c[50][50]=%f\\n\",c[50][50]);\n  return 0;\n}\n"}, {"prompt": "#include<stdio.h>\n#include<assert.h>\nvoid f1(int *q)\n{\n  *q = 1;\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  #pragma omp parallel reduction(+:sum) num_threads(10) private(i)\n  {\n     f1(&i);\n     sum+= i; \n  }\n  assert (sum==10);\n  printf(\"sum=%d\\n\", sum);\n  return 0;   \n}\n"}, {"prompt": "#include <stdlib.h>\nvoid setup(int N)\n{\n  double * m_pdv_sum = (double* ) malloc (sizeof (double) * N );\n  double * m_nvol = (double* ) malloc (sizeof (double) * N );\n\n#pragma omp parallel for schedule(static)\n  for (int i=0; i < N; ++i ) \n  { \n    m_pdv_sum[ i ] = 0.0;\n    m_nvol[ i ]   = i*2.5;\n  }\n\n  free(m_pdv_sum);\n  free(m_nvol);\n}\n\nint main()\n{\n  int N =1000;\n  setup(N);\n}\n  \n"}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[len][len];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  return 0;\n}\n"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble c = 0.2;\nint n = 20, nsteps = 100;\n\nint main()\n{\n  double *b = malloc(2 * n * sizeof(double));\n  double *u[2] = {&b[0], &b[n - 2]}; // oops, should be b[n]\n  for (int i = 1; i < n - 1; i++)\n    u[0][i] = u[1][i] = 1.0 * rand() / RAND_MAX;\n  u[0][0] = u[0][n - 1] = u[1][0] = u[1][n - 1] = 0.5;\n  int p = 0;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u[1 - p][i] = u[p][i] + c * (u[p][i - 1] + u[p][i + 1] - 2 * u[p][i]);\n    }\n    p = 1 - p;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u[p][i]);\n  printf(\"\\n\");\n  free(b);\n}"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nvoid foo()\n{\n  static int q; \n  q += 1;\n}\n\nint main()\n{ \n  #pragma omp parallel \n  {\n     foo();\n  }\n  return 0;   \n}\n\n"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  int a[1000];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  printf(\"a[500]=%d\\n\", a[500]);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n\nint main()\n{\n  int count=0;\n\n#pragma omp parallel shared(count) \n  {\n#pragma omp single\n    count += 1;\n  }\n\n  printf (\"count= %d\\n\", count);\n  return 0;\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections\n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var)\n      {\n        var++;\n      }\n    }\n  }\n\n  if (var!=10) printf(\"%d\\n\",var);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Missing the ordered clause\n * Data race pair: x@56:5:W vs. x@56:5:W\n * */\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n    x++;\n  }\n  printf (\"x=%d\\n\",x);\n  return 0;\n} \n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp task depend(in: x) if(0)                // 1st taskwait\n  {}\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n  #pragma omp taskwait                                // 2nd taskwait\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task shared(x) mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf(\"%d\\n\",x);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    if (tid == 0)\n    {\n      omp_set_lock(&l);\n      x = 0;\n      omp_unset_lock(&l);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l);\n      omp_unset_lock(&l);\n      x = 1;\n    }\n#pragma omp barrier\n  } // end of parallel construct\n  omp_destroy_lock(&l);\n  printf(\"Done: x=%d\\n\", x);\n}"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp taskwait depend(in: x)                  // 1st taskwait\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                // 2nd taskwait\n\n  printf(\"y=%d\\n\",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n\n  int a[2000];\n\n  for (i=0; i<2000; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<1000;i++)\n    a[2*i+1]=a[i]+1;\n\n  printf(\"a[1001]=%d\\n\", a[1001]);  \n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf(\"%d\\n \",var[i]);\n  }\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  int a[1000];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  printf (\"a[500]=%d\\n\", a[500] );\n  return 0;\n} \n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a) depend(mutexinoutset: c)\n      c += a;\n    #pragma omp task depend(in: b) depend(mutexinoutset: c)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf(\"%d\\n\",d);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp barrier\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a += i;\n    }\n\n    #pragma omp single\n    printf(\"Sum is %d\\n\", a);\n  }\n\n  return 0;\n}\n"}, {"prompt": "#include <omp.h>\n#include <assert.h> \nint main()\n{\n  omp_lock_t lck;\n  int i=0;\n  omp_init_lock(&lck);\n#pragma omp parallel sections\n  {\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 1;    \n      omp_unset_lock(&lck);\n    }\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 2;    \n      omp_unset_lock(&lck);\n    }\n  }\n\n  omp_destroy_lock(&lck);\n  assert (i==3);\n  return 0;\n} \n"}, {"prompt": "#include <stdio.h>\nint a[100][100];\nint b[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for default(none) shared(a) private(i,j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n\n#pragma omp parallel for default(shared) private(i,j)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      b[i][j]=b[i][j]+1;\n\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  int len = 20000;\n\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[2 * len], b[len];\n\n  for (int i = 0; i < 2 * len; i++)\n    a[i] = i;\n  for (int i = 0; i < len; i++)\n    b[i] = i + 1;\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len; i++)\n    a[i + 64] = a[i * 2] + b[i];\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n\n  return 0;\n}\n"}, {"prompt": "#include <assert.h> \n#include <unistd.h>\n#include \"signaling.h\"\nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      delay(10000);\n      i = 1;    \n    }\n#pragma omp task depend (out:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n"}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=100, m=100;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) // Note there will be out of bound access\n      b[i][j]=b[i][j-1];\n\n  printf (\"b[50][50]=%f\\n\",b[50][50]);\n\n  return 0;     \n}\n  \n"}, {"prompt": "#include<stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[len], b[len];\n\n  for (i=0;i<len;i++)\n  {  a[i]=i; b[i]=i;} \n/* static storage for a local variable */\n#pragma omp parallel \n  {\n    static int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = a[i]+i;\n      a[i] = tmp;\n    }\n  }\n\n/* automatic storage for a local variable */\n#pragma omp parallel \n  {\n    int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = b[i]+i;\n      b[i] = tmp;\n    }\n  }\n\n  printf(\"a[50]=%d b[50]=%d\\n\", a[50], b[50]);\n \n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf (\"a[50][50]=%d\\n\", a[50][50]);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100], b[100];\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n\n#pragma omp parallel for simd \n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+b[i];\n\n  printf(\"a[50]=%d\\n\",a[50]);\n  return 0;\n}\n"}, {"prompt": "#include <stdlib.h>\ntypedef double real8;\n\nvoid foo(real8 * restrict newSxx, real8 * restrict newSyy, int length)\n{\n  int i;\n\n#pragma omp parallel for private (i) firstprivate (length)\n  for (i = 0; i <= length - 1; i += 1) {\n    newSxx[i] = 0.0;\n    newSyy[i] = 0.0;\n  }\n}\n\nint main()\n{\n  int length=1000;\n  real8* newSxx = malloc (length* sizeof (real8));\n  real8* newSyy = malloc (length* sizeof (real8));\n\n  foo(newSxx, newSyy, length);\n\n  free (newSxx);\n  free (newSyy);\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n#define N 1000\ndouble a[N][N],v[N],v_out[N];\n\nvoid mv()\n{           \n  int i,j;\n  for (i = 0; i < N; i++)\n  {         \n    float sum = 0.0;\n#pragma omp parallel for reduction(+:sum)\n    for (j = 0; j < N; j++)\n    { \n      sum += a[i][j]*v[j];\n    }  \n    v_out[i] = sum;\n  }         \n}\n\nint main()\n{\n  mv();\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE, mits=1000;\ndouble tol=0.0000000001, relax = 1.0, alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n/* Initialize initial condition and RHS */\n//#pragma omp parallel for private(i,j,xx,yy)\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       /* -1 < x < 1 */\n      yy = (int) (-1.0 + dy * (j - 1));       /* -1 < y < 1 */\n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nvoid\njacobi ()\n{\n  double omega;\n  int i, j, k;\n  double error, resid,  ax, ay, b;\n\n  omega = relax;\n/* Initialize coefficients */\n\n  dx = 2.0 / (n - 1); \n  dy = 2.0 / (m - 1);\n\n  ax = 1.0 / (dx * dx);         /* X-direction coef */\n  ay = 1.0 / (dy * dy);         /* Y-direction coef */\n  b = -2.0 / (dx * dx) - 2.0 / (dy * dy) - alpha;       /* Central coeff */\n\n  error = 10.0 * tol;\n  k = 1;\n\n  while (k <= mits)\n    {\n      error = 0.0;\n\n/* Copy new solution into old */\n#pragma omp parallel\n      {\n#pragma omp for private(i,j)\n        for (i = 0; i < n; i++)\n          for (j = 0; j < m; j++)\n            uold[i][j] = u[i][j];\n#pragma omp for private(i,j,resid) reduction(+:error) nowait\n        for (i = 1; i < (n - 1); i++)\n          for (j = 1; j < (m - 1); j++)\n            {\n              resid = (ax * (uold[i - 1][j] + uold[i + 1][j])\n                       + ay * (uold[i][j - 1] + uold[i][j + 1]) +\n                       b * uold[i][j] - f[i][j]) / b;\n\n              u[i][j] = uold[i][j] - omega * resid;\n              error = error + resid * resid;\n            }\n      }\n/*  omp end parallel */\n\n/* Error check */\n\n     k = k + 1;\n      error = sqrt (error) / (n * m);\n    }                           /*  End iteration loop */\n\n  printf (\"Total Number of Iterations:%d\\n\", k);\n  printf (\"Residual:%E\\n\", error);\n}\n\nint main()\n{\n  initialize();\n  jacobi();\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint a[100], b[100], c[100];\nint main()\n{\n  int i;\n#pragma omp simd\n  for (i=0;i<100;i++)\n    a[i]=b[i]*c[i];\n  return 0;\n}\n"}, {"prompt": "#include <assert.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    i = 1;    \n#pragma omp task depend (in:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n"}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  int a[100];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n\n  printf(\"a[50]=%d\\n\", a[50]);\n  return 0;\n}\n"}, {"prompt": "#include <stdlib.h>  \n#include <stdio.h>\nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  int numNodes=len, numNodes2=0; \n  int x[100]; \n\n  // initialize x[]\n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }\n  printf (\"numNodes2 = %d\\n\", numNodes2);\n  return 0;\n} \n"}, {"prompt": "#include<stdio.h>\n#include<assert.h>\n\nvoid f1(int *q)\n{\n#pragma omp critical\n  *q = 1;\n#pragma omp flush\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  \n  #pragma omp parallel reduction(+:sum) num_threads(10) \n  {\n     f1(&i);\n     sum+=i;\n  }\n  assert (sum==10);\n  printf(\"sum=%d\\n\", sum);\n  return 0;   \n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute\n  for (int i=0; i<N; i++){\n    #pragma omp atomic update\n    var++;\n  }\n  printf(\"%d\\n \",var);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for collapse(2)\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nstatic double x[20];\n#pragma omp threadprivate(x)\n\nint main(){\n  int i;\n  double j,k;\n\n  #pragma omp parallel for default(shared)\n  for (i = 0; i < 20; i++){\n    x[i] = -1.0;\n    if(omp_get_thread_num()==0){\n      j = x[0];\n    }\n    if(omp_get_thread_num()==0){\n      k = i+0.05;\n    }\n  }\n\n  printf (\"%f %f\\n\", j, k);\n\n  return 0;\n}\n\n"}, {"prompt": "#include<stdio.h>\n\n/*  argument pass-by-reference */\nvoid f1(int* q)\n{\n  *q += 1;\n}\n\nint main()\n{ \n  int i=0; \n  #pragma omp parallel \n  {\n     f1(&i);\n  }\n  printf (\"i=%d\\n\",i);\n  return 0;   \n}\n"}, {"prompt": "#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n//#pragma omp threadprivate(sum0)\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n/*  reference calculation */\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n//  assert(sum==sum1);\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\nint a[100];\nint main()\n{\nint i;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    a[i]=a[i]+1;\n  return 0;\n} \n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n#pragma omp taskwait\n    }\n\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n#pragma omp taskwait\n    }\n  }\n\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nvoid foo(int * a, int n, int g)\n{\n  int i;\n#pragma omp parallel for firstprivate (g)\n  for (i=0;i<n;i++)\n  {\n    a[i] = a[i]+g;\n  }\n}\n\nint a[100];\nint main()\n{\n  foo(a, 100, 7);\n  return 0;\n}  \n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 64\n\nfloat a;\nfloat x[C];\nfloat y[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    a=5;\n    x[i]=0;\n    y[i]=3;\n  }\n\n  #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) device(0)\n  {\n    for(int i=0; i<C; i++){\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = a * x[i];\n      }\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = x[i] + y[i];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(x[i]!=3){\n      printf(\"Data Race Detected\\n\");\n      return 0;\n    }\n  }\n\n  #pragma omp taskwait\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 100\n\nint *a;\nint *b;\nint *c;\n\nint main(){\n  a = malloc(C*sizeof(int));\n  b = malloc(C*C*sizeof(int));\n  c = malloc(C*sizeof(int));\n\n  for(int i=0; i<C; i++){\n    for(int j=0; j<C; j++){\n      b[j+i*C]=1;\n    }\n    a[i]=1;\n    c[i]=0;\n  }\n\n  #pragma omp target map(to:a[0:C],b[0:C*C]) map(tofrom:c[0:C]) device(0)\n  {\n    #pragma omp teams distribute parallel for\n    for(int i=0; i<C; i++){\n      for(int j=0; j<C; j++){\n        c[i]+=b[j+i*C]*a[j];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(c[i]!=C){\n      printf(\"Data Race\\n\");\n      return 1;\n    }\n  }\n\n  free(a);\n  free(b);\n  free(c);\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a = a + i;\n    }\n\n    #pragma omp single\n    printf(\"Sum is %d\\n\", a);\n  }\n\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int& i)\n{\n#pragma omp task\n  {\n    a[i]= i+1;\n  }\n}\n\nint main()\n{\n  int i=0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n      for (i=0; i<MYLEN; i++)\n      {\n        gen_task(i);\n      }\n    }\n  }\n  \n  /* correctness checking */\n  for (i=0; i<MYLEN; i++)\n  {\n    //assert (a[i]==i+1);\n    if (a[i]!= i+1)\n    {\n      printf(\"warning: a[%d] = %d, not expected %d\\n\", i, a[i], i+1);\n    }\n  }\n  return 0;\n}\n\n"}, {"prompt": "#include <stdio.h>\n\nint cap = 10, size = 0, packages = 1000;\nunsigned r = 0;\n\nint main()\n{\n#pragma omp parallel sections shared(size, cap) firstprivate(r, packages) num_threads(2)\n  {\n#pragma omp section\n    while (packages)\n    {\n#pragma omp critical\n      {\n        if (size < cap)\n        {\n          size++; // produce\n          packages--; // produced a package\n          printf(\"Produced! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n#pragma omp section\n    while (packages)\n    {\n#pragma omp critical\n      {\n        if (size > 0)\n        {\n          size--; // consume\n          packages--; // consumed a package\n          printf(\"Consumed! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1500; i++)\n        r = (r + 1) % 10;\n    }\n  }\n}\n"}, {"prompt": "#include <stdio.h>\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n\n/*\nuse of omp target + teams + distribute + parallel for\n*/\nint main(int argc, char* argv[])\n{\n  int i, i2;\n  int len = 2560;\n  double sum =0.0, sum2=0.0;\n  double a[len], b[len];\n  /*Initialize with some values*/\n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]= ((double)i)/3.0;\n  }\n\n#pragma omp target map(to: a[0:len], b[0:len]) map(tofrom: sum)\n#pragma omp teams num_teams(10) thread_limit(256) reduction (+:sum) \n#pragma omp distribute\n  for (i2=0; i2< len; i2+=256)  \n#pragma omp parallel for reduction (+:sum)\n    for (i=i2;i< min(i2+256, len); i++)\n      sum += a[i]*b[i];\n\n/* CPU reference computation */  \n#pragma omp parallel for reduction (+:sum2)\n    for (i=0;i< len; i++)\n      sum2 += a[i]*b[i];\n  printf (\"sum=%f sum2=%f\\n\", sum, sum2);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i, m=1, n=4;\n  int b[4] = {};\n\n  #pragma omp simd safelen(2)\n  for (i = m; i<n; i++)\n    b[i] = b[i-m] - 1.0f;\n\n  printf(\"Expected: -1; Real: %d\\n\",b[3]);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n  int thrd = omp_get_thread_num();\n  if (thrd == 0) {\n    #pragma omp critical\n    { x = 10; }\n\n    #pragma omp flush(x)\n\n    #pragma omp atomic write\n    y = 1;\n  } else {\n      int tmp = 0;\n      while (tmp == 0) {\n      #pragma omp atomic read acquire\n      tmp = y;\n      }\n    #pragma omp critical\n    { if (x!=10) printf(\"x = %d\\n\", x); }\n  }\n  }\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l0);\n    else if (tid == 1)\n      omp_set_lock(&l1);\n#pragma omp barrier\n    if (tid == 0)\n      x = 0;\n    if (tid == 0)\n    {\n      omp_unset_lock(&l0);\n      omp_set_lock(&l0);\n    }\n    else if (tid == 1)\n    {\n      omp_unset_lock(&l1);\n      omp_set_lock(&l1);\n    }\n    if (tid == 1)\n      x = 1;\n#pragma omp barrier\n    if (tid == 0)\n      omp_unset_lock(&l1);\n    else if (tid == 1)\n      omp_unset_lock(&l0);\n  } // end of parallel construct\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  printf(\"Done: x=%d\\n\", x);\n}\n"}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  int var=0,i;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    var++;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n"}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n\n#pragma omp target map(a[0:len])\n#pragma omp parallel for\n  for (i=0;i< len;i++)\n    a[i]=a[i]+1;\n\n  return 0;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, data_type* const dist_n, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        // LivelockBug here\n        if (new_dist <= d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist_n[v], d);\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = malloc(g.nodes * sizeof(data_type));\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, dist_new, goagain);\n    SWAP(dist, dist_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n\n    if (updated) {\n      // MixSyncBug here\n      atomicWrite(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = atomicRead(&dist[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        // LivelockBug here\n        if (d >= new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      atomicWrite(&dist[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        // LivelockBug here\n        if (new_dist <= d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist[v], d);\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        // LivelockBug here\n        if (d >= new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n\n    if (updated) {\n      critical_min(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // RaceBug here\n    data_type d = dist[v];\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      // RaceBug here\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (new_dist < d) {\n          d = new_dist;\n          // RaceBug here\n          atomicWrite(goagain, 1);\n        }\n      }\n      // RaceBug here\n      dist[v] = d;\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        // RaceBug here\n        const data_type d = dist[dst];\n        if (d > new_dist) {\n          // RaceBug here\n          dist[dst] = new_dist;\n          wl2[fetch_and_add(wl2size)] = dst;\n          update = true;\n        }\n      }\n      if (update) {\n        wl2[fetch_and_add(wl2size)] = src;\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n\n    if (updated) {\n      // MixSyncBug here\n      atomicWrite(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[v];\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n        // RaceBug here\n        const data_type d = dist[dst];\n        if (d > new_dist) {\n          // RaceBug here\n          dist[dst] = new_dist;\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, data_type* const dist_n, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        // LivelockBug here\n        if (new_dist <= d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist_n[v], d);\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = malloc(g.nodes * sizeof(data_type));\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, dist_new, goagain);\n    SWAP(dist, dist_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n        const data_type d = atomicRead(&dist[dst]);\n        // LivelockBug here\n        if (d >= new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < g.nodes; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_edge_data(const ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // RaceBug here\n    const data_type s = dist[src];\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      // RaceBug here\n      data_type d = dist[dst];\n      if (d > new_dist) {\n        // RaceBug here\n        dist[dst] = new_dist;\n        if (critical_max(&time[e], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = e;\n        }\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* time = (int*) malloc(g.edges * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[v];\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n        // RaceBug here\n        const data_type d = dist[dst];\n        if (d > new_dist) {\n          // RaceBug here\n          dist[dst] = new_dist;\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      const data_type d = atomicRead(&dist[dst]);\n      // LivelockBug here\n      if (d >= new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        const data_type d = atomicRead(&dist[dst]);\n        // LivelockBug here\n        if (d >= new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          wl2[fetch_and_add(wl2size)] = dst;\n          update = true;\n        }\n      }\n      if (update) {\n        wl2[fetch_and_add(wl2size)] = src;\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[src];\n\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      // RaceBug here\n      const data_type d = dist[dst];\n      if (d > new_dist) {\n        // RaceBug here\n        dist[dst] = new_dist;\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < g.nodes; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_edge_data(const ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* time = (int*) malloc(g.edges * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        // LivelockBug here\n        if (d >= new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n\n    if (updated) {\n      critical_min(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        const data_type d = atomicRead(&dist[dst]);\n        // LivelockBug here\n        if (d >= new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n          update = true;\n        }\n      }\n      if (update) {\n        if (critical_max(&time[src], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = src;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      const data_type d = atomicRead(&dist[dst]);\n      // LivelockBug here\n      if (d >= new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = atomicRead(&dist[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        // LivelockBug here\n        if (d >= new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      atomicWrite(&dist[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // RaceBug here\n    data_type d = dist[v];\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      // RaceBug here\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (new_dist < d) {\n          d = new_dist;\n          // RaceBug here\n          atomicWrite(goagain, 1);\n        }\n      }\n      // RaceBug here\n      dist[v] = d;\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < g.nodes; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_edge_data(const ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      data_type d = atomicRead(&dist[dst]);\n      // LivelockBug here\n      if (d >= new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        if (critical_max(&time[e], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = e;\n        }\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* time = (int*) malloc(g.edges * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      // RaceBug here\n      dist_n[src] = s;\n    }\n\n    if (updated) {\n      critical_min(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < g.nodes; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_edge_data(const ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      data_type d = atomicRead(&dist[dst]);\n      // LivelockBug here\n      if (d >= new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        if (critical_max(&time[e], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = e;\n        }\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* time = (int*) malloc(g.edges * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      // RaceBug here\n      dist_n[src] = s;\n    }\n\n    if (updated) {\n      critical_min(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < g.nodes; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_edge_data(const ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* time = (int*) malloc(g.edges * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        // RaceBug here\n        const data_type d = dist[dst];\n        if (d > new_dist) {\n          // RaceBug here\n          dist[dst] = new_dist;\n          wl2[fetch_and_add(wl2size)] = dst;\n          update = true;\n        }\n      }\n      if (update) {\n        wl2[fetch_and_add(wl2size)] = src;\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        const data_type d = atomicRead(&dist[dst]);\n        // LivelockBug here\n        if (d >= new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          wl2[fetch_and_add(wl2size)] = dst;\n          update = true;\n        }\n      }\n      if (update) {\n        wl2[fetch_and_add(wl2size)] = src;\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[src];\n\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      // RaceBug here\n      const data_type d = dist[dst];\n      if (d > new_dist) {\n        // RaceBug here\n        dist[dst] = new_dist;\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n        const data_type d = atomicRead(&dist[dst]);\n        // LivelockBug here\n        if (d >= new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        // LivelockBug here\n        if (new_dist <= d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist[v], d);\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        const data_type d = atomicRead(&dist[dst]);\n        // LivelockBug here\n        if (d >= new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n          update = true;\n        }\n      }\n      if (update) {\n        if (critical_max(&time[src], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = src;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        // RaceBug here\n        const data_type d = dist[dst];\n        if (d > new_dist) {\n          // RaceBug here\n          dist[dst] = new_dist;\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n          update = true;\n        }\n      }\n      if (update) {\n        if (critical_max(&time[src], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = src;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        // RaceBug here\n        const data_type d = dist[dst];\n        if (d > new_dist) {\n          // RaceBug here\n          dist[dst] = new_dist;\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n          update = true;\n        }\n      }\n      if (update) {\n        if (critical_max(&time[src], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = src;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < g.nodes; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_edge_data(const ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // RaceBug here\n    const data_type s = dist[src];\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      // RaceBug here\n      data_type d = dist[dst];\n      if (d > new_dist) {\n        // RaceBug here\n        dist[dst] = new_dist;\n        if (critical_max(&time[e], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = e;\n        }\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* time = (int*) malloc(g.edges * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const lost, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    lost[v] = 0;\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n    // go over all edges\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    // if one is included, exclude the other\n    // RaceBug here\n    if (status[src] == included) {\n      // RaceBug here\n      status[dst] = excluded;\n    }\n    // RaceBug here\n    else if (status[dst] == included) {\n      // RaceBug here\n      status[src] = excluded;\n    }\n    // if neither included nor excluded -> mark lower priority node as lost\n    // RaceBug here\n    else if (status[src] != excluded && status[dst] != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(data_type* const status, data_type* const lost, const int size, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < size; v++) {\n    // go over all vertexes\n    if (lost[v] == 0) {\n      if(status[v] == undecided) {\n        status[v] = included;\n      }\n    }\n    else {\n      atomicWrite(goagain, 1);\n      lost[v] = 0; //reset lost flag\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* lost = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, lost, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, lost);\n\n\n    // vertex pass\n    mis_vertex_pass(status, lost, g.nodes, goagain);\n\n  } while (*goagain);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(lost);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        wl2[criticalAdd(wl2size, 1)] = v;\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          // RaceBug here\n          status_n[g.nlist[i]] = excluded;\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new =  malloc(sizeof(data_type) * g.nodes);;\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size);\n\n    updateFromWorklist(status, status_new, wl1, *wl1size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, int* const status, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, int* const status, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        atomicWrite(goagain, 1);\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        // RaceBug here\n        status[v] = included;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          // RaceBug here\n          status[g.nlist[i]] = excluded;\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, int* status)\n{\n\n  init(priority, status, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, goagain);\n\n  } while(*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, int* const status, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, int* const status, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        atomicWrite(goagain, 1);\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        // RaceBug here\n        status[v] = included;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          // RaceBug here\n          status[g.nlist[i]] = excluded;\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, int* status)\n{\n\n  init(priority, status, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, goagain);\n\n  } while(*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && (status[g.nlist[i]] != included) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        // RaceBug here\n        if (status[g.nlist[i]] == included) {\n          // found included neighbor -> exclude self\n          // RaceBug here\n          status_n[v] = excluded;\n        } else {\n          atomicWrite(goagain, 1);\n        }\n      } else {\n        // no such neighbor -> v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    updateUndecided(status, status_new, g.nodes);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, int* const status, int* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, int* const status, int* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        atomicWrite(goagain, 1);\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          // RaceBug here\n          status_n[g.nlist[i]] = excluded;\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, int* status)\n{\n  int* status_new = malloc(g.nodes * sizeof(int));\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n  } while(*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, int* const status, int* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, int* const status, int* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        atomicWrite(goagain, 1);\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          // RaceBug here\n          status_n[g.nlist[i]] = excluded;\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, int* status)\n{\n  int* status_new = malloc(g.nodes * sizeof(int));\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n  } while(*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, int* const status, int* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, int* const status, int* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        atomicWrite(goagain, 1);\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          // RaceBug here\n          status_n[g.nlist[i]] = excluded;\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, int* status)\n{\n  int* status_new = malloc(sizeof(int) * g.nodes);\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    updateUndecided(status, status_new, g.nodes);\n  } while(*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    lost[v] = 0;\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n    // go over all edges\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    // if one is included, exclude the other\n    // RaceBug here\n    if (status[src] == included) {\n      // RaceBug here\n      status_n[dst] = excluded;\n    }\n    // RaceBug here\n    else if (status[dst] == included) {\n      // RaceBug here\n      status_n[src] = excluded;\n    }\n    // if neither included nor excluded -> mark lower priority node as lost\n    // RaceBug here\n    else if (status[src] != excluded && status[dst] != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(data_type* const status, data_type* const status_n, data_type* const lost, const int size, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < size; v++) {\n    // go over all vertexes\n    if (lost[v] == 0) {\n      if(status[v] == undecided) {\n        status_n[v] = included;\n      }\n    }\n    else {\n      atomicWrite(goagain, 1);\n      lost[v] = 0; //reset lost flag\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  data_type* lost = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, lost, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, status_new, lost);\n\n    updateUndecided(status, status_new, g.nodes);\n\n    // vertex pass\n    mis_vertex_pass(status, status_new, lost, g.nodes, goagain);\n\n    updateUndecided(status, status_new, g.nodes);\n  } while (*goagain);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(lost);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && (status[g.nlist[i]] != included) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        // RaceBug here\n        if (status[g.nlist[i]] == included) {\n          // found included neighbor -> exclude self\n          // RaceBug here\n          status_n[v] = excluded;\n        } else {\n          atomicWrite(goagain, 1);\n        }\n      } else {\n        // no such neighbor -> v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    time[v] = 0;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && (status[g.nlist[i]] != included) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        // RaceBug here\n        if (status[g.nlist[i]] == included) {\n          // found included neighbor -> exclude self\n          // RaceBug here\n          status_n[v] = excluded;\n          // and WL neighbors\n          for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n            if(critical_max(&time[g.nlist[j]], iter) != iter) {\n              wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n            }\n          }\n        }\n      } else {\n        // no included neighbor -> v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n        // and WL neighbors\n        for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n          if(critical_max(&time[g.nlist[j]], iter) != iter) {\n            wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);;\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size, time);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    updateFromWorklist(status, status_new, wl1, *wl1size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    lost[v] = 0;\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n    // go over all edges\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    // if one is included, exclude the other\n    // RaceBug here\n    if (status[src] == included) {\n      // RaceBug here\n      status_n[dst] = excluded;\n    }\n    // RaceBug here\n    else if (status[dst] == included) {\n      // RaceBug here\n      status_n[src] = excluded;\n    }\n    // if neither included nor excluded -> mark lower priority node as lost\n    // RaceBug here\n    else if (status[src] != excluded && status[dst] != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(data_type* const status, data_type* const status_n, data_type* const lost, const int size, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < size; v++) {\n    // go over all vertexes\n    if (lost[v] == 0) {\n      if(status[v] == undecided) {\n        status_n[v] = included;\n      }\n    }\n    else {\n      atomicWrite(goagain, 1);\n      lost[v] = 0; //reset lost flag\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  data_type* lost = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, lost, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, status_new, lost);\n\n    updateUndecided(status, status_new, g.nodes);\n\n    // vertex pass\n    mis_vertex_pass(status, status_new, lost, g.nodes, goagain);\n\n    updateUndecided(status, status_new, g.nodes);\n  } while (*goagain);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for schedule(dynamic)\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(lost);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        wl2[criticalAdd(wl2size, 1)] = v;\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          // RaceBug here\n          status_n[g.nlist[i]] = excluded;\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, int* const status, int* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, int* const status, int* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        atomicWrite(goagain, 1);\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          // RaceBug here\n          status_n[g.nlist[i]] = excluded;\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, int* status)\n{\n  int* status_new = malloc(sizeof(int) * g.nodes);\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    updateUndecided(status, status_new, g.nodes);\n  } while(*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < g.nodes; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    lost[v] = 0;\n  }\n  *wlsize = 0;\n  for (int e = 0; e < g.edges; e++)\n  {\n    // initialize worklist\n    if (sp[e] < g.nlist[e]) {\n      wl1[(*wlsize)++] = e;\n    }\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, const data_type* const priority, data_type* const status, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all edges in wl1\n    int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if one is included, exclude the other\n    // RaceBug here\n    if (status[src] == included) {\n      // RaceBug here\n      status[dst] = excluded;\n    }\n    // RaceBug here\n    else if (status[dst] == included) {\n      // RaceBug here\n      status[src] = excluded;\n    }\n    // if neither included nor excluded -> mark lower as lost\n    // RaceBug here\n    else if (status[src] != excluded && status[dst] != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    const int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if src node won\n    if (lost[src] == 0) {\n      // RaceBug here\n      if (status[src] == undecided) {\n        // and is undecided -> include\n        // RaceBug here\n        status[src] = included;\n      }\n    }\n    // if dst node won\n    if (lost[dst] == 0) {\n      if (atomicRead(&status[dst]) == undecided) {\n        // and is undecided -> include\n        // RaceBug here\n        status[dst] = included;\n      }\n    }\n    if (atomicRead(&status[src]) == undecided || atomicRead(&status[dst]) == undecided) {\n      // if either node is still undecided, keep edge in WL\n      wl2[criticalAdd(wl2size, 1)] = e;\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* lost = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(size * sizeof(int));\n  int* wl2 = malloc(size * sizeof(int));\n  int* wl1size = malloc(size * sizeof(int));\n  int* wl2size = malloc(size * sizeof(int));\n\n  init(g, sp, priority, status, lost, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, lost, wl1, *wl1size, wl2, wl2size);\n\n\n    // vertex pass\n    mis_vertex_pass(g, sp, priority, status, lost, wl1, *wl1size, wl2, wl2size);\n\n\n    for (int i = 0; i < g.nodes; i++) {\n      lost[i] = 0;\n    }\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(lost);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && (status[g.nlist[i]] != included) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        // RaceBug here\n        if (status[g.nlist[i]] == included) {\n          // found included neighbor -> exclude self\n          // RaceBug here\n          status_n[v] = excluded;\n        } else {\n          atomicWrite(goagain, 1);\n        }\n      } else {\n        // no such neighbor -> v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    updateUndecided(status, status_new, g.nodes);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        wl2[criticalAdd(wl2size, 1)] = v;\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          // RaceBug here\n          status_n[g.nlist[i]] = excluded;\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new =  malloc(sizeof(data_type) * g.nodes);;\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size);\n\n    updateFromWorklist(status, status_new, wl1, *wl1size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        wl2[criticalAdd(wl2size, 1)] = v;\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          // RaceBug here\n          status_n[g.nlist[i]] = excluded;\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < g.nodes; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    lost[v] = 0;\n  }\n  *wlsize = 0;\n  for (int e = 0; e < g.edges; e++)\n  {\n    // initialize worklist\n    if (sp[e] < g.nlist[e]) {\n      wl1[(*wlsize)++] = e;\n    }\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, const data_type* const priority, data_type* const status, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all edges in wl1\n    int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if one is included, exclude the other\n    // RaceBug here\n    if (status[src] == included) {\n      // RaceBug here\n      status[dst] = excluded;\n    }\n    // RaceBug here\n    else if (status[dst] == included) {\n      // RaceBug here\n      status[src] = excluded;\n    }\n    // if neither included nor excluded -> mark lower as lost\n    // RaceBug here\n    else if (status[src] != excluded && status[dst] != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    const int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if src node won\n    if (lost[src] == 0) {\n      // RaceBug here\n      if (status[src] == undecided) {\n        // and is undecided -> include\n        // RaceBug here\n        status[src] = included;\n      }\n    }\n    // if dst node won\n    if (lost[dst] == 0) {\n      if (atomicRead(&status[dst]) == undecided) {\n        // and is undecided -> include\n        // RaceBug here\n        status[dst] = included;\n      }\n    }\n    if (atomicRead(&status[src]) == undecided || atomicRead(&status[dst]) == undecided) {\n      // if either node is still undecided, keep edge in WL\n      wl2[criticalAdd(wl2size, 1)] = e;\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* lost = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(size * sizeof(int));\n  int* wl2 = malloc(size * sizeof(int));\n  int* wl1size = malloc(size * sizeof(int));\n  int* wl2size = malloc(size * sizeof(int));\n\n  init(g, sp, priority, status, lost, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, lost, wl1, *wl1size, wl2, wl2size);\n\n\n    // vertex pass\n    mis_vertex_pass(g, sp, priority, status, lost, wl1, *wl1size, wl2, wl2size);\n\n\n    for (int i = 0; i < g.nodes; i++) {\n      lost[i] = 0;\n    }\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for schedule(dynamic)\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(lost);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    lost[v] = 0;\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n    // go over all edges\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    // if one is included, exclude the other\n    // RaceBug here\n    if (status[src] == included) {\n      // RaceBug here\n      status_n[dst] = excluded;\n    }\n    // RaceBug here\n    else if (status[dst] == included) {\n      // RaceBug here\n      status_n[src] = excluded;\n    }\n    // if neither included nor excluded -> mark lower priority node as lost\n    // RaceBug here\n    else if (status[src] != excluded && status[dst] != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(data_type* const status, data_type* const status_n, data_type* const lost, const int size, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < size; v++) {\n    // go over all vertexes\n    if (lost[v] == 0) {\n      if(status[v] == undecided) {\n        status_n[v] = included;\n      }\n    }\n    else {\n      atomicWrite(goagain, 1);\n      lost[v] = 0; //reset lost flag\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  data_type* lost = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, lost, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, status_new, lost);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    // vertex pass\n    mis_vertex_pass(status, status_new, lost, g.nodes, goagain);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n  } while (*goagain);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(lost);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    lost[v] = 0;\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n    // go over all edges\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    // if one is included, exclude the other\n    // RaceBug here\n    if (status[src] == included) {\n      // RaceBug here\n      status_n[dst] = excluded;\n    }\n    // RaceBug here\n    else if (status[dst] == included) {\n      // RaceBug here\n      status_n[src] = excluded;\n    }\n    // if neither included nor excluded -> mark lower priority node as lost\n    // RaceBug here\n    else if (status[src] != excluded && status[dst] != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(data_type* const status, data_type* const status_n, data_type* const lost, const int size, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < size; v++) {\n    // go over all vertexes\n    if (lost[v] == 0) {\n      if(status[v] == undecided) {\n        status_n[v] = included;\n      }\n    }\n    else {\n      atomicWrite(goagain, 1);\n      lost[v] = 0; //reset lost flag\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  data_type* lost = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, lost, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, status_new, lost);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    // vertex pass\n    mis_vertex_pass(status, status_new, lost, g.nodes, goagain);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n  } while (*goagain);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for schedule(dynamic)\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(lost);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && (status[g.nlist[i]] != included) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        // RaceBug here\n        if (status[g.nlist[i]] == included) {\n          // found included neighbor -> exclude self\n          // RaceBug here\n          status_n[v] = excluded;\n        } else {\n          atomicWrite(goagain, 1);\n        }\n      } else {\n        // no such neighbor -> v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    time[v] = 0;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && (status[g.nlist[i]] != included) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        // RaceBug here\n        if (status[g.nlist[i]] == included) {\n          // found included neighbor -> exclude self\n          // RaceBug here\n          status_n[v] = excluded;\n          // and WL neighbors\n          for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n            if(critical_max(&time[g.nlist[j]], iter) != iter) {\n              wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n            }\n          }\n        }\n      } else {\n        // no included neighbor -> v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n        // and WL neighbors\n        for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n          if(critical_max(&time[g.nlist[j]], iter) != iter) {\n            wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size, time);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, const int size, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    time[v] = 0;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && (status[g.nlist[i]] != included) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        // RaceBug here\n        if (status[g.nlist[i]] == included) {\n          // found included neighbor -> exclude self\n          // RaceBug here\n          status[v] = excluded;\n          // and WL neighbors\n          for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n            if(critical_max(&time[g.nlist[j]], iter) != iter) {\n              wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n            }\n          }\n        }\n      } else {\n        // no included neighbor -> v is \"included\"\n        // RaceBug here\n        status[v] = included;\n        // and WL neighbors\n        for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n          if(critical_max(&time[g.nlist[j]], iter) != iter) {\n            wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, g.nodes, wl1, wl1size, time);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, wl1, *wl1size, wl2, wl2size, iter, time);\n\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < g.nodes; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    lost[v] = 0;\n  }\n  *wlsize = 0;\n  for (int e = 0; e < g.edges; e++)\n  {\n    // initialize worklist\n    if (sp[e] < g.nlist[e]) {\n      wl1[(*wlsize)++] = e;\n    }\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, const data_type* const priority, data_type* const status, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all edges in wl1\n    int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    const int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if src node won\n    if (lost[src] == 0) {\n      if (atomicRead(&status[src]) == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status[src], included);\n      }\n    }\n    // if dst node won\n    if (lost[dst] == 0) {\n      // GuardBug here\n      if (status[dst] == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status[dst], included);\n      }\n    }\n    if (atomicRead(&status[src]) == undecided || atomicRead(&status[dst]) == undecided) {\n      // if either node is still undecided, keep edge in WL\n      wl2[criticalAdd(wl2size, 1)] = e;\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* lost = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(size * sizeof(int));\n  int* wl2 = malloc(size * sizeof(int));\n  int* wl1size = malloc(size * sizeof(int));\n  int* wl2size = malloc(size * sizeof(int));\n\n  init(g, sp, priority, status, lost, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, lost, wl1, *wl1size, wl2, wl2size);\n\n\n    // vertex pass\n    mis_vertex_pass(g, sp, priority, status, lost, wl1, *wl1size, wl2, wl2size);\n\n\n    for (int i = 0; i < g.nodes; i++) {\n      lost[i] = 0;\n    }\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(lost);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, const int size, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    time[v] = 0;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && (status[g.nlist[i]] != included) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        // RaceBug here\n        if (status[g.nlist[i]] == included) {\n          // found included neighbor -> exclude self\n          // RaceBug here\n          status[v] = excluded;\n          // and WL neighbors\n          for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n            if(critical_max(&time[g.nlist[j]], iter) != iter) {\n              wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n            }\n          }\n        }\n      } else {\n        // no included neighbor -> v is \"included\"\n        // RaceBug here\n        status[v] = included;\n        // and WL neighbors\n        for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n          if(critical_max(&time[g.nlist[j]], iter) != iter) {\n            wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, g.nodes, wl1, wl1size, time);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, wl1, *wl1size, wl2, wl2size, iter, time);\n\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    time[v] = 0;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && (status[g.nlist[i]] != included) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        // RaceBug here\n        if (status[g.nlist[i]] == included) {\n          // found included neighbor -> exclude self\n          // RaceBug here\n          status_n[v] = excluded;\n          // and WL neighbors\n          for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n            if(critical_max(&time[g.nlist[j]], iter) != iter) {\n              wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n            }\n          }\n        }\n      } else {\n        // no included neighbor -> v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n        // and WL neighbors\n        for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n          if(critical_max(&time[g.nlist[j]], iter) != iter) {\n            wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size, time);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < g.nodes; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    lost[v] = 0;\n  }\n  *wlsize = 0;\n  for (int e = 0; e < g.edges; e++)\n  {\n    // initialize worklist\n    if (sp[e] < g.nlist[e]) {\n      wl1[(*wlsize)++] = e;\n    }\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, const data_type* const priority, data_type* const status, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all edges in wl1\n    int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    const int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if src node won\n    if (lost[src] == 0) {\n      if (atomicRead(&status[src]) == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status[src], included);\n      }\n    }\n    // if dst node won\n    if (lost[dst] == 0) {\n      // GuardBug here\n      if (status[dst] == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status[dst], included);\n      }\n    }\n    if (atomicRead(&status[src]) == undecided || atomicRead(&status[dst]) == undecided) {\n      // if either node is still undecided, keep edge in WL\n      wl2[criticalAdd(wl2size, 1)] = e;\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* lost = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(size * sizeof(int));\n  int* wl2 = malloc(size * sizeof(int));\n  int* wl1size = malloc(size * sizeof(int));\n  int* wl2size = malloc(size * sizeof(int));\n\n  init(g, sp, priority, status, lost, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, lost, wl1, *wl1size, wl2, wl2size);\n\n\n    // vertex pass\n    mis_vertex_pass(g, sp, priority, status, lost, wl1, *wl1size, wl2, wl2size);\n\n\n    for (int i = 0; i < g.nodes; i++) {\n      lost[i] = 0;\n    }\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for schedule(dynamic)\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(lost);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, const int size, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        wl2[criticalAdd(wl2size, 1)] = v;\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        // RaceBug here\n        status[v] = included;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          // RaceBug here\n          status[g.nlist[i]] = excluded;\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, g.nodes, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, wl1, *wl1size, wl2, wl2size);\n\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const lost, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    lost[v] = 0;\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n    // go over all edges\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    // if one is included, exclude the other\n    // RaceBug here\n    if (status[src] == included) {\n      // RaceBug here\n      status[dst] = excluded;\n    }\n    // RaceBug here\n    else if (status[dst] == included) {\n      // RaceBug here\n      status[src] = excluded;\n    }\n    // if neither included nor excluded -> mark lower priority node as lost\n    // RaceBug here\n    else if (status[src] != excluded && status[dst] != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(data_type* const status, data_type* const lost, const int size, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < size; v++) {\n    // go over all vertexes\n    if (lost[v] == 0) {\n      if(status[v] == undecided) {\n        status[v] = included;\n      }\n    }\n    else {\n      atomicWrite(goagain, 1);\n      lost[v] = 0; //reset lost flag\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* lost = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, lost, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, lost);\n\n\n    // vertex pass\n    mis_vertex_pass(status, lost, g.nodes, goagain);\n\n  } while (*goagain);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for schedule(dynamic)\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(lost);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, const int size, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        wl2[criticalAdd(wl2size, 1)] = v;\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        // RaceBug here\n        status[v] = included;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          // RaceBug here\n          status[g.nlist[i]] = excluded;\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, g.nodes, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, wl1, *wl1size, wl2, wl2size);\n\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && (status[g.nlist[i]] != included) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        // RaceBug here\n        if (status[g.nlist[i]] == included) {\n          // found included neighbor -> exclude self\n          // RaceBug here\n          status[v] = excluded;\n        } else {\n          atomicWrite(goagain, 1);\n        }\n      } else {\n        // no such neighbor -> v is \"included\"\n        // RaceBug here\n        status[v] = included;\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n\n  init(priority, status, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, goagain);\n\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    time[v] = 0;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && (status[g.nlist[i]] != included) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        // RaceBug here\n        if (status[g.nlist[i]] == included) {\n          // found included neighbor -> exclude self\n          // RaceBug here\n          status_n[v] = excluded;\n          // and WL neighbors\n          for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n            if(critical_max(&time[g.nlist[j]], iter) != iter) {\n              wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n            }\n          }\n        }\n      } else {\n        // no included neighbor -> v is \"included\"\n        // RaceBug here\n        status_n[v] = included;\n        // and WL neighbors\n        for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n          if(critical_max(&time[g.nlist[j]], iter) != iter) {\n            wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);;\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size, time);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    updateFromWorklist(status, status_new, wl1, *wl1size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    // RaceBug here\n    if (status[v] == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      // RaceBug here\n      while ((i < g.nindex[v + 1]) && (status[g.nlist[i]] != included) && ((status[g.nlist[i]] == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        // RaceBug here\n        if (status[g.nlist[i]] == included) {\n          // found included neighbor -> exclude self\n          // RaceBug here\n          status[v] = excluded;\n        } else {\n          atomicWrite(goagain, 1);\n        }\n      } else {\n        // no such neighbor -> v is \"included\"\n        // RaceBug here\n        status[v] = included;\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n\n  init(priority, status, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, goagain);\n\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    // MixSyncBug here\n    const data_type new_label = atomicRead(&label[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n\n    bool updated = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n      if (critical_min(&label[dst], new_label) > new_label) {\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&label[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = atomicRead(&label[src]);\n      // LivelockBug here\n      if (d >= new_label) {\n        d = new_label;\n        atomicWrite(goagain, 1);\n      }\n      atomicWrite(&label[v], d);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = label[src];\n      // LivelockBug here\n      if (d >= new_label) {\n        d = new_label;\n        updated = true;\n      }\n      critical_min(&label_n[src], new_label);\n    }\n\n    if (updated) {\n      critical_min(&label_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int wlsize;\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  // std::fill(time, time + g.nodes, 0);\n  for (int i = 0; i < g.nodes; i++) time[i] = 0;\n\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, label_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const data_type new_label = atomicRead(&label[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n\n    bool updated = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n      const data_type d = atomicRead(&label[dst]);\n      // LivelockBug here\n      if (d >= new_label) {\n        atomicWrite(&label[dst], new_label);\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, const int* const sp, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type new_label = atomicRead(&label[src]);\n\n    const data_type d = atomicRead(&label[dst]);\n    // LivelockBug here\n    if (d >= new_label) {\n      atomicWrite(&label[dst], new_label);\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, sp, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = atomicRead(&label[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = atomicRead(&label[src]);\n      // LivelockBug here\n      if (d >= new_label) {\n        d = new_label;\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(&label[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int wlsize;\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  // std::fill(time, time + g.nodes, 0);\n  for (int i = 0; i < g.nodes; i++) time[i] = 0;\n\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  int idx = 0;\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      wl1[idx] = i;\n      idx++;\n    }\n  }\n  *wlsize = idx;\n}\n\nstatic void cc_edge_data(const ECLgraph g, const int* const sp, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type new_label = atomicRead(&label[src]);\n    data_type d = atomicRead(&label[dst]);\n    // LivelockBug here\n    if (d >= new_label) {\n      atomicWrite(&label[dst], new_label);\n      if (critical_max(&time[e], iter) != iter) {\n        wl2[fetch_and_add(wl2size)] = e;\n      }\n      for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n        if (critical_max(&time[j], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = j;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.edges);\n  int* wl1size = malloc(sizeof(int));\n  int *wl2size = malloc(sizeof(int));\n\n  for (int i = 0; i < g.edges; i++) time[i] = 0;\n\n  struct timeval start, end;\n  init(label, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_edge_data(g, sp, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = label[src];\n      // LivelockBug here\n      if (d >= new_label) {\n        d = new_label;\n        updated = true;\n      }\n      critical_min(&label_n[src], new_label);\n    }\n\n    if (updated) {\n      critical_min(&label_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int wlsize;\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  // std::fill(time, time + g.nodes, 0);\n  for (int i = 0; i < g.nodes; i++) time[i] = 0;\n\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, label_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  int idx = 0;\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      wl1[idx] = i;\n      idx++;\n    }\n  }\n  *wlsize = idx;\n}\n\nstatic void cc_edge_data(const ECLgraph g, const int* const sp, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // RaceBug here\n    const data_type new_label = label[src];\n    // RaceBug here\n    data_type d = label[dst];\n    if (d > new_label) {\n      // RaceBug here\n      label[dst] = new_label;\n      if (critical_max(&time[e], iter) != iter) {\n        wl2[fetch_and_add(wl2size)] = e;\n      }\n      for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n        if (critical_max(&time[j], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = j;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.edges);\n  int* wl1size = malloc(sizeof(int));\n  int *wl2size = malloc(sizeof(int));\n\n  for (int i = 0; i < g.edges; i++) time[i] = 0;\n\n  struct timeval start, end;\n  init(label, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_edge_data(g, sp, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // MixSyncBug here\n    const data_type new_label = atomicRead(&label[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      if (critical_min(&label[dst], new_label) > new_label) {\n        wl2[fetch_and_add(wl2size)] = dst;\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // RaceBug here\n    data_type d = label[v];\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      // RaceBug here\n      const data_type new_label = label[src];\n      if (d > new_label) {\n        d = new_label;\n        // RaceBug here\n        atomicWrite(goagain, 1);;\n      }\n      // RaceBug here\n      label[v] = d;\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, const int* const sp, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type new_label = atomicRead(&label[src]);\n\n    const data_type d = atomicRead(&label[dst]);\n    // LivelockBug here\n    if (d >= new_label) {\n      atomicWrite(&label[dst], new_label);\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, sp, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // RaceBug here\n    data_type d = label[v];\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      // RaceBug here\n      const data_type new_label = label[src];\n      if (d > new_label) {\n        d = new_label;\n        // RaceBug here\n        atomicWrite(goagain, 1);;\n      }\n      // RaceBug here\n      label[v] = d;\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  int idx = 0;\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      wl1[idx] = i;\n      idx++;\n    }\n  }\n  *wlsize = idx;\n}\n\nstatic void cc_edge_data(const ECLgraph g, const int* const sp, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // RaceBug here\n    const data_type new_label = label[src];\n    // RaceBug here\n    data_type d = label[dst];\n    if (d > new_label) {\n      // RaceBug here\n      label[dst] = new_label;\n      if (critical_max(&time[e], iter) != iter) {\n        wl2[fetch_and_add(wl2size)] = e;\n      }\n      for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n        if (critical_max(&time[j], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = j;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.edges);\n  int* wl1size = malloc(sizeof(int));\n  int *wl2size = malloc(sizeof(int));\n\n  for (int i = 0; i < g.edges; i++) time[i] = 0;\n\n  struct timeval start, end;\n  init(label, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_edge_data(g, sp, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, data_type* const label_n, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&label[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = atomicRead(&label[src]);\n      // LivelockBug here\n      if (d >= new_label) {\n        d = new_label;\n        atomicWrite(goagain, 1);\n      }\n      atomicWrite(&label_n[v], d);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, label_new, goagain);\n    SWAP(label, label_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // RaceBug here\n    const data_type new_label = label[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    bool update = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      // RaceBug here\n      const data_type d = label[dst];\n      if (d > new_label) {\n        // RaceBug here\n        label[dst] = new_label;\n        if (critical_max(&time[dst], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n        update = true;\n      }\n    }\n    if (update) {\n      if (critical_max(&time[src], iter) != iter) {\n        wl2[fetch_and_add(wl2size)] = src;\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  int* time = malloc(sizeof(int) * g.nodes);\n  for (int i = 0; i < g.nodes; i++) {\n    time[i] = 0;\n  }\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const data_type new_label = atomicRead(&label[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n\n    bool updated = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n      const data_type d = atomicRead(&label[dst]);\n      // LivelockBug here\n      if (d >= new_label) {\n        atomicWrite(&label[dst], new_label);\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // RaceBug here\n    const data_type new_label = label[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    bool update = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      // RaceBug here\n      const data_type d = label[dst];\n      if (d > new_label) {\n        // RaceBug here\n        label[dst] = new_label;\n        if (critical_max(&time[dst], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n        update = true;\n      }\n    }\n    if (update) {\n      if (critical_max(&time[src], iter) != iter) {\n        wl2[fetch_and_add(wl2size)] = src;\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  int* time = malloc(sizeof(int) * g.nodes);\n  for (int i = 0; i < g.nodes; i++) {\n    time[i] = 0;\n  }\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // MixSyncBug here\n    const data_type new_label = atomicRead(&label[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      if (critical_min(&label[dst], new_label) > new_label) {\n        if (critical_max(&time[dst], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  int* time = malloc(sizeof(int) * g.nodes);\n  for (int i = 0; i < g.nodes; i++) {\n    time[i] = 0;\n  }\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  int idx = 0;\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      wl1[idx] = i;\n      idx++;\n    }\n  }\n  *wlsize = idx;\n}\n\nstatic void cc_edge_data(const ECLgraph g, const int* const sp, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type new_label = atomicRead(&label[src]);\n    data_type d = atomicRead(&label[dst]);\n    // LivelockBug here\n    if (d >= new_label) {\n      atomicWrite(&label[dst], new_label);\n      if (critical_max(&time[e], iter) != iter) {\n        wl2[fetch_and_add(wl2size)] = e;\n      }\n      for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n        if (critical_max(&time[j], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = j;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.edges);\n  int* wl1size = malloc(sizeof(int));\n  int *wl2size = malloc(sizeof(int));\n\n  for (int i = 0; i < g.edges; i++) time[i] = 0;\n\n  struct timeval start, end;\n  init(label, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_edge_data(g, sp, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = label[src];\n      if (d > new_label) {\n        d = new_label;\n        updated = true;\n      }\n      critical_min(&label_n[src], new_label);\n    }\n\n    if (updated) {\n      // RaceBug here\n      label_n[v] = MIN(label_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int wlsize;\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  // std::fill(time, time + g.nodes, 0);\n  for (int i = 0; i < g.nodes; i++) time[i] = 0;\n\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, label_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, const int* const sp, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // RaceBug here\n    const data_type new_label = label[src];\n\n    // RaceBug here\n    const data_type d = label[dst];\n    if (d > new_label) {\n      // RaceBug here\n      label[dst] = new_label;\n      // RaceBug here\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, sp, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // MixSyncBug here\n    const data_type new_label = atomicRead(&label[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      if (critical_min(&label[dst], new_label) > new_label) {\n        if (critical_max(&time[dst], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  int* time = malloc(sizeof(int) * g.nodes);\n  for (int i = 0; i < g.nodes; i++) {\n    time[i] = 0;\n  }\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, const int* const sp, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // MixSyncBug here\n    const data_type new_label = atomicRead(&label[src]);\n\n    if (critical_min(&label[dst], new_label) > new_label) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, sp, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    const data_type new_label = atomicRead(&label[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    bool update = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      const data_type d = atomicRead(&label[dst]);\n      // LivelockBug here\n      if (d >= new_label) {\n        atomicWrite(&label[dst], new_label);\n        if (critical_max(&time[dst], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n        update = true;\n      }\n    }\n    if (update) {\n      if (critical_max(&time[src], iter) != iter) {\n        wl2[fetch_and_add(wl2size)] = src;\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  int* time = malloc(sizeof(int) * g.nodes);\n  for (int i = 0; i < g.nodes; i++) {\n    time[i] = 0;\n  }\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    // MixSyncBug here\n    const data_type new_label = atomicRead(&label[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n\n    bool updated = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n      if (critical_min(&label[dst], new_label) > new_label) {\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  int idx = 0;\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      wl1[idx] = i;\n      idx++;\n    }\n  }\n  *wlsize = idx;\n}\n\nstatic void cc_edge_data(const ECLgraph g, const int* const sp, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // MixSyncBug here\n    const data_type new_label = atomicRead(&label[src]);\n    if (critical_min(&label[dst], new_label) > new_label) {\n      for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n        if (critical_max(&time[j], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = j;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.edges);\n  int* wl1size = malloc(sizeof(int));\n  int *wl2size = malloc(sizeof(int));\n\n  for (int i = 0; i < g.edges; i++) time[i] = 0;\n\n  struct timeval start, end;\n  init(label, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_edge_data(g, sp, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = label[src];\n      if (d > new_label) {\n        d = new_label;\n        updated = true;\n      }\n      critical_min(&label_n[src], new_label);\n    }\n\n    if (updated) {\n      // RaceBug here\n      label_n[v] = MIN(label_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int wlsize;\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  // std::fill(time, time + g.nodes, 0);\n  for (int i = 0; i < g.nodes; i++) time[i] = 0;\n\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, label_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    const data_type new_label = atomicRead(&label[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    bool update = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      const data_type d = atomicRead(&label[dst]);\n      // LivelockBug here\n      if (d >= new_label) {\n        atomicWrite(&label[dst], new_label);\n        wl2[fetch_and_add(wl2size)] = dst;\n        update = true;\n      }\n    }\n    if (update) {\n      wl2[fetch_and_add(wl2size)] = src;\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = atomicRead(&label[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = atomicRead(&label[src]);\n      // LivelockBug here\n      if (d >= new_label) {\n        d = new_label;\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(&label[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int wlsize;\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  // std::fill(time, time + g.nodes, 0);\n  for (int i = 0; i < g.nodes; i++) time[i] = 0;\n\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // RaceBug here\n    const data_type new_label = label[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    bool update = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      // RaceBug here\n      const data_type d = label[dst];\n      if (d > new_label) {\n        // RaceBug here\n        label[dst] = new_label;\n        wl2[fetch_and_add(wl2size)] = dst;\n        update = true;\n      }\n    }\n    if (update) {\n      wl2[fetch_and_add(wl2size)] = src;\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = label[src];\n      if (d > new_label) {\n        d = new_label;\n        updated = true;\n      }\n      // MixSyncBug here\n      label_n[src] = new_label;\n    }\n\n    if (updated) {\n      critical_min(&label_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int wlsize;\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  // std::fill(time, time + g.nodes, 0);\n  for (int i = 0; i < g.nodes; i++) time[i] = 0;\n\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, label_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    // RaceBug here\n    const data_type new_label = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n\n    bool updated = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n      // RaceBug here\n      const data_type d = label[dst];\n      if (d > new_label) {\n        // RaceBug here\n        label[dst] = new_label;\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      // RaceBug here\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, const int* const sp, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // RaceBug here\n    const data_type new_label = label[src];\n\n    // RaceBug here\n    const data_type d = label[dst];\n    if (d > new_label) {\n      // RaceBug here\n      label[dst] = new_label;\n      // RaceBug here\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, sp, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    const data_type new_label = atomicRead(&label[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    bool update = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      const data_type d = atomicRead(&label[dst]);\n      // LivelockBug here\n      if (d >= new_label) {\n        atomicWrite(&label[dst], new_label);\n        wl2[fetch_and_add(wl2size)] = dst;\n        update = true;\n      }\n    }\n    if (update) {\n      wl2[fetch_and_add(wl2size)] = src;\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    // RaceBug here\n    const data_type new_label = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n\n    bool updated = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n      // RaceBug here\n      const data_type d = label[dst];\n      if (d > new_label) {\n        // RaceBug here\n        label[dst] = new_label;\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      // RaceBug here\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  int idx = 0;\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      wl1[idx] = i;\n      idx++;\n    }\n  }\n  *wlsize = idx;\n}\n\nstatic void cc_edge_data(const ECLgraph g, const int* const sp, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // MixSyncBug here\n    const data_type new_label = atomicRead(&label[src]);\n    if (critical_min(&label[dst], new_label) > new_label) {\n      for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n        if (critical_max(&time[j], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = j;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.edges);\n  int* wl1size = malloc(sizeof(int));\n  int *wl2size = malloc(sizeof(int));\n\n  for (int i = 0; i < g.edges; i++) time[i] = 0;\n\n  struct timeval start, end;\n  init(label, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_edge_data(g, sp, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&label[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = atomicRead(&label[src]);\n      // LivelockBug here\n      if (d >= new_label) {\n        d = new_label;\n        atomicWrite(goagain, 1);\n      }\n      atomicWrite(&label[v], d);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = label[src];\n      if (d > new_label) {\n        d = new_label;\n        updated = true;\n      }\n      // MixSyncBug here\n      label_n[src] = new_label;\n    }\n\n    if (updated) {\n      critical_min(&label_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int wlsize;\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  // std::fill(time, time + g.nodes, 0);\n  for (int i = 0; i < g.nodes; i++) time[i] = 0;\n\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, label_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, const int* const sp, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // MixSyncBug here\n    const data_type new_label = atomicRead(&label[src]);\n\n    if (critical_min(&label[dst], new_label) > new_label) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, sp, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, data_type* const label_n, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&label[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = atomicRead(&label[src]);\n      // LivelockBug here\n      if (d >= new_label) {\n        d = new_label;\n        atomicWrite(goagain, 1);\n      }\n      atomicWrite(&label_n[v], d);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, label_new, goagain);\n    SWAP(label, label_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // RaceBug here\n    const data_type new_label = label[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    bool update = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      // RaceBug here\n      const data_type d = label[dst];\n      if (d > new_label) {\n        // RaceBug here\n        label[dst] = new_label;\n        wl2[fetch_and_add(wl2size)] = dst;\n        update = true;\n      }\n    }\n    if (update) {\n      wl2[fetch_and_add(wl2size)] = src;\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    const data_type new_label = atomicRead(&label[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    bool update = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      const data_type d = atomicRead(&label[dst]);\n      // LivelockBug here\n      if (d >= new_label) {\n        atomicWrite(&label[dst], new_label);\n        if (critical_max(&time[dst], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n        update = true;\n      }\n    }\n    if (update) {\n      if (critical_max(&time[src], iter) != iter) {\n        wl2[fetch_and_add(wl2size)] = src;\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  int* time = malloc(sizeof(int) * g.nodes);\n  for (int i = 0; i < g.nodes; i++) {\n    time[i] = 0;\n  }\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // MixSyncBug here\n    const data_type new_label = atomicRead(&label[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      if (critical_min(&label[dst], new_label) > new_label) {\n        wl2[fetch_and_add(wl2size)] = dst;\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_edge_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < edges; e++) {\n    data_type count = 0;\n    const int src = sp[e];\n    const int dst = nlist[e];\n    if (src > dst) {\n      const int beg1 = nindex[dst];\n      const int end1 = nindex[dst + 1];\n      for (int i = beg1; i < end1 && nlist[i] < dst; i++) {\n        const int u = nlist[i];\n        int beg2 = nindex[src];\n        int end2 = nindex[src + 1];\n        if (find(u, beg2, end2, nlist)) count++;\n      }\n      (*g_count) += count;\n    }\n  }\n}\n\nstatic double CPUtc_edge(data_type* count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, edges, nindex, nlist, sp);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_vertex_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < nodes; v++) {\n    data_type count = 0;\n    const int beg1 = nindex[v];\n    const int end1 = nindex[v + 1];\n    int start1 = end1;\n    while ((beg1 < start1) && (v < nlist[start1 - 1])) start1--;\n    for (int j = start1; j < end1; j++) {\n      const int u = nlist[j];\n      const int beg2 = nindex[u];\n      const int end2 = nindex[u + 1];\n      int start2 = end2;\n      while ((beg2 < start2) && (u < nlist[start2 - 1])) start2--;\n      count += (data_type)common(j + 1, end1, start2, end2, nlist);\n    }\n    (*g_count) += count;\n  }\n}\n\nstatic double CPUtc_vertex(data_type* count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, nodes, nindex, nlist);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_vertex_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < nodes; v++) {\n    data_type count = 0;\n    const int beg1 = nindex[v];\n    const int end1 = nindex[v + 1];\n    int start1 = end1;\n    while ((beg1 < start1) && (v < nlist[start1 - 1])) start1--;\n    for (int j = start1; j < end1; j++) {\n      const int u = nlist[j];\n      const int beg2 = nindex[u];\n      const int end2 = nindex[u + 1];\n      int start2 = end2;\n      while ((beg2 < start2) && (u < nlist[start2 - 1])) start2--;\n      count += (data_type)common(j + 1, end1, start2, end2, nlist);\n    }\n    (*g_count) += count;\n  }\n}\n\nstatic double CPUtc_vertex(data_type* count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, nodes, nindex, nlist);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_vertex_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  // RaceBug here\n  data_type result = 0;\n  #pragma omp parallel for\n  for (int v = 0; v < nodes; v++) {\n    data_type count = 0;\n    const int beg1 = nindex[v];\n    const int end1 = nindex[v + 1];\n    int start1 = end1;\n    while ((beg1 < start1) && (v < nlist[start1 - 1])) start1--;\n    for (int j = start1; j < end1; j++) {\n      const int u = nlist[j];\n      const int beg2 = nindex[u];\n      const int end2 = nindex[u + 1];\n      int start2 = end2;\n      while ((beg2 < start2) && (u < nlist[start2 - 1])) start2--;\n      count += (data_type)common(j + 1, end1, start2, end2, nlist);\n    }\n    result += count;\n  }\n  *g_count = result;\n}\n\nstatic double CPUtc_vertex(data_type* count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, nodes, nindex, nlist);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_vertex_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < nodes; v++) {\n    data_type count = 0;\n    const int beg1 = nindex[v];\n    const int end1 = nindex[v + 1];\n    int start1 = end1;\n    while ((beg1 < start1) && (v < nlist[start1 - 1])) start1--;\n    for (int j = start1; j < end1; j++) {\n      const int u = nlist[j];\n      const int beg2 = nindex[u];\n      const int end2 = nindex[u + 1];\n      int start2 = end2;\n      while ((beg2 < start2) && (u < nlist[start2 - 1])) start2--;\n      count += (data_type)common(j + 1, end1, start2, end2, nlist);\n    }\n    (*g_count) += count;\n  }\n}\n\nstatic double CPUtc_vertex(data_type* count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, nodes, nindex, nlist);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_edge_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < edges; e++) {\n    data_type count = 0;\n    const int src = sp[e];\n    const int dst = nlist[e];\n    if (src > dst) {\n      const int beg1 = nindex[dst];\n      const int end1 = nindex[dst + 1];\n      for (int i = beg1; i < end1 && nlist[i] < dst; i++) {\n        const int u = nlist[i];\n        int beg2 = nindex[src];\n        int end2 = nindex[src + 1];\n        if (find(u, beg2, end2, nlist)) count++;\n      }\n      (*g_count) += count;\n    }\n  }\n}\n\nstatic double CPUtc_edge(data_type* count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, edges, nindex, nlist, sp);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_edge_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < edges; e++) {\n    data_type count = 0;\n    const int src = sp[e];\n    const int dst = nlist[e];\n    if (src > dst) {\n      const int beg1 = nindex[dst];\n      const int end1 = nindex[dst + 1];\n      for (int i = beg1; i < end1 && nlist[i] < dst; i++) {\n        const int u = nlist[i];\n        int beg2 = nindex[src];\n        int end2 = nindex[src + 1];\n        if (find(u, beg2, end2, nlist)) count++;\n      }\n      (*g_count) += count;\n    }\n  }\n}\n\nstatic double CPUtc_edge(data_type* count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, edges, nindex, nlist, sp);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_vertex_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < nodes; v++) {\n    data_type count = 0;\n    const int beg1 = nindex[v];\n    const int end1 = nindex[v + 1];\n    int start1 = end1;\n    while ((beg1 < start1) && (v < nlist[start1 - 1])) start1--;\n    for (int j = start1; j < end1; j++) {\n      const int u = nlist[j];\n      const int beg2 = nindex[u];\n      const int end2 = nindex[u + 1];\n      int start2 = end2;\n      while ((beg2 < start2) && (u < nlist[start2 - 1])) start2--;\n      count += (data_type)common(j + 1, end1, start2, end2, nlist);\n    }\n    (*g_count) += count;\n  }\n}\n\nstatic double CPUtc_vertex(data_type* count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, nodes, nindex, nlist);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_edge_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < edges; e++) {\n    data_type count = 0;\n    const int src = sp[e];\n    const int dst = nlist[e];\n    if (src > dst) {\n      const int beg1 = nindex[dst];\n      const int end1 = nindex[dst + 1];\n      for (int i = beg1; i < end1 && nlist[i] < dst; i++) {\n        const int u = nlist[i];\n        int beg2 = nindex[src];\n        int end2 = nindex[src + 1];\n        if (find(u, beg2, end2, nlist)) count++;\n      }\n      (*g_count) += count;\n    }\n  }\n}\n\nstatic double CPUtc_edge(data_type* count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, edges, nindex, nlist, sp);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_edge_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  // RaceBug here\n  data_type result = 0;\n  #pragma omp parallel for\n  for (int e = 0; e < edges; e++) {\n    data_type count = 0;\n    const int src = sp[e];\n    const int dst = nlist[e];\n    if (src > dst) {\n      const int beg1 = nindex[dst];\n      const int end1 = nindex[dst + 1];\n      for (int i = beg1; i < end1 && nlist[i] < dst; i++) {\n        const int u = nlist[i];\n        int beg2 = nindex[src];\n        int end2 = nindex[src + 1];\n        if (find(u, beg2, end2, nlist)) count++;\n      }\n      result += count;\n    }\n  }\n  *g_count = result;\n}\n\nstatic double CPUtc_edge(data_type* count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, edges, nindex, nlist, sp);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_edge_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  // RaceBug here\n  data_type result = 0;\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < edges; e++) {\n    data_type count = 0;\n    const int src = sp[e];\n    const int dst = nlist[e];\n    if (src > dst) {\n      const int beg1 = nindex[dst];\n      const int end1 = nindex[dst + 1];\n      for (int i = beg1; i < end1 && nlist[i] < dst; i++) {\n        const int u = nlist[i];\n        int beg2 = nindex[src];\n        int end2 = nindex[src + 1];\n        if (find(u, beg2, end2, nlist)) count++;\n      }\n      result += count;\n    }\n  }\n  *g_count = result;\n}\n\nstatic double CPUtc_edge(data_type* count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, edges, nindex, nlist, sp);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_vertex_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  // RaceBug here\n  data_type result = 0;\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < nodes; v++) {\n    data_type count = 0;\n    const int beg1 = nindex[v];\n    const int end1 = nindex[v + 1];\n    int start1 = end1;\n    while ((beg1 < start1) && (v < nlist[start1 - 1])) start1--;\n    for (int j = start1; j < end1; j++) {\n      const int u = nlist[j];\n      const int beg2 = nindex[u];\n      const int end2 = nindex[u + 1];\n      int start2 = end2;\n      while ((beg2 < start2) && (u < nlist[start2 - 1])) start2--;\n      count += (data_type)common(j + 1, end1, start2, end2, nlist);\n    }\n    result += count;\n  }\n  *g_count = result;\n}\n\nstatic double CPUtc_vertex(data_type* count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, nodes, nindex, nlist);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        // RaceBug here\n        const data_type d = dist[dst];\n        if (d > new_dist) {\n          // RaceBug here\n          dist[dst] = new_dist;\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n          update = true;\n        }\n      }\n      if (update) {\n        if (critical_max(&time[src], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = src;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[v];\n\n    if (s == iter) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        // RaceBug here\n        const data_type d = dist[dst];\n        if (d > new_dist) {\n          // RaceBug here\n          dist[dst] = new_dist;\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void bfs_vertex_data(ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        // LivelockBug here\n        if (d >= new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n\n    if (updated) {\n      critical_min(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  // int* wl1 = new int [size];\n  // int* wl2 = new int [size];\n  // int* time = new int [g.nodes];\n  // int* wl1size;\n  // int* wl2size;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s == iter) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      const data_type d = atomicRead(&dist[dst]);\n      // LivelockBug here\n      if (d >= new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n    bfs(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s == iter) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        const data_type d = atomicRead(&dist[dst]);\n        // LivelockBug here\n        if (d >= new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // RaceBug here\n    data_type d = dist[v];\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      // RaceBug here\n      const data_type s = dist[src];\n      if (s == iter) {\n        const data_type new_dist = s + 1;\n        if (new_dist < d) {\n          d = new_dist;\n          // RaceBug here\n          atomicWrite(goagain, 1);\n        }\n      }\n      // RaceBug here\n      dist[v] = d;\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // RaceBug here\n    data_type d = dist[v];\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      // RaceBug here\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        if (new_dist < d) {\n          d = new_dist;\n          // RaceBug here\n          atomicWrite(goagain, 1);\n        }\n      }\n      // RaceBug here\n      dist[v] = d;\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void bfs_vertex_data(ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      // RaceBug here\n      dist_n[src] = s;\n    }\n\n    if (updated) {\n      critical_min(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  // int* wl1 = new int [size];\n  // int* wl2 = new int [size];\n  // int* time = new int [g.nodes];\n  // int* wl1size;\n  // int* wl2size;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void bfs_vertex_data(ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        // LivelockBug here\n        if (d >= new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n\n    if (updated) {\n      critical_min(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  // int* wl1 = new int [size];\n  // int* wl2 = new int [size];\n  // int* time = new int [g.nodes];\n  // int* wl1size;\n  // int* wl2size;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        // RaceBug here\n        const data_type d = dist[dst];\n        if (d > new_dist) {\n          // RaceBug here\n          dist[dst] = new_dist;\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n          update = true;\n        }\n      }\n      if (update) {\n        if (critical_max(&time[src], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = src;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[v];\n\n    if (s == iter) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        // RaceBug here\n        const data_type d = dist[dst];\n        if (d > new_dist) {\n          // RaceBug here\n          dist[dst] = new_dist;\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[v];\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        // RaceBug here\n        const data_type d = dist[dst];\n        if (d > new_dist) {\n          // RaceBug here\n          dist[dst] = new_dist;\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        // LivelockBug here\n        if (new_dist <= d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist[v], d);\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void bfs_vertex_data(ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      // RaceBug here\n      dist_n[src] = s;\n    }\n\n    if (updated) {\n      critical_min(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  // int* wl1 = new int [size];\n  // int* wl2 = new int [size];\n  // int* time = new int [g.nodes];\n  // int* wl1size;\n  // int* wl2size;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // RaceBug here\n    const data_type s = dist[src];\n\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      // RaceBug here\n      const data_type d = dist[dst];\n      if (d > new_dist) {\n        // RaceBug here\n        dist[dst] = new_dist;\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n    bfs(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        const data_type d = atomicRead(&dist[dst]);\n        // LivelockBug here\n        if (d >= new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n          update = true;\n        }\n      }\n      if (update) {\n        if (critical_max(&time[src], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = src;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        const data_type d = atomicRead(&dist[dst]);\n        // LivelockBug here\n        if (d >= new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        const data_type d = atomicRead(&dist[dst]);\n        // LivelockBug here\n        if (d >= new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s == iter) {\n        const data_type new_dist = s + 1;\n        // LivelockBug here\n        if (new_dist <= d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist[v], d);\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        const data_type d = atomicRead(&dist[dst]);\n        // LivelockBug here\n        if (d >= new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n          update = true;\n        }\n      }\n      if (update) {\n        if (critical_max(&time[src], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = src;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s == iter) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // RaceBug here\n    data_type d = dist[v];\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      // RaceBug here\n      const data_type s = dist[src];\n      if (s == iter) {\n        const data_type new_dist = s + 1;\n        if (new_dist < d) {\n          d = new_dist;\n          // RaceBug here\n          atomicWrite(goagain, 1);\n        }\n      }\n      // RaceBug here\n      dist[v] = d;\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    // RaceBug here\n    const data_type s = dist[v];\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        // RaceBug here\n        const data_type d = dist[dst];\n        if (d > new_dist) {\n          // RaceBug here\n          dist[dst] = new_dist;\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        // LivelockBug here\n        if (new_dist <= d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist[v], d);\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void bfs_vertex_data(ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = atomicRead(&dist[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        // LivelockBug here\n        if (d >= new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      atomicWrite(&dist[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  // int* wl1 = new int [size];\n  // int* wl2 = new int [size];\n  // int* time = new int [g.nodes];\n  // int* wl1size;\n  // int* wl2size;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // RaceBug here\n    data_type d = dist[v];\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      // RaceBug here\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        if (new_dist < d) {\n          d = new_dist;\n          // RaceBug here\n          atomicWrite(goagain, 1);\n        }\n      }\n      // RaceBug here\n      dist[v] = d;\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\nstatic void bfs_edge_data(ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      data_type d = atomicRead(&dist[dst]);\n      // LivelockBug here\n      if (d >= new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        if (critical_max(&time[e], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = e;\n        }\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(sizeof(int) * size);\n  int* wl2 = (int*)malloc(sizeof(int) * size);\n  int* time = (int*)malloc(sizeof(int) * g.edges);\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void bfs_vertex_data(ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = atomicRead(&dist[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        // LivelockBug here\n        if (d >= new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      atomicWrite(&dist[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  // int* wl1 = new int [size];\n  // int* wl2 = new int [size];\n  // int* time = new int [g.nodes];\n  // int* wl1size;\n  // int* wl2size;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s == iter) {\n        const data_type new_dist = s + 1;\n        // LivelockBug here\n        if (new_dist <= d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist[v], d);\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      const data_type d = atomicRead(&dist[dst]);\n      // LivelockBug here\n      if (d >= new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n    bfs(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // RaceBug here\n    const data_type s = dist[src];\n\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      // RaceBug here\n      const data_type d = dist[dst];\n      if (d > new_dist) {\n        // RaceBug here\n        dist[dst] = new_dist;\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n    bfs(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\nstatic void bfs_edge_data(ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      data_type d = atomicRead(&dist[dst]);\n      // LivelockBug here\n      if (d >= new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        if (critical_max(&time[e], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = e;\n        }\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(sizeof(int) * size);\n  int* wl2 = (int*)malloc(sizeof(int) * size);\n  int* time = (int*)malloc(sizeof(int) * g.edges);\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n    bfs(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\nstatic void bfs_edge_data(ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // RaceBug here\n    const data_type s = dist[src];\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      // RaceBug here\n      data_type d = dist[dst];\n      if (d > new_dist) {\n        // RaceBug here\n        dist[dst] = new_dist;\n        if (critical_max(&time[e], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = e;\n        }\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(sizeof(int) * size);\n  int* wl2 = (int*)malloc(sizeof(int) * size);\n  int* time = (int*)malloc(sizeof(int) * g.edges);\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s == iter) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        const data_type d = atomicRead(&dist[dst]);\n        // LivelockBug here\n        if (d >= new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n    bfs(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\nstatic void bfs_edge_data(ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // RaceBug here\n    const data_type s = dist[src];\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      // RaceBug here\n      data_type d = dist[dst];\n      if (d > new_dist) {\n        // RaceBug here\n        dist[dst] = new_dist;\n        if (critical_max(&time[e], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = e;\n        }\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(sizeof(int) * size);\n  int* wl2 = (int*)malloc(sizeof(int) * size);\n  int* time = (int*)malloc(sizeof(int) * g.edges);\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    // MixSyncBug here\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_vertex_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv, int* const wl1, int* wlsize)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  *wlsize = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n\n    wl1[(*wlsize)++] = v;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // MixSyncBug here\n  int curr = atomicRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    // MixSyncBug here\n    while (curr != (next = atomicRead(&parent[curr]))) {\n      // MixSyncBug here\n      atomicWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, int* const minv, int* const parent, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int v = wl1[idx];\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool inWL = false;\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if (!inWL) {\n            wl2[fetch_and_add(wl2size)] = v;\n            inWL = true;\n          }\n\n          int edx, upd;\n          // MixSyncBug here\n          upd = atomicRead(&minv[arep]);\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n          // MixSyncBug here\n          upd = atomicRead(&minv[brep]);\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n        }\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, bool* const included, int* const minv, int* const parent, const int* const wl1, const int wl1size)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int v = wl1[idx];\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if ((e == minv[arep]) || (e == minv[brep])) {\n            // if this was the best edge found for the set\n            join(arep, brep, parent);\n            included[e] = true;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(g, eweight, included, parent, minv, wl1, wl1size);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mst_first(g, eweight, minv, parent, wl1, *wl1size, wl2, wl2size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    if (*wl1size > 0) {\n      mst_second(g, included, minv, parent, wl1, *wl1size);\n\n      // std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_vertex_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // RaceBug here\n  int curr = parent[idx];\n  if (curr != idx) {\n    int next, prev = idx;\n    // RaceBug here\n    while (curr != (next = parent[curr])) {\n      // RaceBug here\n      parent[prev] = next;\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, int* const minv, int* const parent, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          // RaceBug here\n          *goagain = 1;\n\n          int edx, upd;\n          // RaceBug here\n          upd = minv[arep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n          // RaceBug here\n          upd = minv[brep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n        }\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, bool* const included, int* const minv, int* const parent)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if ((e == minv[arep]) || (e == minv[brep])) {\n            // if this was the best edge found for the set\n            join(arep, brep, parent);\n            included[e] = true;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n\n  init(g, eweight, included, parent, minv);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mst_first(g, eweight, minv, parent, goagain);\n\n    if (*goagain) {\n      mst_second(g, included, minv, parent);\n\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_vertex_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv, int* const wl1, int* wlsize)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  *wlsize = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n\n    wl1[(*wlsize)++] = v;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // RaceBug here\n  int curr = parent[idx];\n  if (curr != idx) {\n    int next, prev = idx;\n    // RaceBug here\n    while (curr != (next = parent[curr])) {\n      // RaceBug here\n      parent[prev] = next;\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, int* const minv, int* const parent, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int v = wl1[idx];\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool inWL = false;\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if (!inWL) {\n            wl2[fetch_and_add(wl2size)] = v;\n            inWL = true;\n          }\n\n          int edx, upd;\n          // RaceBug here\n          upd = minv[arep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n          // RaceBug here\n          upd = minv[brep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n        }\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, bool* const included, int* const minv, int* const parent, const int* const wl1, const int wl1size)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int v = wl1[idx];\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if ((e == minv[arep]) || (e == minv[brep])) {\n            // if this was the best edge found for the set\n            join(arep, brep, parent);\n            included[e] = true;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(g, eweight, included, parent, minv, wl1, wl1size);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mst_first(g, eweight, minv, parent, wl1, *wl1size, wl2, wl2size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    if (*wl1size > 0) {\n      mst_second(g, included, minv, parent, wl1, *wl1size);\n\n      // std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_edge_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv, int* const wl1, int* wlsize)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  *wlsize = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n      // only in one direction\n      if (n > v) {\n        wl1[(*wlsize)++] = e;\n      }\n    }\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // RaceBug here\n  int curr = parent[idx];\n  if (curr != idx) {\n    int next, prev = idx;\n    // RaceBug here\n    while (curr != (next = parent[curr])) {\n      // RaceBug here\n      parent[prev] = next;\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, const int* const sp, int* const minv, int* const parent, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    const int arep = findRep(src, parent);\n    const int brep = findRep(dst, parent);\n    if (arep != brep) {\n      wl2[fetch_and_add(wl2size)] = e;\n\n      int edx, upd;\n      // RaceBug here\n      upd = minv[arep];\n      do {\n        edx = upd;\n        const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n        if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n      } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n      // RaceBug here\n      upd = minv[brep];\n      do {\n        edx = upd;\n        const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n        if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n      } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, const int* const sp, bool* const included, int* const minv, int* const parent, const int* const wl1, const int wl1size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    const int arep = findRep(src, parent);\n    const int brep = findRep(dst, parent);\n    if (arep != brep) {\n      if ((e == minv[arep]) || (e == minv[brep])) {\n        // if this was the best edge found for the set\n        join(arep, brep, parent);\n        included[e] = true;\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, const int* const sp, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n  int* wl1 = malloc(sizeof(int) * (g.edges / 2));\n  int* wl2 = malloc(sizeof(int) * (g.edges / 2));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(g, eweight, included, parent, minv, wl1, wl1size);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mst_first(g, eweight, sp, minv, parent, wl1, *wl1size, wl2, wl2size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    if (*wl1size > 0) {\n      mst_second(g, sp, included, minv, parent, wl1, *wl1size);\n\n      // std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_edge_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv, int* const wl1, int* wlsize)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  *wlsize = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n      // only in one direction\n      if (n > v) {\n        wl1[(*wlsize)++] = e;\n      }\n    }\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // MixSyncBug here\n  int curr = atomicRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    // MixSyncBug here\n    while (curr != (next = atomicRead(&parent[curr]))) {\n      // MixSyncBug here\n      atomicWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, const int* const sp, int* const minv, int* const parent, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    const int arep = findRep(src, parent);\n    const int brep = findRep(dst, parent);\n    if (arep != brep) {\n      wl2[fetch_and_add(wl2size)] = e;\n\n      int edx, upd;\n      // MixSyncBug here\n      upd = atomicRead(&minv[arep]);\n      do {\n        edx = upd;\n        const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n        if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n      } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n      // MixSyncBug here\n      upd = atomicRead(&minv[brep]);\n      do {\n        edx = upd;\n        const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n        if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n      } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, const int* const sp, bool* const included, int* const minv, int* const parent, const int* const wl1, const int wl1size)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    const int arep = findRep(src, parent);\n    const int brep = findRep(dst, parent);\n    if (arep != brep) {\n      if ((e == minv[arep]) || (e == minv[brep])) {\n        // if this was the best edge found for the set\n        join(arep, brep, parent);\n        included[e] = true;\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, const int* const sp, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n  int* wl1 = malloc(sizeof(int) * (g.edges / 2));\n  int* wl2 = malloc(sizeof(int) * (g.edges / 2));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(g, eweight, included, parent, minv, wl1, wl1size);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mst_first(g, eweight, sp, minv, parent, wl1, *wl1size, wl2, wl2size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    if (*wl1size > 0) {\n      mst_second(g, sp, included, minv, parent, wl1, *wl1size);\n\n      // std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_edge_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // RaceBug here\n  int curr = parent[idx];\n  if (curr != idx) {\n    int next, prev = idx;\n    // RaceBug here\n    while (curr != (next = parent[curr])) {\n      // RaceBug here\n      parent[prev] = next;\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, const int* const sp, int* const minv, int* const parent, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    if (dst > src) {\n      const int arep = findRep(src, parent);\n      const int brep = findRep(dst, parent);\n      if (arep != brep) {\n        // RaceBug here\n        *goagain = 1;\n\n        int edx, upd;\n        // RaceBug here\n        upd = minv[arep];\n        do {\n          edx = upd;\n          const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n          if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n        } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n        // RaceBug here\n        upd = minv[brep];\n        do {\n          edx = upd;\n          const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n          if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n        } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, const int* const sp, bool* const included, int* const minv, int* const parent)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    if (dst > src) {\n      const int arep = findRep(src, parent);\n      const int brep = findRep(dst, parent);\n      if (arep != brep) {\n        if ((e == minv[arep]) || (e == minv[brep])) {\n          // if this was the best edge found for the set\n          join(arep, brep, parent);\n          included[e] = true;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, const int* const sp, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n\n  init(g, eweight, included, parent, minv);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mst_first(g, eweight, sp, minv, parent, goagain);\n\n    if (*goagain) {\n      mst_second(g, sp, included, minv, parent);\n\n      //std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int i = 0; i < g.nodes; i++) minv[i] = INT_MAX;\n    }\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_edge_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // MixSyncBug here\n  int curr = atomicRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    // MixSyncBug here\n    while (curr != (next = atomicRead(&parent[curr]))) {\n      // MixSyncBug here\n      atomicWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, const int* const sp, int* const minv, int* const parent, int* goagain)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    if (dst > src) {\n      const int arep = findRep(src, parent);\n      const int brep = findRep(dst, parent);\n      if (arep != brep) {\n        // MixSyncBug here\n        atomicWrite(goagain, 1);\n\n        int edx, upd;\n        // MixSyncBug here\n        upd = atomicRead(&minv[arep]);\n        do {\n          edx = upd;\n          const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n          if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n        } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n        // MixSyncBug here\n        upd = atomicRead(&minv[brep]);\n        do {\n          edx = upd;\n          const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n          if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n        } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, const int* const sp, bool* const included, int* const minv, int* const parent)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    if (dst > src) {\n      const int arep = findRep(src, parent);\n      const int brep = findRep(dst, parent);\n      if (arep != brep) {\n        if ((e == minv[arep]) || (e == minv[brep])) {\n          // if this was the best edge found for the set\n          join(arep, brep, parent);\n          included[e] = true;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, const int* const sp, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n\n  init(g, eweight, included, parent, minv);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mst_first(g, eweight, sp, minv, parent, goagain);\n\n    if (*goagain) {\n      mst_second(g, sp, included, minv, parent);\n\n      //std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int i = 0; i < g.nodes; i++) minv[i] = INT_MAX;\n    }\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_vertex_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // MixSyncBug here\n  int curr = atomicRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    // MixSyncBug here\n    while (curr != (next = atomicRead(&parent[curr]))) {\n      // MixSyncBug here\n      atomicWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, int* const minv, int* const parent, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          // MixSyncBug here\n          atomicWrite(goagain, 1);\n\n          int edx, upd;\n          // MixSyncBug here\n          upd = atomicRead(&minv[arep]);\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n          // MixSyncBug here\n          upd = atomicRead(&minv[brep]);\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n        }\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, bool* const included, int* const minv, int* const parent)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if ((e == minv[arep]) || (e == minv[brep])) {\n            // if this was the best edge found for the set\n            join(arep, brep, parent);\n            included[e] = true;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n\n  init(g, eweight, included, parent, minv);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mst_first(g, eweight, minv, parent, goagain);\n\n    if (*goagain) {\n      mst_second(g, included, minv, parent);\n\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_vertex_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv, int* const wl1, int* wlsize)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  *wlsize = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n\n    wl1[(*wlsize)++] = v;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // RaceBug here\n  int curr = parent[idx];\n  if (curr != idx) {\n    int next, prev = idx;\n    // RaceBug here\n    while (curr != (next = parent[curr])) {\n      // RaceBug here\n      parent[prev] = next;\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, int* const minv, int* const parent, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int v = wl1[idx];\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool inWL = false;\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if (!inWL) {\n            wl2[fetch_and_add(wl2size)] = v;\n            inWL = true;\n          }\n\n          int edx, upd;\n          // RaceBug here\n          upd = minv[arep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n          // RaceBug here\n          upd = minv[brep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n        }\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, bool* const included, int* const minv, int* const parent, const int* const wl1, const int wl1size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int v = wl1[idx];\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if ((e == minv[arep]) || (e == minv[brep])) {\n            // if this was the best edge found for the set\n            join(arep, brep, parent);\n            included[e] = true;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(g, eweight, included, parent, minv, wl1, wl1size);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mst_first(g, eweight, minv, parent, wl1, *wl1size, wl2, wl2size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    if (*wl1size > 0) {\n      mst_second(g, included, minv, parent, wl1, *wl1size);\n\n      // std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_edge_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // MixSyncBug here\n  int curr = atomicRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    // MixSyncBug here\n    while (curr != (next = atomicRead(&parent[curr]))) {\n      // MixSyncBug here\n      atomicWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, const int* const sp, int* const minv, int* const parent, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    if (dst > src) {\n      const int arep = findRep(src, parent);\n      const int brep = findRep(dst, parent);\n      if (arep != brep) {\n        // MixSyncBug here\n        atomicWrite(goagain, 1);\n\n        int edx, upd;\n        // MixSyncBug here\n        upd = atomicRead(&minv[arep]);\n        do {\n          edx = upd;\n          const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n          if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n        } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n        // MixSyncBug here\n        upd = atomicRead(&minv[brep]);\n        do {\n          edx = upd;\n          const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n          if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n        } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, const int* const sp, bool* const included, int* const minv, int* const parent)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    if (dst > src) {\n      const int arep = findRep(src, parent);\n      const int brep = findRep(dst, parent);\n      if (arep != brep) {\n        if ((e == minv[arep]) || (e == minv[brep])) {\n          // if this was the best edge found for the set\n          join(arep, brep, parent);\n          included[e] = true;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, const int* const sp, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n\n  init(g, eweight, included, parent, minv);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mst_first(g, eweight, sp, minv, parent, goagain);\n\n    if (*goagain) {\n      mst_second(g, sp, included, minv, parent);\n\n      //std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int i = 0; i < g.nodes; i++) minv[i] = INT_MAX;\n    }\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_vertex_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // RaceBug here\n  int curr = parent[idx];\n  if (curr != idx) {\n    int next, prev = idx;\n    // RaceBug here\n    while (curr != (next = parent[curr])) {\n      // RaceBug here\n      parent[prev] = next;\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, int* const minv, int* const parent, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          // RaceBug here\n          *goagain = 1;\n\n          int edx, upd;\n          // RaceBug here\n          upd = minv[arep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n          // RaceBug here\n          upd = minv[brep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n        }\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, bool* const included, int* const minv, int* const parent)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if ((e == minv[arep]) || (e == minv[brep])) {\n            // if this was the best edge found for the set\n            join(arep, brep, parent);\n            included[e] = true;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n\n  init(g, eweight, included, parent, minv);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mst_first(g, eweight, minv, parent, goagain);\n\n    if (*goagain) {\n      mst_second(g, included, minv, parent);\n\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_vertex_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // MixSyncBug here\n  int curr = atomicRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    // MixSyncBug here\n    while (curr != (next = atomicRead(&parent[curr]))) {\n      // MixSyncBug here\n      atomicWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, int* const minv, int* const parent, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          // MixSyncBug here\n          atomicWrite(goagain, 1);\n\n          int edx, upd;\n          // MixSyncBug here\n          upd = atomicRead(&minv[arep]);\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n          // MixSyncBug here\n          upd = atomicRead(&minv[brep]);\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n        }\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, bool* const included, int* const minv, int* const parent)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if ((e == minv[arep]) || (e == minv[brep])) {\n            // if this was the best edge found for the set\n            join(arep, brep, parent);\n            included[e] = true;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n\n  init(g, eweight, included, parent, minv);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mst_first(g, eweight, minv, parent, goagain);\n\n    if (*goagain) {\n      mst_second(g, included, minv, parent);\n\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_edge_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv, int* const wl1, int* wlsize)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  *wlsize = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n      // only in one direction\n      if (n > v) {\n        wl1[(*wlsize)++] = e;\n      }\n    }\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // MixSyncBug here\n  int curr = atomicRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    // MixSyncBug here\n    while (curr != (next = atomicRead(&parent[curr]))) {\n      // MixSyncBug here\n      atomicWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, const int* const sp, int* const minv, int* const parent, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    const int arep = findRep(src, parent);\n    const int brep = findRep(dst, parent);\n    if (arep != brep) {\n      wl2[fetch_and_add(wl2size)] = e;\n\n      int edx, upd;\n      // MixSyncBug here\n      upd = atomicRead(&minv[arep]);\n      do {\n        edx = upd;\n        const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n        if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n      } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n      // MixSyncBug here\n      upd = atomicRead(&minv[brep]);\n      do {\n        edx = upd;\n        const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n        if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n      } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, const int* const sp, bool* const included, int* const minv, int* const parent, const int* const wl1, const int wl1size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    const int arep = findRep(src, parent);\n    const int brep = findRep(dst, parent);\n    if (arep != brep) {\n      if ((e == minv[arep]) || (e == minv[brep])) {\n        // if this was the best edge found for the set\n        join(arep, brep, parent);\n        included[e] = true;\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, const int* const sp, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n  int* wl1 = malloc(sizeof(int) * (g.edges / 2));\n  int* wl2 = malloc(sizeof(int) * (g.edges / 2));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(g, eweight, included, parent, minv, wl1, wl1size);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mst_first(g, eweight, sp, minv, parent, wl1, *wl1size, wl2, wl2size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    if (*wl1size > 0) {\n      mst_second(g, sp, included, minv, parent, wl1, *wl1size);\n\n      // std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_edge_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv, int* const wl1, int* wlsize)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  *wlsize = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n      // only in one direction\n      if (n > v) {\n        wl1[(*wlsize)++] = e;\n      }\n    }\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // RaceBug here\n  int curr = parent[idx];\n  if (curr != idx) {\n    int next, prev = idx;\n    // RaceBug here\n    while (curr != (next = parent[curr])) {\n      // RaceBug here\n      parent[prev] = next;\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, const int* const sp, int* const minv, int* const parent, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    const int arep = findRep(src, parent);\n    const int brep = findRep(dst, parent);\n    if (arep != brep) {\n      wl2[fetch_and_add(wl2size)] = e;\n\n      int edx, upd;\n      // RaceBug here\n      upd = minv[arep];\n      do {\n        edx = upd;\n        const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n        if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n      } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n      // RaceBug here\n      upd = minv[brep];\n      do {\n        edx = upd;\n        const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n        if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n      } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, const int* const sp, bool* const included, int* const minv, int* const parent, const int* const wl1, const int wl1size)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    const int arep = findRep(src, parent);\n    const int brep = findRep(dst, parent);\n    if (arep != brep) {\n      if ((e == minv[arep]) || (e == minv[brep])) {\n        // if this was the best edge found for the set\n        join(arep, brep, parent);\n        included[e] = true;\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, const int* const sp, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n  int* wl1 = malloc(sizeof(int) * (g.edges / 2));\n  int* wl2 = malloc(sizeof(int) * (g.edges / 2));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(g, eweight, included, parent, minv, wl1, wl1size);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mst_first(g, eweight, sp, minv, parent, wl1, *wl1size, wl2, wl2size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    if (*wl1size > 0) {\n      mst_second(g, sp, included, minv, parent, wl1, *wl1size);\n\n      // std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_vertex_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv, int* const wl1, int* wlsize)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  *wlsize = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n\n    wl1[(*wlsize)++] = v;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // MixSyncBug here\n  int curr = atomicRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    // MixSyncBug here\n    while (curr != (next = atomicRead(&parent[curr]))) {\n      // MixSyncBug here\n      atomicWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, int* const minv, int* const parent, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int v = wl1[idx];\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool inWL = false;\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if (!inWL) {\n            wl2[fetch_and_add(wl2size)] = v;\n            inWL = true;\n          }\n\n          int edx, upd;\n          // MixSyncBug here\n          upd = atomicRead(&minv[arep]);\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n          // MixSyncBug here\n          upd = atomicRead(&minv[brep]);\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n        }\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, bool* const included, int* const minv, int* const parent, const int* const wl1, const int wl1size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int v = wl1[idx];\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if ((e == minv[arep]) || (e == minv[brep])) {\n            // if this was the best edge found for the set\n            join(arep, brep, parent);\n            included[e] = true;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(g, eweight, included, parent, minv, wl1, wl1size);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mst_first(g, eweight, minv, parent, wl1, *wl1size, wl2, wl2size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    if (*wl1size > 0) {\n      mst_second(g, included, minv, parent, wl1, *wl1size);\n\n      // std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_edge_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  // RaceBug here\n  int curr = parent[idx];\n  if (curr != idx) {\n    int next, prev = idx;\n    // RaceBug here\n    while (curr != (next = parent[curr])) {\n      // RaceBug here\n      parent[prev] = next;\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, const int* const sp, int* const minv, int* const parent, int* goagain)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    if (dst > src) {\n      const int arep = findRep(src, parent);\n      const int brep = findRep(dst, parent);\n      if (arep != brep) {\n        // RaceBug here\n        *goagain = 1;\n\n        int edx, upd;\n        // RaceBug here\n        upd = minv[arep];\n        do {\n          edx = upd;\n          const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n          if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n        } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n        // RaceBug here\n        upd = minv[brep];\n        do {\n          edx = upd;\n          const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n          if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n        } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, const int* const sp, bool* const included, int* const minv, int* const parent)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    if (dst > src) {\n      const int arep = findRep(src, parent);\n      const int brep = findRep(dst, parent);\n      if (arep != brep) {\n        if ((e == minv[arep]) || (e == minv[brep])) {\n          // if this was the best edge found for the set\n          join(arep, brep, parent);\n          included[e] = true;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, const int* const sp, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n\n  init(g, eweight, included, parent, minv);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mst_first(g, eweight, sp, minv, parent, goagain);\n\n    if (*goagain) {\n      mst_second(g, sp, included, minv, parent);\n\n      //std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int i = 0; i < g.nodes; i++) minv[i] = INT_MAX;\n    }\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        const data_type d = atomicRead(&dist[dst]);\n        if (d > new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          wl2[fetch_and_add(wl2size)] = dst;\n          update = true;\n        }\n      }\n      if (update) {\n        wl2[fetch_and_add(wl2size)] = src;\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, data_type* const dist_n, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (new_dist < d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist_n[v], d);\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = malloc(g.nodes * sizeof(data_type));\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, dist_new, goagain);\n    SWAP(dist, dist_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (new_dist < d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist[v], d);\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[v];\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[v];\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < g.nodes; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_edge_data(const ECLgraph g, const int* const sp, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = dist[src];\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n    critical_min(&dist_n[src], s);\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  data_type* dist_new = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* time = (int*) malloc(g.edges * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_edge_data(g, sp, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(dist_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        const data_type d = atomicRead(&dist[dst]);\n        if (d > new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n          update = true;\n        }\n      }\n      if (update) {\n        if (critical_max(&time[src], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = src;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      const data_type d = atomicRead(&dist[dst]);\n      if (d > new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = atomicRead(&dist[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      atomicWrite(&dist[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < g.nodes; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_edge_data(const ECLgraph g, const int* const sp, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = dist[src];\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n    critical_min(&dist_n[src], s);\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  data_type* dist_new = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* time = (int*) malloc(g.edges * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_edge_data(g, sp, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(dist_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, const int* const sp, data_type* const dist, data_type* const dist_n, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // read distance from source vertex\n    const data_type s = dist[src];\n\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  data_type* dist_new = malloc(sizeof(data_type) * g.nodes);\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, sp, dist, dist_new, goagain);\n    SWAP(dist, dist_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(dist_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n\n    if (updated) {\n      critical_min(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < g.nodes; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_edge_data(const ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* time = (int*) malloc(g.edges * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < g.nodes; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_edge_data(const ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* time = (int*) malloc(g.edges * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = atomicRead(&dist[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      atomicWrite(&dist[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, data_type* const dist_n, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = dist[v];\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n        if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = malloc(sizeof(data_type) * g.nodes);\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, dist_new, goagain);\n    SWAP(dist, dist_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, const int* const sp, data_type* const dist, data_type* const dist_n, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // read distance from source vertex\n    const data_type s = dist[src];\n\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  data_type* dist_new = malloc(sizeof(data_type) * g.nodes);\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, sp, dist, dist_new, goagain);\n    SWAP(dist, dist_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(dist_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (new_dist < d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist[v], d);\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, data_type* const dist_n, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (new_dist < d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist_n[v], d);\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = malloc(g.nodes * sizeof(data_type));\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, dist_new, goagain);\n    SWAP(dist, dist_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, data_type* const dist_n, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = dist[v];\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n        if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = malloc(sizeof(data_type) * g.nodes);\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, dist_new, goagain);\n    SWAP(dist, dist_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        const data_type d = atomicRead(&dist[dst]);\n        if (d > new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          wl2[fetch_and_add(wl2size)] = dst;\n          update = true;\n        }\n      }\n      if (update) {\n        wl2[fetch_and_add(wl2size)] = src;\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      const data_type d = atomicRead(&dist[dst]);\n      if (d > new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        const data_type d = atomicRead(&dist[dst]);\n        if (d > new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n          update = true;\n        }\n      }\n      if (update) {\n        if (critical_max(&time[src], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = src;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < g.nodes; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_edge_data(const ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      data_type d = atomicRead(&dist[dst]);\n      if (d > new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        if (critical_max(&time[e], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = e;\n        }\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* time = (int*) malloc(g.edges * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n        const data_type d = atomicRead(&dist[dst]);\n        if (d > new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + g.eweight[i];\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n\n    if (updated) {\n      critical_min(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void sssp(const ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + g.eweight[i];\n        const data_type d = atomicRead(&dist[dst]);\n        if (d > new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_vertex(const int src, const ECLgraph g, data_type* dist)\n{\n  struct timeval start, end;\n\n  init(src, dist, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    sssp(g, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_sssp_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < g.nodes; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void sssp_edge_data(const ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n    if (s != maxval) {\n      const data_type new_dist = s + g.eweight[e];\n      data_type d = atomicRead(&dist[dst]);\n      if (d > new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        if (critical_max(&time[e], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = e;\n        }\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUsssp_edge(const int src, const ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* time = (int*) malloc(g.edges * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  struct timeval start, end;\n\n  init(src, dist, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    sssp_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, const int size, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        wl2[criticalAdd(wl2size, 1)] = v;\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        atomicWrite(&status[v], included);\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          atomicWrite(&status[g.nlist[i]], excluded);\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, g.nodes, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, wl1, *wl1size, wl2, wl2size);\n\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        wl2[criticalAdd(wl2size, 1)] = v;\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        atomicWrite(&status_n[v], included);\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          atomicWrite(&status_n[g.nlist[i]], excluded);\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        wl2[criticalAdd(wl2size, 1)] = v;\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        atomicWrite(&status_n[v], included);\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          atomicWrite(&status_n[g.nlist[i]], excluded);\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    lost[v] = 0;\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n    // go over all edges\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status_n[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status_n[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower priority node as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(data_type* const status, data_type* const status_n, data_type* const lost, const int size, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < size; v++) {\n    // go over all vertexes\n    if (lost[v] == 0) {\n      if(status[v] == undecided) {\n        status_n[v] = included;\n      }\n    }\n    else {\n      atomicWrite(goagain, 1);\n      lost[v] = 0; //reset lost flag\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  data_type* lost = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, lost, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, status_new, lost);\n\n    updateUndecided(status, status_new, g.nodes);\n\n    // vertex pass\n    mis_vertex_pass(status, status_new, lost, g.nodes, goagain);\n\n    updateUndecided(status, status_new, g.nodes);\n  } while (*goagain);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(lost);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && (atomicRead(&status[g.nlist[i]]) != included) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        if (atomicRead(&status[g.nlist[i]]) == included) {\n          // found included neighbor -> exclude self\n          status_n[v] = excluded;\n        } else {\n          atomicWrite(goagain, 1);\n        }\n      } else {\n        // no such neighbor -> v is \"included\"\n        status_n[v] = included;\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    updateUndecided(status, status_new, g.nodes);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const lost, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    lost[v] = 0;\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n    // go over all edges\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower priority node as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(data_type* const status, data_type* const lost, const int size, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < size; v++) {\n    // go over all vertexes\n    if (lost[v] == 0) {\n      if(status[v] == undecided) {\n        status[v] = included;\n      }\n    }\n    else {\n      atomicWrite(goagain, 1);\n      lost[v] = 0; //reset lost flag\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* lost = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, lost, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, lost);\n\n\n    // vertex pass\n    mis_vertex_pass(status, lost, g.nodes, goagain);\n\n  } while (*goagain);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(lost);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    lost[v] = 0;\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n    // go over all edges\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status_n[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status_n[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower priority node as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(data_type* const status, data_type* const status_n, data_type* const lost, const int size, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < size; v++) {\n    // go over all vertexes\n    if (lost[v] == 0) {\n      if(status[v] == undecided) {\n        status_n[v] = included;\n      }\n    }\n    else {\n      atomicWrite(goagain, 1);\n      lost[v] = 0; //reset lost flag\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  data_type* lost = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, lost, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, status_new, lost);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    // vertex pass\n    mis_vertex_pass(status, status_new, lost, g.nodes, goagain);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n  } while (*goagain);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for schedule(dynamic)\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(lost);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, int* const status, int* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, int* const status, int* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        atomicWrite(goagain, 1);\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        atomicWrite(&status_n[v], included);\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          atomicWrite(&status_n[g.nlist[i]], excluded);\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, int* status)\n{\n  int* status_new = malloc(g.nodes * sizeof(int));\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n  } while(*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, int* const status, int* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, int* const status, int* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        atomicWrite(goagain, 1);\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        atomicWrite(&status_n[v], included);\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          atomicWrite(&status_n[g.nlist[i]], excluded);\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, int* status)\n{\n  int* status_new = malloc(g.nodes * sizeof(int));\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n  } while(*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    lost[v] = 0;\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n    // go over all edges\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status_n[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status_n[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower priority node as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(data_type* const status, data_type* const status_n, data_type* const lost, const int size, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < size; v++) {\n    // go over all vertexes\n    if (lost[v] == 0) {\n      if(status[v] == undecided) {\n        status_n[v] = included;\n      }\n    }\n    else {\n      atomicWrite(goagain, 1);\n      lost[v] = 0; //reset lost flag\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  data_type* lost = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, lost, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, status_new, lost);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    // vertex pass\n    mis_vertex_pass(status, status_new, lost, g.nodes, goagain);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n  } while (*goagain);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(lost);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    time[v] = 0;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && (atomicRead(&status[g.nlist[i]]) != included) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        if (atomicRead(&status[g.nlist[i]]) == included) {\n          // found included neighbor -> exclude self\n          status_n[v] = excluded;\n          // and WL neighbors\n          for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n            if(critical_max(&time[g.nlist[j]], iter) != iter) {\n              wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n            }\n          }\n        }\n      } else {\n        // no included neighbor -> v is \"included\"\n        status_n[v] = included;\n        // and WL neighbors\n        for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n          if(critical_max(&time[g.nlist[j]], iter) != iter) {\n            wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size, time);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < g.nodes; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    lost[v] = 0;\n  }\n  *wlsize = 0;\n  for (int e = 0; e < g.edges; e++)\n  {\n    // initialize worklist\n    if (sp[e] < g.nlist[e]) {\n      wl1[(*wlsize)++] = e;\n    }\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, const data_type* const priority, data_type* const status, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all edges in wl1\n    int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    const int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if src node won\n    if (lost[src] == 0) {\n      if (atomicRead(&status[src]) == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status[src], included);\n      }\n    }\n    // if dst node won\n    if (lost[dst] == 0) {\n      if (atomicRead(&status[dst]) == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status[dst], included);\n      }\n    }\n    if (atomicRead(&status[src]) == undecided || atomicRead(&status[dst]) == undecided) {\n      // if either node is still undecided, keep edge in WL\n      wl2[criticalAdd(wl2size, 1)] = e;\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* lost = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(size * sizeof(int));\n  int* wl2 = malloc(size * sizeof(int));\n  int* wl1size = malloc(size * sizeof(int));\n  int* wl2size = malloc(size * sizeof(int));\n\n  init(g, sp, priority, status, lost, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, lost, wl1, *wl1size, wl2, wl2size);\n\n\n    // vertex pass\n    mis_vertex_pass(g, sp, priority, status, lost, wl1, *wl1size, wl2, wl2size);\n\n\n    for (int i = 0; i < g.nodes; i++) {\n      lost[i] = 0;\n    }\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(lost);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, const int size, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    time[v] = 0;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && (atomicRead(&status[g.nlist[i]]) != included) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        if (atomicRead(&status[g.nlist[i]]) == included) {\n          // found included neighbor -> exclude self\n          atomicWrite(&status[v], excluded);\n          // and WL neighbors\n          for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n            if(critical_max(&time[g.nlist[j]], iter) != iter) {\n              wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n            }\n          }\n        }\n      } else {\n        // no included neighbor -> v is \"included\"\n        atomicWrite(&status[v], included);\n        // and WL neighbors\n        for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n          if(critical_max(&time[g.nlist[j]], iter) != iter) {\n            wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, g.nodes, wl1, wl1size, time);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, wl1, *wl1size, wl2, wl2size, iter, time);\n\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        wl2[criticalAdd(wl2size, 1)] = v;\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        atomicWrite(&status_n[v], included);\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          atomicWrite(&status_n[g.nlist[i]], excluded);\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new =  malloc(sizeof(data_type) * g.nodes);;\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size);\n\n    updateFromWorklist(status, status_new, wl1, *wl1size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    time[v] = 0;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && (atomicRead(&status[g.nlist[i]]) != included) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        if (atomicRead(&status[g.nlist[i]]) == included) {\n          // found included neighbor -> exclude self\n          status_n[v] = excluded;\n          // and WL neighbors\n          for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n            if(critical_max(&time[g.nlist[j]], iter) != iter) {\n              wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n            }\n          }\n        }\n      } else {\n        // no included neighbor -> v is \"included\"\n        status_n[v] = included;\n        // and WL neighbors\n        for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n          if(critical_max(&time[g.nlist[j]], iter) != iter) {\n            wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);;\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size, time);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    updateFromWorklist(status, status_new, wl1, *wl1size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < g.nodes; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    lost[v] = 0;\n  }\n  *wlsize = 0;\n  for (int e = 0; e < g.edges; e++)\n  {\n    // initialize worklist\n    if (sp[e] < g.nlist[e]) {\n      wl1[(*wlsize)++] = e;\n    }\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, const data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all edges in wl1\n    int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status_n[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status_n[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    const int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if src node won\n    if (lost[src] == 0) {\n      if (status[src] == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status_n[src], included);\n      }\n    }\n    // if dst node won\n    if (lost[dst] == 0) {\n      if (status[dst] == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status_n[dst], included);\n      }\n    }\n    if (atomicRead(&status[src]) == undecided || atomicRead(&status[dst]) == undecided) {\n      // if either node is still undecided, keep edge in WL\n      wl2[criticalAdd(wl2size, 1)] = e;\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* status_new = malloc(g.nodes * sizeof(data_type));\n  data_type* lost = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(size * sizeof(int));\n  int* wl2 = malloc(size * sizeof(int));\n  int* wl1size = malloc(size * sizeof(int));\n  int* wl2size = malloc(size * sizeof(int));\n\n  init(g, sp, priority, status, status_new, lost, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, status_new, lost, wl1, *wl1size, wl2, wl2size);\n\n    updateFromWorklist(g, sp, status, status_new, wl1, *wl1size);\n\n    // vertex pass\n    mis_vertex_pass(g, sp, priority, status, status_new, lost, wl1, *wl1size, wl2, wl2size);\n\n    updateFromWorklist(g, sp, status, status_new, wl1, *wl1size);\n\n    for (int i = 0; i < g.nodes; i++) {\n      lost[i] = 0;\n    }\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(lost);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, int* const status, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, int* const status, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        atomicWrite(goagain, 1);\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        atomicWrite(&status[v], included);\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          atomicWrite(&status[g.nlist[i]], excluded);\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, int* status)\n{\n\n  init(priority, status, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, goagain);\n\n  } while(*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const lost, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    lost[v] = 0;\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n    // go over all edges\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower priority node as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(data_type* const status, data_type* const lost, const int size, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < size; v++) {\n    // go over all vertexes\n    if (lost[v] == 0) {\n      if(status[v] == undecided) {\n        status[v] = included;\n      }\n    }\n    else {\n      atomicWrite(goagain, 1);\n      lost[v] = 0; //reset lost flag\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* lost = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, lost, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, lost);\n\n\n    // vertex pass\n    mis_vertex_pass(status, lost, g.nodes, goagain);\n\n  } while (*goagain);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for schedule(dynamic)\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(lost);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, const int size, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        wl2[criticalAdd(wl2size, 1)] = v;\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        atomicWrite(&status[v], included);\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          atomicWrite(&status[g.nlist[i]], excluded);\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, g.nodes, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, wl1, *wl1size, wl2, wl2size);\n\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && (atomicRead(&status[g.nlist[i]]) != included) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        if (atomicRead(&status[g.nlist[i]]) == included) {\n          // found included neighbor -> exclude self\n          atomicWrite(&status[v], excluded);\n        } else {\n          atomicWrite(goagain, 1);\n        }\n      } else {\n        // no such neighbor -> v is \"included\"\n        atomicWrite(&status[v], included);\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n\n  init(priority, status, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, goagain);\n\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < g.nodes; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    lost[v] = 0;\n  }\n  *wlsize = 0;\n  for (int e = 0; e < g.edges; e++)\n  {\n    // initialize worklist\n    if (sp[e] < g.nlist[e]) {\n      wl1[(*wlsize)++] = e;\n    }\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, const data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all edges in wl1\n    int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status_n[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status_n[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    const int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if src node won\n    if (lost[src] == 0) {\n      if (status[src] == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status_n[src], included);\n      }\n    }\n    // if dst node won\n    if (lost[dst] == 0) {\n      if (status[dst] == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status_n[dst], included);\n      }\n    }\n    if (atomicRead(&status[src]) == undecided || atomicRead(&status[dst]) == undecided) {\n      // if either node is still undecided, keep edge in WL\n      wl2[criticalAdd(wl2size, 1)] = e;\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* status_new = malloc(g.nodes * sizeof(data_type));\n  data_type* lost = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(size * sizeof(int));\n  int* wl2 = malloc(size * sizeof(int));\n  int* wl1size = malloc(size * sizeof(int));\n  int* wl2size = malloc(size * sizeof(int));\n\n  init(g, sp, priority, status, status_new, lost, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, status_new, lost, wl1, *wl1size, wl2, wl2size);\n\n    updateFromWorklist(g, sp, status, status_new, wl1, *wl1size);\n\n    // vertex pass\n    mis_vertex_pass(g, sp, priority, status, status_new, lost, wl1, *wl1size, wl2, wl2size);\n\n    updateFromWorklist(g, sp, status, status_new, wl1, *wl1size);\n\n    for (int i = 0; i < g.nodes; i++) {\n      lost[i] = 0;\n    }\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for schedule(dynamic)\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(lost);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && (atomicRead(&status[g.nlist[i]]) != included) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        if (atomicRead(&status[g.nlist[i]]) == included) {\n          // found included neighbor -> exclude self\n          status_n[v] = excluded;\n        } else {\n          atomicWrite(goagain, 1);\n        }\n      } else {\n        // no such neighbor -> v is \"included\"\n        status_n[v] = included;\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    updateUndecided(status, status_new, g.nodes);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && (atomicRead(&status[g.nlist[i]]) != included) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        if (atomicRead(&status[g.nlist[i]]) == included) {\n          // found included neighbor -> exclude self\n          atomicWrite(&status[v], excluded);\n        } else {\n          atomicWrite(goagain, 1);\n        }\n      } else {\n        // no such neighbor -> v is \"included\"\n        atomicWrite(&status[v], included);\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n\n  init(priority, status, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, goagain);\n\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    time[v] = 0;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && (atomicRead(&status[g.nlist[i]]) != included) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        if (atomicRead(&status[g.nlist[i]]) == included) {\n          // found included neighbor -> exclude self\n          status_n[v] = excluded;\n          // and WL neighbors\n          for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n            if(critical_max(&time[g.nlist[j]], iter) != iter) {\n              wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n            }\n          }\n        }\n      } else {\n        // no included neighbor -> v is \"included\"\n        status_n[v] = included;\n        // and WL neighbors\n        for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n          if(critical_max(&time[g.nlist[j]], iter) != iter) {\n            wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);;\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size, time);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    updateFromWorklist(status, status_new, wl1, *wl1size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, int* const status, int* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, int* const status, int* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        atomicWrite(goagain, 1);\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        atomicWrite(&status_n[v], included);\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          atomicWrite(&status_n[g.nlist[i]], excluded);\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, int* status)\n{\n  int* status_new = malloc(sizeof(int) * g.nodes);\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    updateUndecided(status, status_new, g.nodes);\n  } while(*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && (atomicRead(&status[g.nlist[i]]) != included) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        if (atomicRead(&status[g.nlist[i]]) == included) {\n          // found included neighbor -> exclude self\n          status_n[v] = excluded;\n        } else {\n          atomicWrite(goagain, 1);\n        }\n      } else {\n        // no such neighbor -> v is \"included\"\n        status_n[v] = included;\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < g.nodes; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    lost[v] = 0;\n  }\n  *wlsize = 0;\n  for (int e = 0; e < g.edges; e++)\n  {\n    // initialize worklist\n    if (sp[e] < g.nlist[e]) {\n      wl1[(*wlsize)++] = e;\n    }\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, const data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all edges in wl1\n    int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status_n[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status_n[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    const int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if src node won\n    if (lost[src] == 0) {\n      if (status[src] == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status_n[src], included);\n      }\n    }\n    // if dst node won\n    if (lost[dst] == 0) {\n      if (status[dst] == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status_n[dst], included);\n      }\n    }\n    if (atomicRead(&status[src]) == undecided || atomicRead(&status[dst]) == undecided) {\n      // if either node is still undecided, keep edge in WL\n      wl2[criticalAdd(wl2size, 1)] = e;\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* status_new = malloc(g.nodes * sizeof(data_type));\n  data_type* lost = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(size * sizeof(int));\n  int* wl2 = malloc(size * sizeof(int));\n  int* wl1size = malloc(size * sizeof(int));\n  int* wl2size = malloc(size * sizeof(int));\n\n  init(g, sp, priority, status, status_new, lost, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, status_new, lost, wl1, *wl1size, wl2, wl2size);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    // vertex pass\n    mis_vertex_pass(g, sp, priority, status, status_new, lost, wl1, *wl1size, wl2, wl2size);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    for (int i = 0; i < g.nodes; i++) {\n      lost[i] = 0;\n    }\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for schedule(dynamic)\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(lost);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    time[v] = 0;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && (atomicRead(&status[g.nlist[i]]) != included) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        if (atomicRead(&status[g.nlist[i]]) == included) {\n          // found included neighbor -> exclude self\n          status_n[v] = excluded;\n          // and WL neighbors\n          for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n            if(critical_max(&time[g.nlist[j]], iter) != iter) {\n              wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n            }\n          }\n        }\n      } else {\n        // no included neighbor -> v is \"included\"\n        status_n[v] = included;\n        // and WL neighbors\n        for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n          if(critical_max(&time[g.nlist[j]], iter) != iter) {\n            wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size, time);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, int* const status, int* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, int* const status, int* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        atomicWrite(goagain, 1);\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        atomicWrite(&status_n[v], included);\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          atomicWrite(&status_n[g.nlist[i]], excluded);\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, int* status)\n{\n  int* status_new = malloc(sizeof(int) * g.nodes);\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    updateUndecided(status, status_new, g.nodes);\n  } while(*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < g.nodes; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    lost[v] = 0;\n  }\n  *wlsize = 0;\n  for (int e = 0; e < g.edges; e++)\n  {\n    // initialize worklist\n    if (sp[e] < g.nlist[e]) {\n      wl1[(*wlsize)++] = e;\n    }\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, const data_type* const priority, data_type* const status, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all edges in wl1\n    int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    const int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if src node won\n    if (lost[src] == 0) {\n      if (atomicRead(&status[src]) == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status[src], included);\n      }\n    }\n    // if dst node won\n    if (lost[dst] == 0) {\n      if (atomicRead(&status[dst]) == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status[dst], included);\n      }\n    }\n    if (atomicRead(&status[src]) == undecided || atomicRead(&status[dst]) == undecided) {\n      // if either node is still undecided, keep edge in WL\n      wl2[criticalAdd(wl2size, 1)] = e;\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* lost = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(size * sizeof(int));\n  int* wl2 = malloc(size * sizeof(int));\n  int* wl1size = malloc(size * sizeof(int));\n  int* wl2size = malloc(size * sizeof(int));\n\n  init(g, sp, priority, status, lost, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, lost, wl1, *wl1size, wl2, wl2size);\n\n\n    // vertex pass\n    mis_vertex_pass(g, sp, priority, status, lost, wl1, *wl1size, wl2, wl2size);\n\n\n    for (int i = 0; i < g.nodes; i++) {\n      lost[i] = 0;\n    }\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for schedule(dynamic)\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(lost);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    lost[v] = 0;\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n    // go over all edges\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status_n[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status_n[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower priority node as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(data_type* const status, data_type* const status_n, data_type* const lost, const int size, data_type* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < size; v++) {\n    // go over all vertexes\n    if (lost[v] == 0) {\n      if(status[v] == undecided) {\n        status_n[v] = included;\n      }\n    }\n    else {\n      atomicWrite(goagain, 1);\n      lost[v] = 0; //reset lost flag\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n  data_type* lost = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, lost, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, status_new, lost);\n\n    updateUndecided(status, status_new, g.nodes);\n\n    // vertex pass\n    mis_vertex_pass(status, status_new, lost, g.nodes, goagain);\n\n    updateUndecided(status, status_new, g.nodes);\n  } while (*goagain);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for schedule(dynamic)\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(lost);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && (atomicRead(&status[g.nlist[i]]) != included) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        if (atomicRead(&status[g.nlist[i]]) == included) {\n          // found included neighbor -> exclude self\n          status_n[v] = excluded;\n        } else {\n          atomicWrite(goagain, 1);\n        }\n      } else {\n        // no such neighbor -> v is \"included\"\n        status_n[v] = included;\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new = malloc(sizeof(data_type) * g.nodes);\n\n  init(priority, status, status_new, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, status_new, goagain);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, int* const status, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n  }\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, int* const status, data_type* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    // go over all the nodes\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        atomicWrite(goagain, 1);\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        atomicWrite(&status[v], included);\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          atomicWrite(&status[g.nlist[i]], excluded);\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, int* status)\n{\n\n  init(priority, status, g.nodes);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  data_type* goagain = malloc(sizeof(data_type));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mis(g, priority, status, goagain);\n\n  } while(*goagain);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, data_type* const status_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, data_type* const status_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> status still unknown\n        wl2[criticalAdd(wl2size, 1)] = v;\n      } else {\n        // no such neighbor -> all neighbors are \"excluded\" and v is \"included\"\n        atomicWrite(&status_n[v], included);\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          atomicWrite(&status_n[g.nlist[i]], excluded);\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  data_type* status_new =  malloc(sizeof(data_type) * g.nodes);;\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, status_new, g.nodes, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, status_new, wl1, *wl1size, wl2, wl2size);\n\n    updateFromWorklist(status, status_new, wl1, *wl1size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_vertex_omp.h\"\n\nstatic void init(data_type* const priority, data_type* const status, const int size, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    time[v] = 0;\n\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void mis(const ECLgraph g, const data_type* const priority, data_type* const status, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all nodes in WL\n    int v = wl1[w];\n    if (atomicRead(&status[v]) == undecided) {\n      int i = g.nindex[v];\n      // try to find a non-excluded neighbor whose priority is higher\n      while ((i < g.nindex[v + 1]) && (atomicRead(&status[g.nlist[i]]) != included) && ((atomicRead(&status[g.nlist[i]]) == excluded) || (priority[v] > priority[g.nlist[i]]) || ((priority[v] == priority[g.nlist[i]]) && (v > g.nlist[i])))) {\n        i++;\n      }\n      if (i < g.nindex[v + 1]) {\n        // found such a neighbor -> check if neighbor is included\n        if (atomicRead(&status[g.nlist[i]]) == included) {\n          // found included neighbor -> exclude self\n          atomicWrite(&status[v], excluded);\n          // and WL neighbors\n          for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n            if(critical_max(&time[g.nlist[j]], iter) != iter) {\n              wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n            }\n          }\n        }\n      } else {\n        // no included neighbor -> v is \"included\"\n        atomicWrite(&status[v], included);\n        // and WL neighbors\n        for (int j = g.nindex[v]; j < g.nindex[v + 1]; j++) {\n          if(critical_max(&time[g.nlist[j]], iter) != iter) {\n            wl2[criticalAdd(wl2size, 1)] = g.nlist[j];\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double OMPmis_vertex(const ECLgraph g, data_type* const priority, data_type* status)\n{\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(priority, status, g.nodes, wl1, wl1size, time);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mis(g, priority, status, wl1, *wl1size, wl2, wl2size, iter, time);\n\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mis_edge_omp.h\"\n\nstatic void init(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, int* const wl1, int* wlsize)\n{\n  // initialize arrays\n  for (int v = 0; v < g.nodes; v++)\n  {\n    priority[v] = hash(v + 712313887);\n    status[v] = undecided;\n    status_n[v] = undecided;\n    lost[v] = 0;\n  }\n  *wlsize = 0;\n  for (int e = 0; e < g.edges; e++)\n  {\n    // initialize worklist\n    if (sp[e] < g.nlist[e]) {\n      wl1[(*wlsize)++] = e;\n    }\n  }\n}\n\nstatic void mis(const ECLgraph g, const int* const sp, const data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    // go over all edges in wl1\n    int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if one is included, exclude the other\n    if (atomicRead(&status[src]) == included) {\n      atomicWrite(&status_n[dst], excluded);\n    }\n    else if (atomicRead(&status[dst]) == included) {\n      atomicWrite(&status_n[src], excluded);\n    }\n    // if neither included nor excluded -> mark lower as lost\n    else if (atomicRead(&status[src]) != excluded && atomicRead(&status[dst]) != excluded) {\n      if (priority[src] < priority[dst]) {\n        atomicWrite(&lost[src], 1);\n      } else {\n        atomicWrite(&lost[dst], 1);\n      }\n    }\n  }\n}\n\nstatic void mis_vertex_pass(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status, data_type* const status_n, data_type* const lost, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int w = 0; w < wl1size; w++) {\n    const int e = wl1[w];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    // if src node won\n    if (lost[src] == 0) {\n      if (status[src] == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status_n[src], included);\n      }\n    }\n    // if dst node won\n    if (lost[dst] == 0) {\n      if (status[dst] == undecided) {\n        // and is undecided -> include\n        atomicWrite(&status_n[dst], included);\n      }\n    }\n    if (atomicRead(&status[src]) == undecided || atomicRead(&status[dst]) == undecided) {\n      // if either node is still undecided, keep edge in WL\n      wl2[criticalAdd(wl2size, 1)] = e;\n    }\n  }\n}\n\nstatic double OMPmis_edge(const ECLgraph g, const int* const sp, data_type* const priority, data_type* const status)\n{\n  data_type* status_new = malloc(g.nodes * sizeof(data_type));\n  data_type* lost = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(size * sizeof(int));\n  int* wl2 = malloc(size * sizeof(int));\n  int* wl1size = malloc(size * sizeof(int));\n  int* wl2size = malloc(size * sizeof(int));\n\n  init(g, sp, priority, status, status_new, lost, wl1, wl1size);\n\n  struct timeval beg, end;\n  gettimeofday(&beg, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    // edge pass\n    mis(g, sp, priority, status, status_new, lost, wl1, *wl1size, wl2, wl2size);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    // vertex pass\n    mis_vertex_pass(g, sp, priority, status, status_new, lost, wl1, *wl1size, wl2, wl2size);\n\n    for (int i = 0; i < g.nodes; i++) status[i] = status_new[i];\n\n    for (int i = 0; i < g.nodes; i++) {\n      lost[i] = 0;\n    }\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n  // include all remaining nodes that have no edges\n  #pragma omp parallel for\n  for (int i = 0; i < g.nodes; i++) {\n    if (status[i] == undecided)\n    status[i] = included;\n  }\n\n  gettimeofday(&end, NULL);\n  const double runtime = end.tv_sec - beg.tv_sec + (end.tv_usec - beg.tv_usec) / 1000000.0;\n\n  // determine and print set size\n  int cnt = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    if (status[v] == included) cnt++;\n  }\n  printf(\"iterations: %d,  elements in set: %d (%.1f%%)\\n\", iter, cnt, 100.0 * cnt / g.nodes);\n\n  free(status_new);\n  free(lost);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const data_type new_label = atomicRead(&label[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n\n    bool updated = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n      const data_type d = atomicRead(&label[dst]);\n      if (d > new_label) {\n        atomicWrite(&label[dst], new_label);\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    const data_type new_label = label[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      if (critical_min(&label_n[dst], new_label) > new_label) {\n        wl2[fetch_and_add(wl2size)] = dst;\n      }\n    }\n    critical_min(&label_n[src], new_label);\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, label_new, wl1, *wl1size, wl2, wl2size, iter);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free (iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, data_type* const label_n, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const data_type new_label = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n\n    bool updated = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n      if (critical_min(&label_n[dst], new_label) > new_label) {\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(g.nodes * sizeof(data_type));\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, label_new, goagain);\n    SWAP(label, label_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    const data_type new_label = atomicRead(&label[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    bool update = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      const data_type d = atomicRead(&label[dst]);\n      if (d > new_label) {\n        atomicWrite(&label[dst], new_label);\n        if (critical_max(&time[dst], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n        update = true;\n      }\n    }\n    if (update) {\n      if (critical_max(&time[src], iter) != iter) {\n        wl2[fetch_and_add(wl2size)] = src;\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  int* time = malloc(sizeof(int) * g.nodes);\n  for (int i = 0; i < g.nodes; i++) {\n    time[i] = 0;\n  }\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = label[src];\n      if (d > new_label) {\n        d = new_label;\n        updated = true;\n      }\n      critical_min(&label_n[src], new_label);\n    }\n\n    if (updated) {\n      critical_min(&label_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int wlsize;\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  // std::fill(time, time + g.nodes, 0);\n  for (int i = 0; i < g.nodes; i++) time[i] = 0;\n\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, label_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&label[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = atomicRead(&label[src]);\n      if (d > new_label) {\n        d = new_label;\n        atomicWrite(goagain, 1);\n      }\n      atomicWrite(&label[v], d);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = label[src];\n      if (d > new_label) {\n        d = new_label;\n        updated = true;\n      }\n      critical_min(&label_n[src], new_label);\n    }\n\n    if (updated) {\n      critical_min(&label_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int wlsize;\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  // std::fill(time, time + g.nodes, 0);\n  for (int i = 0; i < g.nodes; i++) time[i] = 0;\n\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, label_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&label[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = atomicRead(&label[src]);\n      if (d > new_label) {\n        d = new_label;\n        atomicWrite(goagain, 1);\n      }\n      atomicWrite(&label[v], d);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  int idx = 0;\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      wl1[idx] = i;\n      idx++;\n    }\n  }\n  *wlsize = idx;\n}\n\nstatic void cc_edge_data(const ECLgraph g, const int* const sp, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type new_label = atomicRead(&label[src]);\n    data_type d = atomicRead(&label[dst]);\n    if (d > new_label) {\n      atomicWrite(&label[dst], new_label);\n      if (critical_max(&time[e], iter) != iter) {\n        wl2[fetch_and_add(wl2size)] = e;\n      }\n      for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n        if (critical_max(&time[j], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = j;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.edges);\n  int* wl1size = malloc(sizeof(int));\n  int *wl2size = malloc(sizeof(int));\n\n  for (int i = 0; i < g.edges; i++) time[i] = 0;\n\n  struct timeval start, end;\n  init(label, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_edge_data(g, sp, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const data_type new_label = atomicRead(&label[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n\n    bool updated = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n      const data_type d = atomicRead(&label[dst]);\n      if (d > new_label) {\n        atomicWrite(&label[dst], new_label);\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, const int* const sp, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    data_type new_label;\n    #pragma omp critical\n    new_label = label[src];\n\n    if (critical_min(&label[dst], new_label) > new_label) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, sp, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, const int* const sp, data_type* const label, data_type* const label_n, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type new_label = label[src];\n\n    if (critical_min(&label_n[dst], new_label) > new_label) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, sp, label, label_new, goagain);\n    SWAP(label, label_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    const data_type new_label = atomicRead(&label[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    bool update = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      const data_type d = atomicRead(&label[dst]);\n      if (d > new_label) {\n        atomicWrite(&label[dst], new_label);\n        if (critical_max(&time[dst], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n        update = true;\n      }\n    }\n    if (update) {\n      if (critical_max(&time[src], iter) != iter) {\n        wl2[fetch_and_add(wl2size)] = src;\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  int* time = malloc(sizeof(int) * g.nodes);\n  for (int i = 0; i < g.nodes; i++) {\n    time[i] = 0;\n  }\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = atomicRead(&label[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = atomicRead(&label[src]);\n      if (d > new_label) {\n        d = new_label;\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(&label[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int wlsize;\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  // std::fill(time, time + g.nodes, 0);\n  for (int i = 0; i < g.nodes; i++) time[i] = 0;\n\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    data_type new_label;\n    #pragma omp critical\n    new_label = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n\n    bool updated = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n      if (critical_min(&label[dst], new_label) > new_label) {\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, const int* const sp, data_type* const label, data_type* const label_n, int* goagain)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type new_label = label[src];\n\n    if (critical_min(&label_n[dst], new_label) > new_label) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, sp, label, label_new, goagain);\n    SWAP(label, label_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  int idx = 0;\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      wl1[idx] = i;\n      idx++;\n    }\n  }\n  *wlsize = idx;\n}\n\nstatic void cc_edge_data(const ECLgraph g, const int* const sp, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type new_label = label[src];\n    if (critical_min(&label_n[dst], new_label) > new_label) {\n      for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n        if (critical_max(&time[j], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = j;\n        }\n      }\n    }\n    critical_min(&label_n[src], new_label);\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.edges);\n  int* wl1size = malloc(sizeof(int));\n  int *wl2size = malloc(sizeof(int));\n\n  for (int i = 0; i < g.edges; i++) time[i] = 0;\n\n  struct timeval start, end;\n  init(label, label_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_edge_data(g, sp, label, label_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    const data_type new_label = atomicRead(&label[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    bool update = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      const data_type d = atomicRead(&label[dst]);\n      if (d > new_label) {\n        atomicWrite(&label[dst], new_label);\n        wl2[fetch_and_add(wl2size)] = dst;\n        update = true;\n      }\n    }\n    if (update) {\n      wl2[fetch_and_add(wl2size)] = src;\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  int idx = 0;\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      wl1[idx] = i;\n      idx++;\n    }\n  }\n  *wlsize = idx;\n}\n\nstatic void cc_edge_data(const ECLgraph g, const int* const sp, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type new_label = atomicRead(&label[src]);\n    data_type d = atomicRead(&label[dst]);\n    if (d > new_label) {\n      atomicWrite(&label[dst], new_label);\n      if (critical_max(&time[e], iter) != iter) {\n        wl2[fetch_and_add(wl2size)] = e;\n      }\n      for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n        if (critical_max(&time[j], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = j;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.edges);\n  int* wl1size = malloc(sizeof(int));\n  int *wl2size = malloc(sizeof(int));\n\n  for (int i = 0; i < g.edges; i++) time[i] = 0;\n\n  struct timeval start, end;\n  init(label, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_edge_data(g, sp, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  int idx = 0;\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      wl1[idx] = i;\n      idx++;\n    }\n  }\n  *wlsize = idx;\n}\n\nstatic void cc_edge_data(const ECLgraph g, const int* const sp, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    data_type new_label;\n    #pragma omp critical\n    new_label = label[src];\n    if (critical_min(&label[dst], new_label) > new_label) {\n      for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n        if (critical_max(&time[j], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = j;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.edges);\n  int* wl1size = malloc(sizeof(int));\n  int *wl2size = malloc(sizeof(int));\n\n  for (int i = 0; i < g.edges; i++) time[i] = 0;\n\n  struct timeval start, end;\n  init(label, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_edge_data(g, sp, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    const data_type new_label = label[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      if (critical_min(&label_n[dst], new_label) > new_label) {\n        if (critical_max(&time[dst], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n    critical_min(&label_n[src], new_label);\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  int* time = malloc(sizeof(int) * g.nodes);\n  for (int i = 0; i < g.nodes; i++) {\n    time[i] = 0;\n  }\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, label_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free (iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    data_type new_label;\n    #pragma omp critical\n    new_label = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n\n    bool updated = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n      if (critical_min(&label[dst], new_label) > new_label) {\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, data_type* const label_n, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const data_type new_label = label[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n\n    bool updated = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n      if (critical_min(&label_n[dst], new_label) > new_label) {\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(g.nodes * sizeof(data_type));\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, label_new, goagain);\n    SWAP(label, label_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  int idx = 0;\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      wl1[idx] = i;\n      idx++;\n    }\n  }\n  *wlsize = idx;\n}\n\nstatic void cc_edge_data(const ECLgraph g, const int* const sp, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type new_label = label[src];\n    if (critical_min(&label_n[dst], new_label) > new_label) {\n      for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n        if (critical_max(&time[j], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = j;\n        }\n      }\n    }\n    critical_min(&label_n[src], new_label);\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.edges);\n  int* wl1size = malloc(sizeof(int));\n  int *wl2size = malloc(sizeof(int));\n\n  for (int i = 0; i < g.edges; i++) time[i] = 0;\n\n  struct timeval start, end;\n  init(label, label_new, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_edge_data(g, sp, label, label_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = atomicRead(&label[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = atomicRead(&label[src]);\n      if (d > new_label) {\n        d = new_label;\n        updated = true;\n      }\n    }\n\n    if (updated) {\n      atomicWrite(&label[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int wlsize;\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  // std::fill(time, time + g.nodes, 0);\n  for (int i = 0; i < g.nodes; i++) time[i] = 0;\n\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, const int* const sp, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type new_label = atomicRead(&label[src]);\n\n    const data_type d = atomicRead(&label[dst]);\n    if (d > new_label) {\n      atomicWrite(&label[dst], new_label);\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, sp, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    data_type new_label;\n    #pragma omp critical\n    new_label = label[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      if (critical_min(&label[dst], new_label) > new_label) {\n        wl2[fetch_and_add(wl2size)] = dst;\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    data_type new_label;\n    #pragma omp critical\n    new_label = label[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      if (critical_min(&label[dst], new_label) > new_label) {\n        if (critical_max(&time[dst], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  int* time = malloc(sizeof(int) * g.nodes);\n  for (int i = 0; i < g.nodes; i++) {\n    time[i] = 0;\n  }\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, const int* const sp, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type new_label = atomicRead(&label[src]);\n\n    const data_type d = atomicRead(&label[dst]);\n    if (d > new_label) {\n      atomicWrite(&label[dst], new_label);\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, sp, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, data_type* const label_n, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&label[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = atomicRead(&label[src]);\n      if (d > new_label) {\n        d = new_label;\n        atomicWrite(goagain, 1);\n      }\n      atomicWrite(&label_n[v], d);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, label_new, goagain);\n    SWAP(label, label_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    data_type new_label;\n    #pragma omp critical\n    new_label = label[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      if (critical_min(&label[dst], new_label) > new_label) {\n        if (critical_max(&time[dst], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  int* time = malloc(sizeof(int) * g.nodes);\n  for (int i = 0; i < g.nodes; i++) {\n    time[i] = 0;\n  }\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    data_type new_label;\n    #pragma omp critical\n    new_label = label[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      if (critical_min(&label[dst], new_label) > new_label) {\n        wl2[fetch_and_add(wl2size)] = dst;\n      }\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    const data_type new_label = label[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      if (critical_min(&label_n[dst], new_label) > new_label) {\n        wl2[fetch_and_add(wl2size)] = dst;\n      }\n    }\n    critical_min(&label_n[src], new_label);\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, label_new, wl1, *wl1size, wl2, wl2size, iter);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free (iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    const data_type new_label = atomicRead(&label[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    bool update = false;\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      const data_type d = atomicRead(&label[dst]);\n      if (d > new_label) {\n        atomicWrite(&label[dst], new_label);\n        wl2[fetch_and_add(wl2size)] = dst;\n        update = true;\n      }\n    }\n    if (update) {\n      wl2[fetch_and_add(wl2size)] = src;\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n  struct timeval start, end;\n\n  init(label, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, wl1, *wl1size, wl2, wl2size, iter);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, const int* const sp, data_type* const label, int* goagain)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    data_type new_label;\n    #pragma omp critical\n    new_label = label[src];\n\n    if (critical_min(&label[dst], new_label) > new_label) {\n      atomicWrite(goagain, 1);\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  struct timeval start, end;\n\n  init(label, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, sp, label, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_edge_omp.h\"\n\nstatic void init(data_type* const label, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  int idx = 0;\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label[v] = v;\n\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      wl1[idx] = i;\n      idx++;\n    }\n  }\n  *wlsize = idx;\n}\n\nstatic void cc_edge_data(const ECLgraph g, const int* const sp, data_type* const label, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    data_type new_label;\n    #pragma omp critical\n    new_label = label[src];\n    if (critical_min(&label[dst], new_label) > new_label) {\n      for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n        if (critical_max(&time[j], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = j;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUcc_edge(const ECLgraph g, data_type* label, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = malloc(sizeof(int) * size);\n  int* wl2 = malloc(sizeof(int) * size);\n  int* time = malloc(sizeof(int) * g.edges);\n  int* wl1size = malloc(sizeof(int));\n  int *wl2size = malloc(sizeof(int));\n\n  for (int i = 0; i < g.edges; i++) time[i] = 0;\n\n  struct timeval start, end;\n  init(label, g.nodes, g, wl1, wl1size, time);\n\n  // iterate until no more changes\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_edge_data(g, sp, label, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size, int* const wl1, int* wlsize)\n{\n  // initialize label array\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n    // initialize worklist\n    wl1[v] = v;\n  }\n  *wlsize = size;\n}\n\nstatic void cc_vertex_data(const ECLgraph g, data_type* const label, data_type* const label_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    const data_type new_label = label[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    for (int i = beg; i < end; i++) {\n      const int dst = g.nlist[i];\n\n      if (critical_min(&label_n[dst], new_label) > new_label) {\n        if (critical_max(&time[dst], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n    critical_min(&label_n[src], new_label);\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*) malloc(size * sizeof(int));\n  int* wl2 = (int*) malloc(size * sizeof(int));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  int* time = malloc(sizeof(int) * g.nodes);\n  for (int i = 0; i < g.nodes; i++) {\n    time[i] = 0;\n  }\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes, wl1, wl1size);\n\n  // iterate until no more changes\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    cc_vertex_data(g, label, label_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(label, label_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free (iter % 2 ? label : label_new);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  free(time);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_cc_vertex_omp.h\"\n\nstatic void init(data_type* const label, data_type* const label_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    label_n[v] = v;\n    label[v] = v;\n  }\n}\n\nstatic void cc(const ECLgraph g, data_type* const label, data_type* const label_n, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&label[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type new_label = atomicRead(&label[src]);\n      if (d > new_label) {\n        d = new_label;\n        atomicWrite(goagain, 1);\n      }\n      atomicWrite(&label_n[v], d);\n    }\n  }\n}\n\nstatic double CPUcc_vertex(const ECLgraph g, data_type* label)\n{\n  data_type* label_new = malloc(sizeof(data_type) * g.nodes);\n  struct timeval start, end;\n\n  init(label, label_new, g.nodes);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  gettimeofday(&start, NULL);\n\n  do {\n    iter++;\n    *goagain = 0;\n    cc(g, label, label_new, goagain);\n    SWAP(label, label_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_vertex_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < nodes; v++) {\n    data_type count = 0;\n    const int beg1 = nindex[v];\n    const int end1 = nindex[v + 1];\n    int start1 = end1;\n    while ((beg1 < start1) && (v < nlist[start1 - 1])) start1--;\n    for (int j = start1; j < end1; j++) {\n      const int u = nlist[j];\n      const int beg2 = nindex[u];\n      const int end2 = nindex[u + 1];\n      int start2 = end2;\n      while ((beg2 < start2) && (u < nlist[start2 - 1])) start2--;\n      count += (data_type)common(j + 1, end1, start2, end2, nlist);\n    }\n    #pragma omp atomic\n    (*g_count) += count;\n  }\n}\n\nstatic double CPUtc_vertex(data_type* count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, nodes, nindex, nlist);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_edge_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < edges; e++) {\n    data_type count = 0;\n    const int src = sp[e];\n    const int dst = nlist[e];\n    if (src > dst) {\n      const int beg1 = nindex[dst];\n      const int end1 = nindex[dst + 1];\n      for (int i = beg1; i < end1 && nlist[i] < dst; i++) {\n        const int u = nlist[i];\n        int beg2 = nindex[src];\n        int end2 = nindex[src + 1];\n        if (find(u, beg2, end2, nlist)) count++;\n      }\n      #pragma omp critical\n      (*g_count) += count;\n    }\n  }\n}\n\nstatic double CPUtc_edge(data_type* count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, edges, nindex, nlist, sp);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_edge_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < edges; e++) {\n    data_type count = 0;\n    const int src = sp[e];\n    const int dst = nlist[e];\n    if (src > dst) {\n      const int beg1 = nindex[dst];\n      const int end1 = nindex[dst + 1];\n      for (int i = beg1; i < end1 && nlist[i] < dst; i++) {\n        const int u = nlist[i];\n        int beg2 = nindex[src];\n        int end2 = nindex[src + 1];\n        if (find(u, beg2, end2, nlist)) count++;\n      }\n      #pragma omp critical\n      (*g_count) += count;\n    }\n  }\n}\n\nstatic double CPUtc_edge(data_type* count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, edges, nindex, nlist, sp);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_vertex_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < nodes; v++) {\n    data_type count = 0;\n    const int beg1 = nindex[v];\n    const int end1 = nindex[v + 1];\n    int start1 = end1;\n    while ((beg1 < start1) && (v < nlist[start1 - 1])) start1--;\n    for (int j = start1; j < end1; j++) {\n      const int u = nlist[j];\n      const int beg2 = nindex[u];\n      const int end2 = nindex[u + 1];\n      int start2 = end2;\n      while ((beg2 < start2) && (u < nlist[start2 - 1])) start2--;\n      count += (data_type)common(j + 1, end1, start2, end2, nlist);\n    }\n    #pragma omp atomic\n    (*g_count) += count;\n  }\n}\n\nstatic double CPUtc_vertex(data_type* count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, nodes, nindex, nlist);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_edge_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  data_type result = 0;\n  #pragma omp parallel for reduction(+: result) schedule(dynamic)\n  for (int e = 0; e < edges; e++) {\n    data_type count = 0;\n    const int src = sp[e];\n    const int dst = nlist[e];\n    if (src > dst) {\n      const int beg1 = nindex[dst];\n      const int end1 = nindex[dst + 1];\n      for (int i = beg1; i < end1 && nlist[i] < dst; i++) {\n        const int u = nlist[i];\n        int beg2 = nindex[src];\n        int end2 = nindex[src + 1];\n        if (find(u, beg2, end2, nlist)) count++;\n      }\n      result += count;\n    }\n  }\n  *g_count = result;\n}\n\nstatic double CPUtc_edge(data_type* count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, edges, nindex, nlist, sp);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_vertex_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < nodes; v++) {\n    data_type count = 0;\n    const int beg1 = nindex[v];\n    const int end1 = nindex[v + 1];\n    int start1 = end1;\n    while ((beg1 < start1) && (v < nlist[start1 - 1])) start1--;\n    for (int j = start1; j < end1; j++) {\n      const int u = nlist[j];\n      const int beg2 = nindex[u];\n      const int end2 = nindex[u + 1];\n      int start2 = end2;\n      while ((beg2 < start2) && (u < nlist[start2 - 1])) start2--;\n      count += (data_type)common(j + 1, end1, start2, end2, nlist);\n    }\n    #pragma omp critical\n    (*g_count) += count;\n  }\n}\n\nstatic double CPUtc_vertex(data_type* count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, nodes, nindex, nlist);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_vertex_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < nodes; v++) {\n    data_type count = 0;\n    const int beg1 = nindex[v];\n    const int end1 = nindex[v + 1];\n    int start1 = end1;\n    while ((beg1 < start1) && (v < nlist[start1 - 1])) start1--;\n    for (int j = start1; j < end1; j++) {\n      const int u = nlist[j];\n      const int beg2 = nindex[u];\n      const int end2 = nindex[u + 1];\n      int start2 = end2;\n      while ((beg2 < start2) && (u < nlist[start2 - 1])) start2--;\n      count += (data_type)common(j + 1, end1, start2, end2, nlist);\n    }\n    #pragma omp critical\n    (*g_count) += count;\n  }\n}\n\nstatic double CPUtc_vertex(data_type* count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, nodes, nindex, nlist);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_vertex_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  data_type result = 0;\n  #pragma omp parallel for reduction(+: result) schedule(dynamic)\n  for (int v = 0; v < nodes; v++) {\n    data_type count = 0;\n    const int beg1 = nindex[v];\n    const int end1 = nindex[v + 1];\n    int start1 = end1;\n    while ((beg1 < start1) && (v < nlist[start1 - 1])) start1--;\n    for (int j = start1; j < end1; j++) {\n      const int u = nlist[j];\n      const int beg2 = nindex[u];\n      const int end2 = nindex[u + 1];\n      int start2 = end2;\n      while ((beg2 < start2) && (u < nlist[start2 - 1])) start2--;\n      count += (data_type)common(j + 1, end1, start2, end2, nlist);\n    }\n    result += count;\n  }\n  *g_count = result;\n}\n\nstatic double CPUtc_vertex(data_type* count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, nodes, nindex, nlist);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_vertex_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  data_type result = 0;\n  #pragma omp parallel for reduction(+: result)\n  for (int v = 0; v < nodes; v++) {\n    data_type count = 0;\n    const int beg1 = nindex[v];\n    const int end1 = nindex[v + 1];\n    int start1 = end1;\n    while ((beg1 < start1) && (v < nlist[start1 - 1])) start1--;\n    for (int j = start1; j < end1; j++) {\n      const int u = nlist[j];\n      const int beg2 = nindex[u];\n      const int end2 = nindex[u + 1];\n      int start2 = end2;\n      while ((beg2 < start2) && (u < nlist[start2 - 1])) start2--;\n      count += (data_type)common(j + 1, end1, start2, end2, nlist);\n    }\n    result += count;\n  }\n  *g_count = result;\n}\n\nstatic double CPUtc_vertex(data_type* count, const int nodes, const int* const nindex, const int* const nlist)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, nodes, nindex, nlist);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_edge_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  data_type result = 0;\n  #pragma omp parallel for reduction(+: result)\n  for (int e = 0; e < edges; e++) {\n    data_type count = 0;\n    const int src = sp[e];\n    const int dst = nlist[e];\n    if (src > dst) {\n      const int beg1 = nindex[dst];\n      const int end1 = nindex[dst + 1];\n      for (int i = beg1; i < end1 && nlist[i] < dst; i++) {\n        const int u = nlist[i];\n        int beg2 = nindex[src];\n        int end2 = nindex[src + 1];\n        if (find(u, beg2, end2, nlist)) count++;\n      }\n      result += count;\n    }\n  }\n  *g_count = result;\n}\n\nstatic double CPUtc_edge(data_type* count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, edges, nindex, nlist, sp);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_edge_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < edges; e++) {\n    data_type count = 0;\n    const int src = sp[e];\n    const int dst = nlist[e];\n    if (src > dst) {\n      const int beg1 = nindex[dst];\n      const int end1 = nindex[dst + 1];\n      for (int i = beg1; i < end1 && nlist[i] < dst; i++) {\n        const int u = nlist[i];\n        int beg2 = nindex[src];\n        int end2 = nindex[src + 1];\n        if (find(u, beg2, end2, nlist)) count++;\n      }\n      #pragma omp atomic\n      (*g_count) += count;\n    }\n  }\n}\n\nstatic double CPUtc_edge(data_type* count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, edges, nindex, nlist, sp);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_tc_edge_omp.h\"\n\nstatic void triCounting(data_type* g_count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < edges; e++) {\n    data_type count = 0;\n    const int src = sp[e];\n    const int dst = nlist[e];\n    if (src > dst) {\n      const int beg1 = nindex[dst];\n      const int end1 = nindex[dst + 1];\n      for (int i = beg1; i < end1 && nlist[i] < dst; i++) {\n        const int u = nlist[i];\n        int beg2 = nindex[src];\n        int end2 = nindex[src + 1];\n        if (find(u, beg2, end2, nlist)) count++;\n      }\n      #pragma omp atomic\n      (*g_count) += count;\n    }\n  }\n}\n\nstatic double CPUtc_edge(data_type* count, const int edges, const int* const nindex, const int* const nlist, const int* const sp)\n{\n  struct timeval start, end;\n  *count = 0;\n\n  gettimeofday(&start, NULL);\n\n  triCounting(count, edges, nindex, nlist, sp);\n\n  gettimeofday(&end, NULL);\n\n  return (end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0);\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n    bfs(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void bfs_vertex_data(ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n\n    if (updated) {\n      critical_min(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  // int* wl1 = new int [size];\n  // int* wl2 = new int [size];\n  // int* time = new int [g.nodes];\n  // int* wl1size;\n  // int* wl2size;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      const data_type d = atomicRead(&dist[dst]);\n      if (d > new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n    bfs(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        const data_type d = atomicRead(&dist[dst]);\n        if (d > new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n          update = true;\n        }\n      }\n      if (update) {\n        if (critical_max(&time[src], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = src;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[v];\n\n    if (s == iter) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s == iter) {\n        const data_type new_dist = s + 1;\n        if (new_dist < d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist[v], d);\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s == iter) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        const data_type d = atomicRead(&dist[dst]);\n        if (d > new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s == iter) {\n        const data_type new_dist = s + 1;\n        if (new_dist < d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist[v], d);\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      const data_type d = atomicRead(&dist[dst]);\n      if (d > new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n    bfs(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void bfs_vertex_data(ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = dist[v];\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = dist[src];\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n\n    if (updated) {\n      critical_min(&dist_n[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  // int* wl1 = new int [size];\n  // int* wl2 = new int [size];\n  // int* time = new int [g.nodes];\n  // int* wl1size;\n  // int* wl2size;\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(ECLgraph g, const int* const sp, data_type* const dist, data_type* const dist_n, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = dist[src];\n\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  data_type* dist_new = (data_type*) malloc(g.nodes * sizeof(data_type));\n  init(src, dist, dist_new, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n    bfs(g, sp, dist, dist_new, goagain);\n    SWAP(dist, dist_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\nstatic void bfs_edge_data(ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(sizeof(int) * size);\n  int* wl2 = (int*)malloc(sizeof(int) * size);\n  int* time = (int*)malloc(sizeof(int) * g.edges);\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\nstatic void bfs_edge_data(ECLgraph g, const int* const sp, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = dist[src];\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n    critical_min(&dist_n[src], s);\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  data_type* dist_new = (data_type*)malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(sizeof(int) * size);\n  int* wl2 = (int*)malloc(sizeof(int) * size);\n  int* time = (int*)malloc(sizeof(int) * g.edges);\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_edge_data(g, sp, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        const data_type d = atomicRead(&dist[dst]);\n        if (d > new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        const data_type d = atomicRead(&dist[dst]);\n        if (d > new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n          wl2[fetch_and_add(wl2size)] = dst;\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(ECLgraph g, const int* const sp, data_type* const dist, data_type* const dist_n, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = dist[src];\n\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  data_type* dist_new = (data_type*) malloc(g.nodes * sizeof(data_type));\n  init(src, dist, dist_new, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n    bfs(g, sp, dist, dist_new, goagain);\n    SWAP(dist, dist_new);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, const ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n        }\n      }\n      critical_min(&dist_n[src], s);\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  data_type* dist_new = (int*)malloc(g.nodes * sizeof(data_type));\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[v];\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\nstatic void bfs_edge_data(ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(sizeof(int) * size);\n  int* wl2 = (int*)malloc(sizeof(int) * size);\n  int* time = (int*)malloc(sizeof(int) * g.edges);\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[v];\n\n    if (s == iter) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[src]);\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      bool update = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        const data_type d = atomicRead(&dist[dst]);\n        if (d > new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n          update = true;\n        }\n      }\n      if (update) {\n        if (critical_max(&time[src], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = src;\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        if (new_dist < d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist[v], d);\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[v];\n\n    if (s != maxval) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v ++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    // read distance from source vertex\n    const data_type s = atomicRead(&dist[v]);\n\n    if (s == iter) {\n      bool updated = false;\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n        const data_type d = atomicRead(&dist[dst]);\n        if (d > new_dist) {\n          atomicWrite(&dist[dst], new_dist);\n          updated = true;\n        }\n      }\n      if (updated) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void bfs_vertex_data(ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = atomicRead(&dist[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      atomicWrite(&dist[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  // int* wl1 = new int [size];\n  // int* wl2 = new int [size];\n  // int* time = new int [g.nodes];\n  // int* wl1size;\n  // int* wl2size;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, data_type* const dist_n, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist_n[v] = temp;\n    dist[v] = temp;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\nstatic void bfs_edge_data(ECLgraph g, const int* const sp, data_type* const dist, data_type* const dist_n, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = dist[src];\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      if (critical_min(&dist_n[dst], new_dist) > new_dist) {\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n    critical_min(&dist_n[src], s);\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  data_type* dist_new = (data_type*)malloc(sizeof(data_type) * g.nodes);\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(sizeof(int) * size);\n  int* wl2 = (int*)malloc(sizeof(int) * size);\n  int* time = (int*)malloc(sizeof(int) * g.edges);\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  init(src, dist, dist_new, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_edge_data(g, sp, dist, dist_new, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    SWAP(dist, dist_new);\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(iter % 2 ? dist : dist_new);\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(ECLgraph g, const int* const sp, data_type* const dist, int* goagain)\n{\n  const int gsize = g.edges;\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < gsize; e++) {\n\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      if (critical_min(&dist[dst], new_dist) > new_dist) {\n        atomicWrite(goagain, 1);\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n    bfs(g, sp, dist, goagain);\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n  // initialize worklist\n  wl1[0] = src;\n  *wlsize = 1;\n}\n\nstatic void bfs_vertex_data(const ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int src = wl1[idx];\n    // read distance from source vertex\n    data_type s;\n    #pragma omp critical\n    s = dist[src];\n    const int beg = g.nindex[src];\n    const int end = g.nindex[src + 1];\n\n    if (s != maxval) {\n      for (int i = beg; i < end; i++) {\n        const int dst = g.nlist[i];\n        const data_type new_dist = s + 1;\n\n        if (critical_min(&dist[dst], new_dist) > new_dist) {\n          if (critical_max(&time[dst], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = dst;\n          }\n        }\n      }\n    }\n  }\n}\n//+BlankLine\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\nstatic void bfs_edge_data(ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      data_type d = atomicRead(&dist[dst]);\n      if (d > new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        if (critical_max(&time[e], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = e;\n        }\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(sizeof(int) * size);\n  int* wl2 = (int*)malloc(sizeof(int) * size);\n  int* time = (int*)malloc(sizeof(int) * g.edges);\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n    time[v] = 0;\n  }\n\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = g.nlist[i];\n    idx++;\n  }\n  *wlsize = idx;\n}\n\nstatic void bfs_vertex_data(ECLgraph g, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int v = wl1[idx];\n    data_type d = atomicRead(&dist[v]);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool updated = false;\n\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        if (d > new_dist) {\n          d = new_dist;\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      atomicWrite(&dist[v], d);\n      for (int j = beg; j < end; j++) {\n        const int n = g.nlist[j];\n        if (critical_max(&time[n], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = n;\n        }\n      }\n    }\n  }\n}\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(size * sizeof(int));\n  int* wl2 = (int*)malloc(size * sizeof(int));\n  int* time = (int*)malloc(g.nodes * sizeof(int));\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  // int* wl1 = new int [size];\n  // int* wl2 = new int [size];\n  // int* time = new int [g.nodes];\n  // int* wl1size;\n  // int* wl2size;\n\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_vertex_data(g, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_vertex_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size)\n{\n  // initialize arrays\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n}\n\nstatic void bfs(const int iter, ECLgraph g, data_type* const dist, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    data_type d = atomicRead(&dist[v]);\n    for (int i = beg; i < end; i++) {\n      const int src = g.nlist[i];\n      const data_type s = atomicRead(&dist[src]);\n      if (s != maxval) {\n        const data_type new_dist = s + 1;\n        if (new_dist < d) {\n          d = new_dist;\n          atomicWrite(goagain, 1);\n        }\n      }\n      atomicWrite(&dist[v], d);\n    }\n  }\n}\n\nstatic double CPUbfs_vertex(const int src, ECLgraph g, data_type* dist)\n{\n  init(src, dist, g.nodes);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    *goagain = 0;\n    bfs(iter, g, dist, goagain);\n    iter++;\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(goagain);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_bfs_edge_omp.h\"\n\nstatic void init(const int src, data_type* const dist, const int size, ECLgraph g, int* const wl1, int* wlsize, int* const time)\n{\n  // initialize dist array\n  for (int v = 0; v < size; v++) {\n    const data_type temp = (v == src) ? 0 : maxval;\n    dist[v] = temp;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    time[e] = 0;\n  }\n  // initialize worklist\n  int idx = 0;\n  for (int i = g.nindex[src]; i < g.nindex[src + 1]; i++) {\n    wl1[idx] = i;\n    idx++;\n  }\n  *wlsize = idx;\n}\nstatic void bfs_edge_data(ECLgraph g, const int* const sp, data_type* const dist, const int* const wl1, const int wl1size, int* const wl2, int* wl2size, const int iter, int* const time)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx ++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n    const data_type s = atomicRead(&dist[src]);\n    if (s != maxval) {\n      const data_type new_dist = s + 1;\n      data_type d = atomicRead(&dist[dst]);\n      if (d > new_dist) {\n        atomicWrite(&dist[dst], new_dist);\n        if (critical_max(&time[e], iter) != iter) {\n          wl2[fetch_and_add(wl2size)] = e;\n        }\n        for (int j = g.nindex[dst]; j < g.nindex[dst + 1]; j++) {\n          if (critical_max(&time[j], iter) != iter) {\n            wl2[fetch_and_add(wl2size)] = j;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUbfs_edge(const int src, ECLgraph g, data_type* dist, const int* const sp)\n{\n  const int size = MAX(g.edges, g.nodes);\n  int* wl1 = (int*)malloc(sizeof(int) * size);\n  int* wl2 = (int*)malloc(sizeof(int) * size);\n  int* time = (int*)malloc(sizeof(int) * g.edges);\n  int* wl1size = (int*)malloc(sizeof(int));\n  int* wl2size = (int*)malloc(sizeof(int));\n  init(src, dist, g.nodes, g, wl1, wl1size, time);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  // iterate until no more changes\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    bfs_edge_data(g, sp, dist, wl1, *wl1size, wl2, wl2size, iter, time);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(wl1);\n  free(wl2);\n  free(time);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_vertex_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv, int* const wl1, int* wlsize)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  *wlsize = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n\n    wl1[(*wlsize)++] = v;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  int curr = criticalRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    while (curr != (next = criticalRead(&parent[curr]))) {\n      criticalWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, int* const minv, int* const parent, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int v = wl1[idx];\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool inWL = false;\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if (!inWL) {\n            wl2[fetch_and_add(wl2size)] = v;\n            inWL = true;\n          }\n\n          int edx, upd;\n          #pragma omp critical\n          upd = minv[arep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n          #pragma omp critical\n          upd = minv[brep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n        }\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, bool* const included, int* const minv, int* const parent, const int* const wl1, const int wl1size)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int v = wl1[idx];\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if ((e == minv[arep]) || (e == minv[brep])) {\n            // if this was the best edge found for the set\n            join(arep, brep, parent);\n            included[e] = true;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(g, eweight, included, parent, minv, wl1, wl1size);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mst_first(g, eweight, minv, parent, wl1, *wl1size, wl2, wl2size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    if (*wl1size > 0) {\n      mst_second(g, included, minv, parent, wl1, *wl1size);\n\n      // std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_edge_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  int curr = criticalRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    while (curr != (next = criticalRead(&parent[curr]))) {\n      criticalWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, const int* const sp, int* const minv, int* const parent, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    if (dst > src) {\n      const int arep = findRep(src, parent);\n      const int brep = findRep(dst, parent);\n      if (arep != brep) {\n        atomicWrite(goagain, 1);\n\n        int edx, upd;\n        #pragma omp critical\n        upd = minv[arep];\n        do {\n          edx = upd;\n          const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n          if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n        } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n        #pragma omp critical\n        upd = minv[brep];\n        do {\n          edx = upd;\n          const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n          if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n        } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, const int* const sp, bool* const included, int* const minv, int* const parent)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int e = 0; e < g.edges; e++) {\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    if (dst > src) {\n      const int arep = findRep(src, parent);\n      const int brep = findRep(dst, parent);\n      if (arep != brep) {\n        if ((e == minv[arep]) || (e == minv[brep])) {\n          // if this was the best edge found for the set\n          join(arep, brep, parent);\n          included[e] = true;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, const int* const sp, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n\n  init(g, eweight, included, parent, minv);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mst_first(g, eweight, sp, minv, parent, goagain);\n\n    if (*goagain) {\n      mst_second(g, sp, included, minv, parent);\n\n      //std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int i = 0; i < g.nodes; i++) minv[i] = INT_MAX;\n    }\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_edge_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv, int* const wl1, int* wlsize)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  *wlsize = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n      // only in one direction\n      if (n > v) {\n        wl1[(*wlsize)++] = e;\n      }\n    }\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  int curr = criticalRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    while (curr != (next = criticalRead(&parent[curr]))) {\n      criticalWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, const int* const sp, int* const minv, int* const parent, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    const int arep = findRep(src, parent);\n    const int brep = findRep(dst, parent);\n    if (arep != brep) {\n      wl2[fetch_and_add(wl2size)] = e;\n\n      int edx, upd;\n      #pragma omp critical\n      upd = minv[arep];\n      do {\n        edx = upd;\n        const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n        if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n      } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n      #pragma omp critical\n      upd = minv[brep];\n      do {\n        edx = upd;\n        const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n        if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n      } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, const int* const sp, bool* const included, int* const minv, int* const parent, const int* const wl1, const int wl1size)\n{\n  #pragma omp parallel for\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    const int arep = findRep(src, parent);\n    const int brep = findRep(dst, parent);\n    if (arep != brep) {\n      if ((e == minv[arep]) || (e == minv[brep])) {\n        // if this was the best edge found for the set\n        join(arep, brep, parent);\n        included[e] = true;\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, const int* const sp, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n  int* wl1 = malloc(sizeof(int) * (g.edges / 2));\n  int* wl2 = malloc(sizeof(int) * (g.edges / 2));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(g, eweight, included, parent, minv, wl1, wl1size);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mst_first(g, eweight, sp, minv, parent, wl1, *wl1size, wl2, wl2size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    if (*wl1size > 0) {\n      mst_second(g, sp, included, minv, parent, wl1, *wl1size);\n\n      // std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_edge_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  int curr = criticalRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    while (curr != (next = criticalRead(&parent[curr]))) {\n      criticalWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, const int* const sp, int* const minv, int* const parent, int* goagain)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    if (dst > src) {\n      const int arep = findRep(src, parent);\n      const int brep = findRep(dst, parent);\n      if (arep != brep) {\n        atomicWrite(goagain, 1);\n\n        int edx, upd;\n        #pragma omp critical\n        upd = minv[arep];\n        do {\n          edx = upd;\n          const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n          if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n        } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n        #pragma omp critical\n        upd = minv[brep];\n        do {\n          edx = upd;\n          const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n          if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n        } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, const int* const sp, bool* const included, int* const minv, int* const parent)\n{\n  #pragma omp parallel for\n  for (int e = 0; e < g.edges; e++) {\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    if (dst > src) {\n      const int arep = findRep(src, parent);\n      const int brep = findRep(dst, parent);\n      if (arep != brep) {\n        if ((e == minv[arep]) || (e == minv[brep])) {\n          // if this was the best edge found for the set\n          join(arep, brep, parent);\n          included[e] = true;\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, const int* const sp, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n\n  init(g, eweight, included, parent, minv);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mst_first(g, eweight, sp, minv, parent, goagain);\n\n    if (*goagain) {\n      mst_second(g, sp, included, minv, parent);\n\n      //std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int i = 0; i < g.nodes; i++) minv[i] = INT_MAX;\n    }\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_edge_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv, int* const wl1, int* wlsize)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  *wlsize = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n      // only in one direction\n      if (n > v) {\n        wl1[(*wlsize)++] = e;\n      }\n    }\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  int curr = criticalRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    while (curr != (next = criticalRead(&parent[curr]))) {\n      criticalWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, const int* const sp, int* const minv, int* const parent, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    const int arep = findRep(src, parent);\n    const int brep = findRep(dst, parent);\n    if (arep != brep) {\n      wl2[fetch_and_add(wl2size)] = e;\n\n      int edx, upd;\n      #pragma omp critical\n      upd = minv[arep];\n      do {\n        edx = upd;\n        const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n        if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n      } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n      #pragma omp critical\n      upd = minv[brep];\n      do {\n        edx = upd;\n        const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n        if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n      } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, const int* const sp, bool* const included, int* const minv, int* const parent, const int* const wl1, const int wl1size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int e = wl1[idx];\n    const int src = sp[e];\n    const int dst = g.nlist[e];\n\n    const int arep = findRep(src, parent);\n    const int brep = findRep(dst, parent);\n    if (arep != brep) {\n      if ((e == minv[arep]) || (e == minv[brep])) {\n        // if this was the best edge found for the set\n        join(arep, brep, parent);\n        included[e] = true;\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, const int* const sp, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n  int* wl1 = malloc(sizeof(int) * (g.edges / 2));\n  int* wl2 = malloc(sizeof(int) * (g.edges / 2));\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(g, eweight, included, parent, minv, wl1, wl1size);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mst_first(g, eweight, sp, minv, parent, wl1, *wl1size, wl2, wl2size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    if (*wl1size > 0) {\n      mst_second(g, sp, included, minv, parent, wl1, *wl1size);\n\n      // std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  free(wl1);\n  free(wl2);\n  free(wl1size);\n  free(wl2size);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_vertex_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv, int* const wl1, int* wlsize)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  *wlsize = 0;\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n\n    wl1[(*wlsize)++] = v;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  int curr = criticalRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    while (curr != (next = criticalRead(&parent[curr]))) {\n      criticalWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, int* const minv, int* const parent, const int* const wl1, const int wl1size, int* const wl2, int* wl2size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int v = wl1[idx];\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    bool inWL = false;\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if (!inWL) {\n            wl2[fetch_and_add(wl2size)] = v;\n            inWL = true;\n          }\n\n          int edx, upd;\n          #pragma omp critical\n          upd = minv[arep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n          #pragma omp critical\n          upd = minv[brep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n        }\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, bool* const included, int* const minv, int* const parent, const int* const wl1, const int wl1size)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int idx = 0; idx < wl1size; idx++) {\n    const int v = wl1[idx];\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if ((e == minv[arep]) || (e == minv[brep])) {\n            // if this was the best edge found for the set\n            join(arep, brep, parent);\n            included[e] = true;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n  int* wl1 = malloc(sizeof(int) * g.nodes);\n  int* wl2 = malloc(sizeof(int) * g.nodes);\n  int* wl1size = malloc(sizeof(int));\n  int* wl2size = malloc(sizeof(int));\n\n  init(g, eweight, included, parent, minv, wl1, wl1size);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int iter = 0;\n  do {\n    iter++;\n    *wl2size = 0;\n\n    mst_first(g, eweight, minv, parent, wl1, *wl1size, wl2, wl2size);\n\n    SWAP(wl1, wl2);\n    *wl1size = *wl2size;\n    if (*wl1size > 0) {\n      mst_second(g, included, minv, parent, wl1, *wl1size);\n\n      // std::fill(minv, minv + g.nodes, INT_MAX);\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*wl1size > 0);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  free(wl1);\n  free(wl2);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_vertex_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  int curr = criticalRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    while (curr != (next = criticalRead(&parent[curr]))) {\n      criticalWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, int* const minv, int* const parent, int* goagain)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          atomicWrite(goagain, 1);\n\n          int edx, upd;\n          #pragma omp critical\n          upd = minv[arep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n          #pragma omp critical\n          upd = minv[brep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n        }\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, bool* const included, int* const minv, int* const parent)\n{\n  #pragma omp parallel for schedule(dynamic)\n  for (int v = 0; v < g.nodes; v++) {\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if ((e == minv[arep]) || (e == minv[brep])) {\n            // if this was the best edge found for the set\n            join(arep, brep, parent);\n            included[e] = true;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n\n  init(g, eweight, included, parent, minv);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mst_first(g, eweight, minv, parent, goagain);\n\n    if (*goagain) {\n      mst_second(g, included, minv, parent);\n\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  return runtime;\n}\n"}, {"prompt": "typedef int data_type;\n#include \"indigo_mst_vertex_omp.h\"\n\nstatic void init(const ECLgraph g, data_type* const eweight, bool* const included, int* const parent, int* const minv)\n{\n  // std::fill(included, included + g.edges, false);\n  for (int e = 0; e < g.edges; e++) {\n    included[e] = false;\n  }\n  for (int v = 0; v < g.nodes; v++) {\n    //initially, each vertex is its own parent\n    parent[v] = v;\n    minv[v] = INT_MAX;\n  }\n  for (int e = 0; e < g.edges; e++) {\n    eweight[e] = g.eweight[e];\n  }\n}\n\nstatic int findRep(int idx, int* const parent)\n{\n  int curr = criticalRead(&parent[idx]);\n  if (curr != idx) {\n    int next, prev = idx;\n    while (curr != (next = criticalRead(&parent[curr]))) {\n      criticalWrite(&parent[prev], next);\n      prev = curr;\n      curr = next;\n    }\n  }\n  return curr;\n}\n\nstatic void join(int arep, int brep, int* const parent)\n{\n  int mrep;\n  do {\n    mrep = MAX(arep, brep);\n    arep = MIN(arep, brep);\n  } while ((brep = critical_CAS(&parent[mrep], mrep, arep)) != mrep);\n}\n\nstatic void mst_first(const ECLgraph g, data_type* const eweight, int* const minv, int* const parent, int* goagain)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          atomicWrite(goagain, 1);\n\n          int edx, upd;\n          #pragma omp critical\n          upd = minv[arep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[arep], edx, e)) != edx);\n\n          #pragma omp critical\n          upd = minv[brep];\n          do {\n            edx = upd;\n            const data_type wei = (edx == INT_MAX) ? maxval : eweight[edx];\n            if ((eweight[e] > wei) || ((eweight[e] == wei) && (e >= edx))) break;\n          } while ((upd = critical_CAS(&minv[brep], edx, e)) != edx);\n        }\n      }\n    }\n  }\n}\n\nstatic void mst_second(const ECLgraph g, bool* const included, int* const minv, int* const parent)\n{\n  #pragma omp parallel for\n  for (int v = 0; v < g.nodes; v++) {\n    const int arep = findRep(v, parent);\n    const int beg = g.nindex[v];\n    const int end = g.nindex[v + 1];\n    for (int e = beg; e < end; e++) {\n      const int n = g.nlist[e];\n\n      if (n > v) {\n        const int brep = findRep(n, parent);\n        if (arep != brep) {\n          if ((e == minv[arep]) || (e == minv[brep])) {\n            // if this was the best edge found for the set\n            join(arep, brep, parent);\n            included[e] = true;\n          }\n        }\n      }\n    }\n  }\n}\n\nstatic double CPUmst(const ECLgraph g, bool* const included)\n{\n  int* parent = malloc(sizeof(int) * g.nodes);\n  int* minv = malloc(sizeof(int) * g.nodes);\n  data_type* eweight = malloc(sizeof(data_type) * g.edges);\n\n  init(g, eweight, included, parent, minv);\n\n  struct timeval start, end;\n  gettimeofday(&start, NULL);\n\n  int* goagain = malloc(sizeof(int));\n  int iter = 0;\n  do {\n    iter++;\n    *goagain = 0;\n\n    mst_first(g, eweight, minv, parent, goagain);\n\n    if (*goagain) {\n      mst_second(g, included, minv, parent);\n\n      for (int v = 0; v < g.nodes; v++) {\n        minv[v] = INT_MAX;\n      }\n    }\n  } while (*goagain);\n\n  gettimeofday(&end, NULL);\n  double runtime = end.tv_sec + end.tv_usec / 1000000.0 - start.tv_sec - start.tv_usec / 1000000.0;\n  printf(\"iterations: %d\\n\", iter);\n\n  free(parent);\n  free(minv);\n  free(eweight);\n  return runtime;\n}\n"}]