[{"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define N 10000\n#define C 512\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n    for(int j=0; j<N; j++){\n        \n        #pragma omp critical(addlock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        \n        #pragma omp critical(sublock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i] -= 2;\n        }\n        \n        \n    }\n    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!= -N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){    \n    init();\n    count();\n    check();\n    return 0;\n}", "targets": {"31": "    #pragma omp distribute parallel for\n", "32": "    for(int j=0; j<N; j++){\n", "34": "        #pragma omp critical(addlock)\n", "36": "        for(int i=0; i<C; i++){\n", "35": "        #pragma omp simd\n", "37": "            countervar[i]++;\n", "38": "        }\n", "40": "        #pragma omp critical(sublock)\n", "42": "        for(int i=0; i<C; i++){\n", "41": "        #pragma omp simd\n", "43": "            countervar[i] -= 2;\n", "44": "        }\n", "47": "    }\n"}}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=0; i<N; i++){\n\t\t\t#pragma omp atomic update\n            countervar++;\n        }\n    return 0;\n}\n\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}", "targets": {"13": "        for (int i=0; i<N; i++){\n", "12": "    #pragma omp teams distribute parallel for\n", "16": "        }\n", "15": "            countervar++;\n"}}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}", "targets": {"14": "        for (int i=0; i<N; i++){\n", "13": "    #pragma omp teams distribute parallel for\n", "16": "        }\n", "15": "            countervar++;\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams distribute\n        for (int i=1; i<N; i++){\n            countervar[i]=countervar[i-1]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<N; i++){\n        if(countervar[i]!=i){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}", "targets": {"22": "        for (int i=1; i<N; i++){\n", "23": "            countervar[i]=countervar[i-1]+1;\n", "24": "        }\n", "21": "    #pragma omp teams distribute\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define C 4096\n\n\nfloat a;\nfloat x[C];\nfloat y[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        a=5;\n        x[i]=0;\n        y[i]=3;\n    }\n        return 0;\n}\n\n\nint saxpy(){\n    \n    float res;\n    #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) nowait device(0)\n    {\n        for(int i=0; i<C; i++){\n            #pragma omp task depend(inout:x[i])\n            {\n                x[i] = a * x[i];                \n            }\n            #pragma omp task depend(inout:x[i])\n            {\n                x[i] = x[i] + y[i];\n            }\n            res = x[i] + 1;\n        }\n    }        \n    \n    return res;\n}\n\nint main(){\n    init();\n    saxpy();\n\t#pragma omp taskwait\n    return 0;\n}", "targets": {"33": "            #pragma omp task depend(inout:x[i])\n", "34": "            {\n", "35": "                x[i] = a * x[i];                \n", "37": "            #pragma omp task depend(inout:x[i])\n", "38": "            {\n", "39": "                x[i] = x[i] + y[i];\n", "30": "    #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) nowait device(0)\n", "31": "    {\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 512\n\n\nint *a;\nint *b;\nint *c;\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        for(int j=0; j<C; j++){\n            b[j+i*C]=1;\n        }\n        a[i]=1;\n        c[i]=0;\n    }\n        return 0;\n}\n\n\nint Mult(){\n    #pragma omp parallel sections num_threads(2)\n    {\n        #pragma omp target map(to:a[0:C],b[0:C*C]) map(from:c[0:C]) device(0)\n            {\n                #pragma omp teams distribute parallel for\n                for(int i=0; i<C; i++){\n                    for(int j=0; j<C; j++){\n                        c[i]+=b[j+i*C]*a[j];\n                    }\n                }\n            }\n        #pragma omp section\n        #pragma omp parallel num_threads(4)\n            #pragma omp for\n            for(int i=C; i>0; i--){\n                a[i]=3;    \n                #pragma omp target update to(a[i]) device(0)\n            }    \n    }\n    return 0;\n}\n\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(c[i]!=C){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    a = malloc(C*sizeof(int));\n    b = malloc(C*C*sizeof(int));\n    c = malloc(C*sizeof(int));\n    init();\n    omp_set_nested(1);\n    Mult();\n    check();\n    free(a);\n    free(b);\n    free(c);\n    return 0;\n}", "targets": {"32": "    {\n", "31": "    #pragma omp parallel sections num_threads(2)\n", "33": "        #pragma omp target map(to:a[0:C],b[0:C*C]) map(from:c[0:C]) device(0)\n", "43": "        #pragma omp parallel num_threads(4)\n", "42": "        #pragma omp section\n", "49": "    }\n", "36": "                for(int i=0; i<C; i++){\n", "35": "                #pragma omp teams distribute parallel for\n", "40": "                }\n", "37": "                    for(int j=0; j<C; j++){\n", "38": "                        c[i]+=b[j+i*C]*a[j];\n", "39": "                    }\n", "45": "            for(int i=C; i>0; i--){\n", "44": "            #pragma omp for\n", "46": "                a[i]=3;    \n", "48": "            }    \n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 100\n#define C 512\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint init(){\n    for(int i=0; i<C; i++){\n        b[i]=0;\n        c[i]=2;\n        temp[i]=0;\n    }\n    a=2;\n    return 0;\n}\n\n\nint add_Mult(){\n#pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n    {\n        #pragma omp teams \n        for(int i =0; i<N; i++){\n        #pragma omp distribute simd\n        {\n            for(int i=0; i<C; i++){\n                temp[i] = b[i] + c[i];\n            }    \n        }\n        #pragma omp distribute simd\n        {\n            for(int i=C; i>0; i--){\n                b[i] = temp[i] * a;\n            }    \n            \n        }\n        }\n    }    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    int val = 0;\n    for(int i=0; i<N; i++){\n        val = val + 2;\n        val = val * 2;\n    }\n    for(int i=0; i<C; i++){\n        if(b[i]!=val){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    add_Mult();\n    check();\n    return 0;\n}", "targets": {"35": "        for(int i =0; i<N; i++){\n", "38": "            for(int i=0; i<C; i++){\n", "36": "        #pragma omp distribute simd\n", "37": "        {\n", "39": "                temp[i] = b[i] + c[i];\n", "40": "            }    \n", "44": "            for(int i=C; i>0; i--){\n", "42": "        #pragma omp distribute simd\n", "43": "        {\n", "45": "                b[i] = temp[i] * a;\n", "46": "            }    \n", "49": "        }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 100\n#define C 512\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint init(){\n    for(int i=0; i<C; i++){\n        b[i]=0;\n        c[i]=2;\n        temp[i]=0;\n    }\n    a=2;\n    return 0;\n}\n\n\nint add_Mult(){\n#pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n#pragma omp parallel\n    {\n        for(int i=0; i<N; i++){\n        #pragma omp for nowait\n            for(int i=0; i<C; i++){\n                temp[i] = b[i] + c[i];\n            }    \n        \n        #pragma omp for nowait\n            for(int i=C; i>0; i--){\n                b[i] = temp[i] * a;\n            }    \n        }    \n    }    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    int val = 0;\n    for(int i=0; i<N; i++){\n        val = val + 2;\n        val = val * 2;\n    }\n    for(int i=0; i<C; i++){\n        if(b[i]!=val){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    add_Mult();\n    check();\n    return 0;\n}", "targets": {"32": "    {\n", "33": "        for(int i=0; i<N; i++){\n", "35": "            for(int i=0; i<C; i++){\n", "34": "        #pragma omp for nowait\n", "36": "                temp[i] = b[i] + c[i];\n", "37": "            }    \n", "40": "            for(int i=C; i>0; i--){\n", "39": "        #pragma omp for nowait\n", "41": "                b[i] = temp[i] * a;\n", "42": "            }    \n", "43": "        }    \n", "44": "    }    \n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=1; i<N; i++){\n            countervar[i]=countervar[i-1]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<N; i++){\n        if(countervar[i]!=i){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}", "targets": {"22": "    #pragma omp distribute parallel for\n", "23": "        for (int i=1; i<N; i++){\n", "24": "            countervar[i]=countervar[i-1]+1;\n", "25": "        }\n"}}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n\t#pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n\t\t\t#pragma omp atomic update\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}", "targets": {"13": "    #pragma omp distribute parallel for\n", "14": "        for (int i=0; i<N; i++){\n", "16": "            countervar++;\n", "17": "        }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100000\n\nint countervar = 0;\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n    for(int i=0; i<N; i++){\n        \n        #pragma omp critical(addlock)\n        countervar++;\n        \n        \n        #pragma omp critical(sublock)\n        countervar -= 2;\n        \n        \n    }\n    \n    return 0;\n}\n\nint main(){\n    \n\n    count();\n    printf(\"counter: %i expected: -%i\\n\",countervar,N);\n    \n    return countervar;\n}", "targets": {"21": "    #pragma omp distribute parallel for\n", "22": "    for(int i=0; i<N; i++){\n", "24": "        #pragma omp critical(addlock)\n", "25": "        countervar++;\n", "28": "        #pragma omp critical(sublock)\n", "29": "        countervar -= 2;\n", "32": "    }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n#define C 16\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams distribute simd safelen(C)\n        for (int i=C; i<N; i++){\n            countervar[i]=countervar[i-C]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=C; i<N; i++){\n        if(countervar[i]!=i-C+1){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}", "targets": {"23": "        for (int i=C; i<N; i++){\n", "24": "            countervar[i]=countervar[i-C]+1;\n", "25": "        }\n", "22": "    #pragma omp teams distribute simd safelen(C)\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n#define C 16\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for simd safelen(C)\n        for (int i=C; i<N; i++){\n            countervar[i]=countervar[i-C]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=C; i<N; i++){\n        if(countervar[i]!=i-C+1){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}", "targets": {"23": "    #pragma omp distribute parallel for simd safelen(C)\n", "24": "        for (int i=C; i<N; i++){\n", "25": "            countervar[i]=countervar[i-C]+1;\n", "26": "        }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n#define C 16\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams distribute parallel for simd safelen(C)\n        for (int i=C; i<N; i++){\n            countervar[i]=countervar[i-C]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=C; i<N; i++){\n        if(countervar[i]!=i-C+1){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}", "targets": {"23": "        for (int i=C; i<N; i++){\n", "22": "    #pragma omp teams distribute parallel for simd safelen(C)\n", "25": "        }\n", "24": "            countervar[i]=countervar[i-C]+1;\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100000\n\nint countervar = 0;\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute\n    for(int i=0; i<N; i++){\n        \n        #pragma omp critical(addlock)\n        countervar++;\n        \n        \n        #pragma omp critical(sublock)\n        countervar -= 2;\n        \n        \n    }\n    \n    return 0;\n}\n\nint main(){\n    \n\n    count();\n    \n    printf(\"counter: %i expected: -%i\\n\",countervar,N);\n    return countervar;\n}", "targets": {"19": "    for(int i=0; i<N; i++){\n", "21": "        #pragma omp critical(addlock)\n", "22": "        countervar++;\n", "25": "        #pragma omp critical(sublock)\n", "26": "        countervar -= 2;\n", "29": "    }\n", "18": "    #pragma omp teams distribute\n"}}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}", "targets": {"14": "    #pragma omp distribute parallel for\n", "15": "        for (int i=0; i<N; i++){\n", "16": "            countervar++;\n", "17": "        }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint countervar = 0;\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams\n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n\n    #pragma omp distribute parallel for\n    for(int i=0; i<N; i++){\n        \n        omp_set_lock(&addlock);\n        countervar++;\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        countervar -= 2;\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint main(){\n    \n    \n    \n    count();\n    printf(\"counter: %i expected: -%i\\n \",countervar,N);\n    \n    return 0;\n}", "targets": {"22": "    {\n", "23": "    omp_init_lock(&addlock);\n", "24": "    omp_init_lock(&sublock);\n", "27": "    for(int i=0; i<N; i++){\n", "26": "    #pragma omp distribute parallel for\n", "37": "    omp_destroy_lock(&addlock);\n", "38": "    omp_destroy_lock(&sublock);\n", "39": "    }\n", "29": "        omp_set_lock(&addlock);\n", "30": "        countervar++;\n", "31": "        omp_unset_lock(&addlock);\n", "32": "        omp_set_lock(&sublock);\n", "33": "        countervar -= 2;\n", "34": "        omp_unset_lock(&sublock);\n", "36": "    }\n"}}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=0; i<N*2; i++){\n            if(countervar<N){\n                #pragma omp atomic\n                countervar++;\n            }\n        }\n    return 0;\n}\n\n\nint main(){\n    count();\n    printf(\"counter: %i expected: %i\\n \",countervar,N);\n    return 0;\n}", "targets": {"15": "        for (int i=0; i<N*2; i++){\n", "14": "    #pragma omp teams distribute parallel for\n", "20": "        }\n", "16": "            if(countervar<N){\n", "18": "                countervar++;\n", "19": "            }\n"}}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}", "targets": {"14": "        for (int i=0; i<N; i++){\n", "15": "            countervar++;\n", "16": "        }\n", "13": "    #pragma omp teams distribute\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100000\n\nint countervar = 0;\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for\n    for(int i=0; i<N; i++){\n        \n        #pragma omp critical(addlock)\n        countervar++;\n        \n        \n        #pragma omp critical(sublock)\n        countervar -= 2;\n        \n        \n    }\n    \n    return 0;\n}\n\nint main(){\n    \n\n    count();\n    printf(\"counter: %i expected: -%i\\n\",countervar,N);\n    \n    return countervar;\n}", "targets": {"19": "    for(int i=0; i<N; i++){\n", "18": "    #pragma omp teams distribute parallel for\n", "29": "    }\n", "21": "        #pragma omp critical(addlock)\n", "22": "        countervar++;\n", "25": "        #pragma omp critical(sublock)\n", "26": "        countervar -= 2;\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint countervar = 0;\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\n\n\nint count(){\n    printf(\"start \\n\");\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams num_teams(1)\n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n    #pragma omp distribute parallel for\n    for(int i=0; i<N; i++){\n        \n        omp_set_lock(&addlock);\n        countervar++;\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        countervar -= 2;\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint main(){\n    \n    \n    \n    count();\n    printf(\"counter: %i expected: -%i\\n \",countervar,N);\n    \n    return 0;\n}", "targets": {"24": "    {\n", "25": "    omp_init_lock(&addlock);\n", "26": "    omp_init_lock(&sublock);\n", "28": "    for(int i=0; i<N; i++){\n", "27": "    #pragma omp distribute parallel for\n", "38": "    omp_destroy_lock(&addlock);\n", "39": "    omp_destroy_lock(&sublock);\n", "40": "    }\n", "30": "        omp_set_lock(&addlock);\n", "31": "        countervar++;\n", "32": "        omp_unset_lock(&addlock);\n", "33": "        omp_set_lock(&sublock);\n", "34": "        countervar -= 2;\n", "35": "        omp_unset_lock(&sublock);\n", "37": "    }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n#define N 100\n#define C 512\n\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams \n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n    #pragma omp distribute\n    for(int j=0; j<N; j++){\n        \n        omp_set_lock(&addlock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]-=2;\n        }\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=-N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    \n    init();\n    \n    \n    \n    count();\n    check();\n    \n    return 0;\n}", "targets": {"30": "    {\n", "31": "    omp_init_lock(&addlock);\n", "32": "    omp_init_lock(&sublock);\n", "34": "    for(int j=0; j<N; j++){\n", "33": "    #pragma omp distribute\n", "36": "        omp_set_lock(&addlock);\n", "38": "        for(int i=0; i<C; i++){\n", "37": "        #pragma omp simd\n", "39": "            countervar[i]++;\n", "40": "        }\n", "41": "        omp_unset_lock(&addlock);\n", "42": "        omp_set_lock(&sublock);\n", "44": "        for(int i=0; i<C; i++){\n", "43": "        #pragma omp simd\n", "45": "            countervar[i]-=2;\n", "46": "        }\n", "47": "        omp_unset_lock(&sublock);\n", "49": "    }\n", "50": "    omp_destroy_lock(&addlock);\n", "51": "    omp_destroy_lock(&sublock);\n", "52": "    }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 64\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=0; i<N; i++){\n            #pragma omp simd\n            for(int i=0; i<C; i++){\n                countervar[i]++;\n            }\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=100000){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}", "targets": {"25": "        for (int i=0; i<N; i++){\n", "24": "    #pragma omp teams distribute parallel for\n", "30": "        }\n", "27": "            for(int i=0; i<C; i++){\n", "26": "            #pragma omp simd\n", "28": "                countervar[i]++;\n", "29": "            }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 64\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams distribute\n        for (int i=0; i<N; i++){\n            #pragma omp simd\n            for(int i=0; i<C; i++){\n                countervar[i]++;\n            }\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=100000){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}", "targets": {"25": "        for (int i=0; i<N; i++){\n", "27": "            for(int i=0; i<C; i++){\n", "26": "            #pragma omp simd\n", "28": "                countervar[i]++;\n", "29": "            }\n", "30": "        }\n", "24": "    #pragma omp teams distribute\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 64\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n            #pragma omp simd\n            for(int i=0; i<C; i++){\n                countervar[i]++;\n            }\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=100000){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}", "targets": {"25": "    #pragma omp distribute parallel for\n", "26": "        for (int i=0; i<N; i++){\n", "28": "            for(int i=0; i<C; i++){\n", "27": "            #pragma omp simd\n", "29": "                countervar[i]++;\n", "30": "            }\n", "31": "        }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint countervar = 0;\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams \n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n    #pragma omp distribute\n    for(int i=0; i<N; i++){\n        \n        omp_set_lock(&addlock);\n        countervar++;\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        countervar -= 2;\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint main(){\n    \n    \n    \n    count();\n    printf(\"counter: %i expected: -%i\\n \",countervar,N);\n    \n    return 0;\n}", "targets": {"22": "    {\n", "23": "    omp_init_lock(&addlock);\n", "24": "    omp_init_lock(&sublock);\n", "26": "    for(int i=0; i<N; i++){\n", "25": "    #pragma omp distribute\n", "28": "        omp_set_lock(&addlock);\n", "29": "        countervar++;\n", "30": "        omp_unset_lock(&addlock);\n", "31": "        omp_set_lock(&sublock);\n", "32": "        countervar -= 2;\n", "33": "        omp_unset_lock(&sublock);\n", "35": "    }\n", "36": "    omp_destroy_lock(&addlock);\n", "37": "    omp_destroy_lock(&sublock);\n", "38": "    }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n#define N 100\n#define C 512\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams num_teams(1)\n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);\n    #pragma omp distribute parallel for\n    for(int j=0; j<N; j++){\n        \n        omp_set_lock(&addlock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]-=2;\n        }\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=-N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    \n    init();\n    \n    \n    \n    count();\n    check();\n    \n    return 0;\n}", "targets": {"30": "    {\n", "31": "    omp_init_lock(&addlock);\n", "32": "    omp_init_lock(&sublock);\n", "34": "    for(int j=0; j<N; j++){\n", "33": "    #pragma omp distribute parallel for\n", "50": "    omp_destroy_lock(&addlock);\n", "51": "    omp_destroy_lock(&sublock);\n", "52": "    }\n", "36": "        omp_set_lock(&addlock);\n", "38": "        for(int i=0; i<C; i++){\n", "37": "        #pragma omp simd\n", "39": "            countervar[i]++;\n", "40": "        }\n", "41": "        omp_unset_lock(&addlock);\n", "42": "        omp_set_lock(&sublock);\n", "44": "        for(int i=0; i<C; i++){\n", "43": "        #pragma omp simd\n", "45": "            countervar[i]-=2;\n", "46": "        }\n", "47": "        omp_unset_lock(&sublock);\n", "49": "    }\n"}}, {"prompt": "#include <stdio.h>   \n#include <stdlib.h> \n#include <stdbool.h>\n#include <stdint.h>\n#define C 51200L\n\n\nint64_t *a;\nint64_t *b;\nint64_t *c;\n\n\nint init(){\n    for(int64_t i=0; i<C; i++){\n        for(int64_t j=0; j<C; j++){\n            a[j+i*C]=1;\n            b[j+i*C]=1;\n            c[j+i*C]=0;\n        }\n        \n    }\n        return 0;\n}\n\n\nint add(){\n    #pragma omp target map(to:a[0:C*C],b[0:C*C]) map(from:c[0:C*C]) device(0)\n    {\n        // #pragma omp teams\n        // printf(\"Executed on host: %s\\n\",omp_is_initial_device() ? \"true\" : \"false\");\n        #pragma omp teams distribute parallel for collapse(2)\n        for(int64_t i=0; i<C; i++){\n            for(int64_t j=0; j<C; j++){\n                c[j+i*C]=b[j+i*C] + a[j+i*C];\n            }\n        }\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int64_t i=0; i<C*C; i++){\n        if(c[i]!=2){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    a = (int64_t *) malloc(C*C*sizeof(int64_t));\n    b = (int64_t *) malloc(C*C*sizeof(int64_t));\n    c = (int64_t *) malloc(C*C*sizeof(int64_t));\n    init();\n    add();\n    check();\n    free(a);\n    free(b);\n    free(c);\n    return 0;\n}", "targets": {"36": "        for(int64_t i=0; i<C; i++){\n", "35": "        #pragma omp teams distribute parallel for collapse(2)\n", "40": "        }\n", "37": "            for(int64_t j=0; j<C; j++){\n", "38": "                c[j+i*C]=b[j+i*C] + a[j+i*C];\n", "39": "            }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 64\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams num_teams(1) thread_limit(1048)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n            #pragma omp simd\n            for(int i=0; i<C; i++){\n                countervar[i]++;\n            }\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}", "targets": {"26": "    #pragma omp distribute parallel for\n", "27": "        for (int i=0; i<N; i++){\n", "29": "            for(int i=0; i<C; i++){\n", "28": "            #pragma omp simd\n", "30": "                countervar[i]++;\n", "31": "            }\n", "32": "        }\n"}}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute parallel for reduction(+:countervar)\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}", "targets": {"13": "        for (int i=0; i<N; i++){\n", "12": "    #pragma omp teams distribute parallel for reduction(+:countervar)\n", "15": "        }\n", "14": "            countervar++;\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#define N 100000\n#define C 512\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams distribute\n    for(int j=0; j<N; j++){\n        \n        #pragma omp critical(addlock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        \n        #pragma omp critical(sublock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i] -= 2;\n        }\n        \n        \n    }\n    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!= -N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){    \n    init();\n    count();\n    check();\n    return 0;\n}", "targets": {"29": "    for(int j=0; j<N; j++){\n", "31": "        #pragma omp critical(addlock)\n", "33": "        for(int i=0; i<C; i++){\n", "32": "        #pragma omp simd\n", "34": "            countervar[i]++;\n", "35": "        }\n", "37": "        #pragma omp critical(sublock)\n", "39": "        for(int i=0; i<C; i++){\n", "38": "        #pragma omp simd\n", "40": "            countervar[i] -= 2;\n", "41": "        }\n", "44": "    }\n", "28": "    #pragma omp teams distribute\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 42000\n\nint countervar[N];\n\nint init(){\n    for(int i=0; i<N; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:N]) device(0)\n    #pragma omp teams distribute parallel for\n        for (int i=1; i<N; i++){\n            countervar[i]=countervar[i-1]+1;\n        }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<N; i++){\n        if(countervar[i]!=i){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    count();\n    check();\n    return 0;\n}", "targets": {"22": "        for (int i=1; i<N; i++){\n", "21": "    #pragma omp teams distribute parallel for\n", "24": "        }\n", "23": "            countervar[i]=countervar[i-1]+1;\n"}}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams num_teams(1) thread_limit(1048)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: %i\\n\",countervar,N);\n    return 0;\n}", "targets": {"15": "    #pragma omp distribute parallel for\n", "16": "        for (int i=0; i<N; i++){\n", "17": "            countervar++;\n", "18": "        }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n#define N 100000\n#define C 512\n\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams distribute parallel for\n    for(int j=0; j<N; j++){\n        \n        #pragma omp critical(addlock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        \n        #pragma omp critical(sublock)\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i] -= 2;\n        }\n        \n        \n    }\n    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=-N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){    \n    init();\n    count();\n    check();\n    return 0;\n}", "targets": {"28": "    for(int j=0; j<N; j++){\n", "27": "    #pragma omp teams distribute parallel for\n", "43": "    }\n", "30": "        #pragma omp critical(addlock)\n", "32": "        for(int i=0; i<C; i++){\n", "31": "        #pragma omp simd\n", "33": "            countervar[i]++;\n", "34": "        }\n", "36": "        #pragma omp critical(sublock)\n", "38": "        for(int i=0; i<C; i++){\n", "37": "        #pragma omp simd\n", "39": "            countervar[i] -= 2;\n", "40": "        }\n"}}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n\t#pragma omp teams num_teams(1)\n    #pragma omp distribute parallel for\n        for (int i=0; i<N; i++){\n\t\t\t#pragma omp critical\n            countervar++;\n\t\t\t\n\t\t\t#pragma omp critical\n\t\t\tcountervar -= 2;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: -100000\\n \",countervar);\n    return 0;\n}", "targets": {"13": "    #pragma omp distribute parallel for\n", "14": "        for (int i=0; i<N; i++){\n", "15": "\t\t\t#pragma omp critical\n", "16": "            countervar++;\n", "18": "\t\t\t#pragma omp critical\n", "19": "\t\t\tcountervar -= 2;\n", "20": "        }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#define C 512\n\n\nint *a;\nint *b;\nint *c;\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        for(int j=0; j<C; j++){\n            b[j+i*C]=1;\n        }\n        a[i]=1;\n        c[i]=0;\n    }\n        return 0;\n}\n\n\nint Mult(){\n\t#pragma omp target map(to:a[0:C],b[0:C*C]) map(from:c[0:C])\n    #pragma omp teams distribute parallel for\n    for(int i=0; i<C; i++){\n        for(int j=0; j<C; j++){\n            c[i]+=b[j+i*C]*a[j];\n        }\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(c[i]!=C){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    a = malloc(C*sizeof(int));\n    b = malloc(C*C*sizeof(int));\n    c = malloc(C*sizeof(int));\n    init();\n    Mult();\n    check();\n    free(a);\n    free(b);\n    free(c);\n    return 0;\n}", "targets": {"33": "    for(int i=0; i<C; i++){\n", "32": "    #pragma omp teams distribute parallel for\n", "37": "    }\n", "34": "        for(int j=0; j<C; j++){\n", "35": "            c[i]+=b[j+i*C]*a[j];\n", "36": "        }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdbool.h>\n#define N 100\n#define C 512\n\n#pragma omp declare target\nomp_lock_t addlock;\nomp_lock_t sublock;\n#pragma omp end declare target\nint countervar[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        countervar[i]=0;\n    }\n    return 0;\n}\n\nint count(){\n    #pragma omp target map(tofrom:countervar[0:C]) device(0)\n    #pragma omp teams\n    {\n    omp_init_lock(&addlock);\n    omp_init_lock(&sublock);    \n    #pragma omp distribute parallel for\n    for(int j=0; j<N; j++){\n        \n        omp_set_lock(&addlock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]++;\n        }\n        omp_unset_lock(&addlock);\n        omp_set_lock(&sublock);\n        #pragma omp simd\n        for(int i=0; i<C; i++){\n            countervar[i]-=2;\n        }\n        omp_unset_lock(&sublock);\n        \n    }\n    omp_destroy_lock(&addlock);\n    omp_destroy_lock(&sublock);\n    }\n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(countervar[i]!=-N){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    \n    init();\n    \n    \n    \n    count();\n    check();\n    \n    return 0;\n}", "targets": {"30": "    {\n", "31": "    omp_init_lock(&addlock);\n", "32": "    omp_init_lock(&sublock);    \n", "34": "    for(int j=0; j<N; j++){\n", "33": "    #pragma omp distribute parallel for\n", "50": "    omp_destroy_lock(&addlock);\n", "51": "    omp_destroy_lock(&sublock);\n", "52": "    }\n", "36": "        omp_set_lock(&addlock);\n", "38": "        for(int i=0; i<C; i++){\n", "37": "        #pragma omp simd\n", "39": "            countervar[i]++;\n", "40": "        }\n", "41": "        omp_unset_lock(&addlock);\n", "42": "        omp_set_lock(&sublock);\n", "44": "        for(int i=0; i<C; i++){\n", "43": "        #pragma omp simd\n", "45": "            countervar[i]-=2;\n", "46": "        }\n", "47": "        omp_unset_lock(&sublock);\n", "49": "    }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define C 20000\n\n\nfloat a;\nfloat x[C];\nfloat y[C];\n\n\nint init(){\n    for(int i=0; i<C; i++){\n        a=5;\n        x[i]=0;\n        y[i]=3;\n    }\n        return 0;\n}\n\n\nint saxpy(){\n    \n    #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) device(0)\n    {\n        #pragma omp teams distribute        \n        for(int i=0; i<C; i++){\n            #pragma omp task \n            {\n                x[i] = a * x[i];                \n            }\n            #pragma omp task \n            {\n                x[i] = x[i] + y[i];\n            }\n        }\n        \n    }        \n    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    for(int i=0; i<C; i++){\n        if(x[i]!=3){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    saxpy();\n    check();\n    return 0;\n}", "targets": {"33": "        for(int i=0; i<C; i++){\n", "34": "            #pragma omp task \n", "36": "                x[i] = a * x[i];                \n", "38": "            #pragma omp task \n", "40": "                x[i] = x[i] + y[i];\n", "42": "        }\n", "32": "        #pragma omp teams distribute        \n", "35": "            {\n", "39": "            {\n"}}, {"prompt": "#include <stdio.h>\n#define N 100000\n\nint countervar = 0;\n\n\nint count(){\n    #pragma omp target map(tofrom:countervar) device(0)\n    #pragma omp teams distribute\n        for (int i=0; i<N; i++){\n\t\t\t#pragma omp atomic update\n            countervar++;\n        }\n    return 0;\n}\n\nint main(){\n    count();\n    printf(\"counter: %i expected: 100000\\n \",countervar);\n    return 0;\n}", "targets": {"13": "        for (int i=0; i<N; i++){\n", "15": "            countervar++;\n", "16": "        }\n", "12": "    #pragma omp teams distribute\n"}}, {"prompt": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#define N 100\n#define C 512\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint init(){\n    for(int i=0; i<C; i++){\n        b[i]=0;\n        c[i]=2;\n        temp[i]=0;\n    }\n    a=2;\n    return 0;\n}\n\n\nint add_Mult(){\n#pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n    {\n        #pragma omp teams \n        for(int i=0; i<N ;i++){\n            #pragma omp distribute\n            for(int i=0; i<C; i++){\n                temp[i] = b[i] + c[i];\n            }    \n        \n            #pragma omp distribute\n            for(int i=C; i>0; i--){\n                b[i] = temp[i] * a;\n            }    \n        \n        }\n        \n    }    \n    return 0;\n}\n\nint check(){\n    bool test = false;\n    int val = 0;\n    for(int i=0; i<N; i++){\n        val = val + 2;\n        val = val * 2;\n    }\n    for(int i=0; i<C; i++){\n        if(b[i]!=val){\n            test = true;\n        }\n    }\n    printf(\"Memory Access Issue visible: %s\\n\",test ? \"true\" : \"false\");\n    return 0;\n}\n\nint main(){\n    init();\n    add_Mult();\n    check();\n    return 0;\n}", "targets": {"34": "        for(int i=0; i<N ;i++){\n", "36": "            for(int i=0; i<C; i++){\n", "35": "            #pragma omp distribute\n", "37": "                temp[i] = b[i] + c[i];\n", "38": "            }    \n", "41": "            for(int i=C; i>0; i--){\n", "40": "            #pragma omp distribute\n", "42": "                b[i] = temp[i] * a;\n", "43": "            }    \n", "45": "        }\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf(\"a[50]=%d\\n\", a[50]);   \n  return 0;\n}\n", "targets": {"63": "  for (i=0;i<len-1;i++)\n", "62": "#pragma omp parallel for\n", "64": "    a[i+1]=a[i]+1;\n"}}, {"prompt": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 20x1000. */\n#include \"polybench/jacobi-2d-imper.h\"\n/* Array initialization. */\n\nstatic void init_array(int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c1;\n    int c2;\n    int c4;\n    int c3;\n    if (n >= 1) {\n#pragma omp parallel for private(c3, c4, c2)\n      for (c1 = 0; c1 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n          for (c3 = 16 * c2; c3 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c1; c4 <= ((16 * c1 + 15 < n + -1?16 * c1 + 15 : n + -1)); c4++) {\n              A[c4][c3] = (((double )c4) * (c3 + 2) + 2) / n;\n              B[c4][c3] = (((double )c4) * (c3 + 3) + 3) / n;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int n,double A[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",A[i][j]);\n      if ((i * n + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_jacobi_2d_imper(int tsteps,int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int t;\n  //int i;\n  //int j;\n  \n  //#pragma scop\n{\n    int c0;\n    int c1;\n    int c3;\n    int c2;\n    int c4;\n    int c5;\n    if (n >= 3 && tsteps >= 1) {\n      for (c0 = 0; c0 <= (((n + 3 * tsteps + -4) * 16 < 0?((16 < 0?-((-(n + 3 * tsteps + -4) + 16 + 1) / 16) : -((-(n + 3 * tsteps + -4) + 16 - 1) / 16))) : (n + 3 * tsteps + -4) / 16)); c0++) {\n#pragma omp parallel for private(c5, c4, c2, c3)\n        for (c1 = (((2 * c0 * 3 < 0?-(-(2 * c0) / 3) : ((3 < 0?(-(2 * c0) + - 3 - 1) / - 3 : (2 * c0 + 3 - 1) / 3)))) > (((16 * c0 + -1 * tsteps + 1) * 16 < 0?-(-(16 * c0 + -1 * tsteps + 1) / 16) : ((16 < 0?(-(16 * c0 + -1 * tsteps + 1) + - 16 - 1) / - 16 : (16 * c0 + -1 * tsteps + 1 + 16 - 1) / 16))))?((2 * c0 * 3 < 0?-(-(2 * c0) / 3) : ((3 < 0?(-(2 * c0) + - 3 - 1) / - 3 : (2 * c0 + 3 - 1) / 3)))) : (((16 * c0 + -1 * tsteps + 1) * 16 < 0?-(-(16 * c0 + -1 * tsteps + 1) / 16) : ((16 < 0?(-(16 * c0 + -1 * tsteps + 1) + - 16 - 1) / - 16 : (16 * c0 + -1 * tsteps + 1 + 16 - 1) / 16))))); c1 <= (((((((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) < (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48))?(((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) : (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48)))) < c0?(((((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) < (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48))?(((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) : (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48)))) : c0)); c1++) {\n          for (c2 = ((((16 * c1 + -1 * n + -12) * 16 < 0?-(-(16 * c1 + -1 * n + -12) / 16) : ((16 < 0?(-(16 * c1 + -1 * n + -12) + - 16 - 1) / - 16 : (16 * c1 + -1 * n + -12 + 16 - 1) / 16)))) > 2 * c0 + -2 * c1?(((16 * c1 + -1 * n + -12) * 16 < 0?-(-(16 * c1 + -1 * n + -12) / 16) : ((16 < 0?(-(16 * c1 + -1 * n + -12) + - 16 - 1) / - 16 : (16 * c1 + -1 * n + -12 + 16 - 1) / 16)))) : 2 * c0 + -2 * c1); c2 <= (((((((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) < (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16))?(((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) : (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)))) < (((32 * c0 + -32 * c1 + n + 29) * 16 < 0?((16 < 0?-((-(32 * c0 + -32 * c1 + n + 29) + 16 + 1) / 16) : -((-(32 * c0 + -32 * c1 + n + 29) + 16 - 1) / 16))) : (32 * c0 + -32 * c1 + n + 29) / 16))?(((((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) < (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16))?(((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) : (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)))) : (((32 * c0 + -32 * c1 + n + 29) * 16 < 0?((16 < 0?-((-(32 * c0 + -32 * c1 + n + 29) + 16 + 1) / 16) : -((-(32 * c0 + -32 * c1 + n + 29) + 16 - 1) / 16))) : (32 * c0 + -32 * c1 + n + 29) / 16)))); c2++) {\n            if (c0 <= (((32 * c1 + 16 * c2 + -1 * n + 1) * 32 < 0?((32 < 0?-((-(32 * c1 + 16 * c2 + -1 * n + 1) + 32 + 1) / 32) : -((-(32 * c1 + 16 * c2 + -1 * n + 1) + 32 - 1) / 32))) : (32 * c1 + 16 * c2 + -1 * n + 1) / 32)) && c1 <= c2 + -1) {\n              if ((n + 1) % 2 == 0) {\n                for (c4 = (16 * c1 > 16 * c2 + -1 * n + 3?16 * c1 : 16 * c2 + -1 * n + 3); c4 <= 16 * c1 + 15; c4++) {\n                  A[-16 * c2 + c4 + n + -2][n + -2] = B[-16 * c2 + c4 + n + -2][n + -2];\n                }\n              }\n            }\n            if (c0 <= (((48 * c1 + -1 * n + 1) * 32 < 0?((32 < 0?-((-(48 * c1 + -1 * n + 1) + 32 + 1) / 32) : -((-(48 * c1 + -1 * n + 1) + 32 - 1) / 32))) : (48 * c1 + -1 * n + 1) / 32)) && c1 >= c2) {\n              if ((n + 1) % 2 == 0) {\n                for (c5 = (16 * c2 > 16 * c1 + -1 * n + 3?16 * c2 : 16 * c1 + -1 * n + 3); c5 <= ((16 * c1 < 16 * c2 + 15?16 * c1 : 16 * c2 + 15)); c5++) {\n                  A[n + -2][-16 * c1 + c5 + n + -2] = B[n + -2][-16 * c1 + c5 + n + -2];\n                }\n              }\n            }\n            for (c3 = ((((((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) > (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2))))?(((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) : (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2)))))) > 16 * c0 + -16 * c1?(((((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) > (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2))))?(((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) : (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2)))))) : 16 * c0 + -16 * c1); c3 <= ((((((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) < tsteps + -1?((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) : tsteps + -1)) < 16 * c0 + -16 * c1 + 15?((((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) < tsteps + -1?((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) : tsteps + -1)) : 16 * c0 + -16 * c1 + 15)); c3++) {\n              if (c1 <= ((c3 * 8 < 0?((8 < 0?-((-c3 + 8 + 1) / 8) : -((-c3 + 8 - 1) / 8))) : c3 / 8))) {\n                for (c5 = (16 * c2 > 2 * c3 + 1?16 * c2 : 2 * c3 + 1); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -2?16 * c2 + 15 : 2 * c3 + n + -2)); c5++) {\n                  B[1][-2 * c3 + c5] = 0.2 * (A[1][-2 * c3 + c5] + A[1][-2 * c3 + c5 - 1] + A[1][1 + (-2 * c3 + c5)] + A[1 + 1][-2 * c3 + c5] + A[1 - 1][-2 * c3 + c5]);\n                }\n              }\n              for (c4 = (16 * c1 > 2 * c3 + 2?16 * c1 : 2 * c3 + 2); c4 <= ((16 * c1 + 15 < 2 * c3 + n + -2?16 * c1 + 15 : 2 * c3 + n + -2)); c4++) {\n                if (c2 <= ((c3 * 8 < 0?((8 < 0?-((-c3 + 8 + 1) / 8) : -((-c3 + 8 - 1) / 8))) : c3 / 8))) {\n                  B[-2 * c3 + c4][1] = 0.2 * (A[-2 * c3 + c4][1] + A[-2 * c3 + c4][1 - 1] + A[-2 * c3 + c4][1 + 1] + A[1 + (-2 * c3 + c4)][1] + A[-2 * c3 + c4 - 1][1]);\n                }\n                for (c5 = (16 * c2 > 2 * c3 + 2?16 * c2 : 2 * c3 + 2); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -2?16 * c2 + 15 : 2 * c3 + n + -2)); c5++) {\n                  B[-2 * c3 + c4][-2 * c3 + c5] = 0.2 * (A[-2 * c3 + c4][-2 * c3 + c5] + A[-2 * c3 + c4][-2 * c3 + c5 - 1] + A[-2 * c3 + c4][1 + (-2 * c3 + c5)] + A[1 + (-2 * c3 + c4)][-2 * c3 + c5] + A[-2 * c3 + c4 - 1][-2 * c3 + c5]);\n                  A[-2 * c3 + c4 + -1][-2 * c3 + c5 + -1] = B[-2 * c3 + c4 + -1][-2 * c3 + c5 + -1];\n                }\n                if (c2 >= (((2 * c3 + n + -16) * 16 < 0?-(-(2 * c3 + n + -16) / 16) : ((16 < 0?(-(2 * c3 + n + -16) + - 16 - 1) / - 16 : (2 * c3 + n + -16 + 16 - 1) / 16))))) {\n                  A[-2 * c3 + c4 + -1][n + -2] = B[-2 * c3 + c4 + -1][n + -2];\n                }\n              }\n              if (c1 >= (((2 * c3 + n + -16) * 16 < 0?-(-(2 * c3 + n + -16) / 16) : ((16 < 0?(-(2 * c3 + n + -16) + - 16 - 1) / - 16 : (2 * c3 + n + -16 + 16 - 1) / 16))))) {\n                for (c5 = (16 * c2 > 2 * c3 + 2?16 * c2 : 2 * c3 + 2); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -1?16 * c2 + 15 : 2 * c3 + n + -1)); c5++) {\n                  A[n + -2][-2 * c3 + c5 + -1] = B[n + -2][-2 * c3 + c5 + -1];\n                }\n              }\n            }\n            if (c0 >= (((2 * c1 + c2 + -1) * 2 < 0?-(-(2 * c1 + c2 + -1) / 2) : ((2 < 0?(-(2 * c1 + c2 + -1) + - 2 - 1) / - 2 : (2 * c1 + c2 + -1 + 2 - 1) / 2)))) && c1 >= c2 + 1 && c2 <= (((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8))) {\n              for (c4 = 16 * c1; c4 <= ((16 * c1 + 15 < 16 * c2 + n + 12?16 * c1 + 15 : 16 * c2 + n + 12)); c4++) {\n                B[-16 * c2 + c4 + -14][1] = 0.2 * (A[-16 * c2 + c4 + -14][1] + A[-16 * c2 + c4 + -14][1 - 1] + A[-16 * c2 + c4 + -14][1 + 1] + A[1 + (-16 * c2 + c4 + -14)][1] + A[-16 * c2 + c4 + -14 - 1][1]);\n              }\n            }\n            if (c0 >= (((3 * c1 + -1) * 2 < 0?-(-(3 * c1 + -1) / 2) : ((2 < 0?(-(3 * c1 + -1) + - 2 - 1) / - 2 : (3 * c1 + -1 + 2 - 1) / 2)))) && c1 <= (((((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8)) < c2?(((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8)) : c2))) {\n              for (c5 = (16 * c2 > 16 * c1 + 15?16 * c2 : 16 * c1 + 15); c5 <= ((16 * c2 + 15 < 16 * c1 + n + 12?16 * c2 + 15 : 16 * c1 + n + 12)); c5++) {\n                B[1][-16 * c1 + c5 + -14] = 0.2 * (A[1][-16 * c1 + c5 + -14] + A[1][-16 * c1 + c5 + -14 - 1] + A[1][1 + (-16 * c1 + c5 + -14)] + A[1 + 1][-16 * c1 + c5 + -14] + A[1 - 1][-16 * c1 + c5 + -14]);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int n = 500;\n  int tsteps = 10;\n/* Variable declaration/allocation. */\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(n, *A, *B);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_jacobi_2d_imper(tsteps,n, *A, *B);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *A);\n/* Be clean. */\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n", "targets": {"31": "      for (c1 = 0; c1 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c1++) {\n", "30": "#pragma omp parallel for private(c3, c4, c2)\n", "32": "        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n", "33": "          for (c3 = 16 * c2; c3 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c3++) {\n", "35": "            for (c4 = 16 * c1; c4 <= ((16 * c1 + 15 < n + -1?16 * c1 + 15 : n + -1)); c4++) {\n", "34": "#pragma omp simd\n", "36": "              A[c4][c3] = (((double )c4) * (c3 + 2) + 2) / n;\n", "37": "              B[c4][c3] = (((double )c4) * (c3 + 3) + 3) / n;\n", "38": "            }\n", "39": "          }\n", "40": "        }\n", "41": "      }\n", "80": "        for (c1 = (((2 * c0 * 3 < 0?-(-(2 * c0) / 3) : ((3 < 0?(-(2 * c0) + - 3 - 1) / - 3 : (2 * c0 + 3 - 1) / 3)))) > (((16 * c0 + -1 * tsteps + 1) * 16 < 0?-(-(16 * c0 + -1 * tsteps + 1) / 16) : ((16 < 0?(-(16 * c0 + -1 * tsteps + 1) + - 16 - 1) / - 16 : (16 * c0 + -1 * tsteps + 1 + 16 - 1) / 16))))?((2 * c0 * 3 < 0?-(-(2 * c0) / 3) : ((3 < 0?(-(2 * c0) + - 3 - 1) / - 3 : (2 * c0 + 3 - 1) / 3)))) : (((16 * c0 + -1 * tsteps + 1) * 16 < 0?-(-(16 * c0 + -1 * tsteps + 1) / 16) : ((16 < 0?(-(16 * c0 + -1 * tsteps + 1) + - 16 - 1) / - 16 : (16 * c0 + -1 * tsteps + 1 + 16 - 1) / 16))))); c1 <= (((((((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) < (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48))?(((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) : (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48)))) < c0?(((((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) < (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48))?(((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)) : (((32 * c0 + n + 29) * 48 < 0?((48 < 0?-((-(32 * c0 + n + 29) + 48 + 1) / 48) : -((-(32 * c0 + n + 29) + 48 - 1) / 48))) : (32 * c0 + n + 29) / 48)))) : c0)); c1++) {\n", "79": "#pragma omp parallel for private(c5, c4, c2, c3)\n", "81": "          for (c2 = ((((16 * c1 + -1 * n + -12) * 16 < 0?-(-(16 * c1 + -1 * n + -12) / 16) : ((16 < 0?(-(16 * c1 + -1 * n + -12) + - 16 - 1) / - 16 : (16 * c1 + -1 * n + -12 + 16 - 1) / 16)))) > 2 * c0 + -2 * c1?(((16 * c1 + -1 * n + -12) * 16 < 0?-(-(16 * c1 + -1 * n + -12) / 16) : ((16 < 0?(-(16 * c1 + -1 * n + -12) + - 16 - 1) / - 16 : (16 * c1 + -1 * n + -12 + 16 - 1) / 16)))) : 2 * c0 + -2 * c1); c2 <= (((((((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) < (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16))?(((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) : (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)))) < (((32 * c0 + -32 * c1 + n + 29) * 16 < 0?((16 < 0?-((-(32 * c0 + -32 * c1 + n + 29) + 16 + 1) / 16) : -((-(32 * c0 + -32 * c1 + n + 29) + 16 - 1) / 16))) : (32 * c0 + -32 * c1 + n + 29) / 16))?(((((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) < (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16))?(((16 * c1 + n + 12) * 16 < 0?((16 < 0?-((-(16 * c1 + n + 12) + 16 + 1) / 16) : -((-(16 * c1 + n + 12) + 16 - 1) / 16))) : (16 * c1 + n + 12) / 16)) : (((n + 2 * tsteps + -3) * 16 < 0?((16 < 0?-((-(n + 2 * tsteps + -3) + 16 + 1) / 16) : -((-(n + 2 * tsteps + -3) + 16 - 1) / 16))) : (n + 2 * tsteps + -3) / 16)))) : (((32 * c0 + -32 * c1 + n + 29) * 16 < 0?((16 < 0?-((-(32 * c0 + -32 * c1 + n + 29) + 16 + 1) / 16) : -((-(32 * c0 + -32 * c1 + n + 29) + 16 - 1) / 16))) : (32 * c0 + -32 * c1 + n + 29) / 16)))); c2++) {\n", "82": "            if (c0 <= (((32 * c1 + 16 * c2 + -1 * n + 1) * 32 < 0?((32 < 0?-((-(32 * c1 + 16 * c2 + -1 * n + 1) + 32 + 1) / 32) : -((-(32 * c1 + 16 * c2 + -1 * n + 1) + 32 - 1) / 32))) : (32 * c1 + 16 * c2 + -1 * n + 1) / 32)) && c1 <= c2 + -1) {\n", "83": "              if ((n + 1) % 2 == 0) {\n", "84": "                for (c4 = (16 * c1 > 16 * c2 + -1 * n + 3?16 * c1 : 16 * c2 + -1 * n + 3); c4 <= 16 * c1 + 15; c4++) {\n", "85": "                  A[-16 * c2 + c4 + n + -2][n + -2] = B[-16 * c2 + c4 + n + -2][n + -2];\n", "86": "                }\n", "87": "              }\n", "88": "            }\n", "89": "            if (c0 <= (((48 * c1 + -1 * n + 1) * 32 < 0?((32 < 0?-((-(48 * c1 + -1 * n + 1) + 32 + 1) / 32) : -((-(48 * c1 + -1 * n + 1) + 32 - 1) / 32))) : (48 * c1 + -1 * n + 1) / 32)) && c1 >= c2) {\n", "90": "              if ((n + 1) % 2 == 0) {\n", "91": "                for (c5 = (16 * c2 > 16 * c1 + -1 * n + 3?16 * c2 : 16 * c1 + -1 * n + 3); c5 <= ((16 * c1 < 16 * c2 + 15?16 * c1 : 16 * c2 + 15)); c5++) {\n", "92": "                  A[n + -2][-16 * c1 + c5 + n + -2] = B[n + -2][-16 * c1 + c5 + n + -2];\n", "93": "                }\n", "94": "              }\n", "95": "            }\n", "96": "            for (c3 = ((((((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) > (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2))))?(((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) : (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2)))))) > 16 * c0 + -16 * c1?(((((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) > (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2))))?(((16 * c1 + -1 * n + 2) * 2 < 0?-(-(16 * c1 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c1 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c1 + -1 * n + 2 + 2 - 1) / 2)))) : (((16 * c2 + -1 * n + 2) * 2 < 0?-(-(16 * c2 + -1 * n + 2) / 2) : ((2 < 0?(-(16 * c2 + -1 * n + 2) + - 2 - 1) / - 2 : (16 * c2 + -1 * n + 2 + 2 - 1) / 2)))))) : 16 * c0 + -16 * c1); c3 <= ((((((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) < tsteps + -1?((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) : tsteps + -1)) < 16 * c0 + -16 * c1 + 15?((((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) < tsteps + -1?((8 * c1 + 6 < 8 * c2 + 6?8 * c1 + 6 : 8 * c2 + 6)) : tsteps + -1)) : 16 * c0 + -16 * c1 + 15)); c3++) {\n", "97": "              if (c1 <= ((c3 * 8 < 0?((8 < 0?-((-c3 + 8 + 1) / 8) : -((-c3 + 8 - 1) / 8))) : c3 / 8))) {\n", "98": "                for (c5 = (16 * c2 > 2 * c3 + 1?16 * c2 : 2 * c3 + 1); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -2?16 * c2 + 15 : 2 * c3 + n + -2)); c5++) {\n", "99": "                  B[1][-2 * c3 + c5] = 0.2 * (A[1][-2 * c3 + c5] + A[1][-2 * c3 + c5 - 1] + A[1][1 + (-2 * c3 + c5)] + A[1 + 1][-2 * c3 + c5] + A[1 - 1][-2 * c3 + c5]);\n", "100": "                }\n", "101": "              }\n", "102": "              for (c4 = (16 * c1 > 2 * c3 + 2?16 * c1 : 2 * c3 + 2); c4 <= ((16 * c1 + 15 < 2 * c3 + n + -2?16 * c1 + 15 : 2 * c3 + n + -2)); c4++) {\n", "103": "                if (c2 <= ((c3 * 8 < 0?((8 < 0?-((-c3 + 8 + 1) / 8) : -((-c3 + 8 - 1) / 8))) : c3 / 8))) {\n", "104": "                  B[-2 * c3 + c4][1] = 0.2 * (A[-2 * c3 + c4][1] + A[-2 * c3 + c4][1 - 1] + A[-2 * c3 + c4][1 + 1] + A[1 + (-2 * c3 + c4)][1] + A[-2 * c3 + c4 - 1][1]);\n", "105": "                }\n", "106": "                for (c5 = (16 * c2 > 2 * c3 + 2?16 * c2 : 2 * c3 + 2); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -2?16 * c2 + 15 : 2 * c3 + n + -2)); c5++) {\n", "107": "                  B[-2 * c3 + c4][-2 * c3 + c5] = 0.2 * (A[-2 * c3 + c4][-2 * c3 + c5] + A[-2 * c3 + c4][-2 * c3 + c5 - 1] + A[-2 * c3 + c4][1 + (-2 * c3 + c5)] + A[1 + (-2 * c3 + c4)][-2 * c3 + c5] + A[-2 * c3 + c4 - 1][-2 * c3 + c5]);\n", "108": "                  A[-2 * c3 + c4 + -1][-2 * c3 + c5 + -1] = B[-2 * c3 + c4 + -1][-2 * c3 + c5 + -1];\n", "109": "                }\n", "110": "                if (c2 >= (((2 * c3 + n + -16) * 16 < 0?-(-(2 * c3 + n + -16) / 16) : ((16 < 0?(-(2 * c3 + n + -16) + - 16 - 1) / - 16 : (2 * c3 + n + -16 + 16 - 1) / 16))))) {\n", "111": "                  A[-2 * c3 + c4 + -1][n + -2] = B[-2 * c3 + c4 + -1][n + -2];\n", "112": "                }\n", "113": "              }\n", "114": "              if (c1 >= (((2 * c3 + n + -16) * 16 < 0?-(-(2 * c3 + n + -16) / 16) : ((16 < 0?(-(2 * c3 + n + -16) + - 16 - 1) / - 16 : (2 * c3 + n + -16 + 16 - 1) / 16))))) {\n", "115": "                for (c5 = (16 * c2 > 2 * c3 + 2?16 * c2 : 2 * c3 + 2); c5 <= ((16 * c2 + 15 < 2 * c3 + n + -1?16 * c2 + 15 : 2 * c3 + n + -1)); c5++) {\n", "116": "                  A[n + -2][-2 * c3 + c5 + -1] = B[n + -2][-2 * c3 + c5 + -1];\n", "117": "                }\n", "118": "              }\n", "119": "            }\n", "120": "            if (c0 >= (((2 * c1 + c2 + -1) * 2 < 0?-(-(2 * c1 + c2 + -1) / 2) : ((2 < 0?(-(2 * c1 + c2 + -1) + - 2 - 1) / - 2 : (2 * c1 + c2 + -1 + 2 - 1) / 2)))) && c1 >= c2 + 1 && c2 <= (((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8))) {\n", "121": "              for (c4 = 16 * c1; c4 <= ((16 * c1 + 15 < 16 * c2 + n + 12?16 * c1 + 15 : 16 * c2 + n + 12)); c4++) {\n", "122": "                B[-16 * c2 + c4 + -14][1] = 0.2 * (A[-16 * c2 + c4 + -14][1] + A[-16 * c2 + c4 + -14][1 - 1] + A[-16 * c2 + c4 + -14][1 + 1] + A[1 + (-16 * c2 + c4 + -14)][1] + A[-16 * c2 + c4 + -14 - 1][1]);\n", "123": "              }\n", "124": "            }\n", "125": "            if (c0 >= (((3 * c1 + -1) * 2 < 0?-(-(3 * c1 + -1) / 2) : ((2 < 0?(-(3 * c1 + -1) + - 2 - 1) / - 2 : (3 * c1 + -1 + 2 - 1) / 2)))) && c1 <= (((((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8)) < c2?(((tsteps + -8) * 8 < 0?((8 < 0?-((-(tsteps + -8) + 8 + 1) / 8) : -((-(tsteps + -8) + 8 - 1) / 8))) : (tsteps + -8) / 8)) : c2))) {\n", "126": "              for (c5 = (16 * c2 > 16 * c1 + 15?16 * c2 : 16 * c1 + 15); c5 <= ((16 * c2 + 15 < 16 * c1 + n + 12?16 * c2 + 15 : 16 * c1 + n + 12)); c5++) {\n", "127": "                B[1][-16 * c1 + c5 + -14] = 0.2 * (A[1][-16 * c1 + c5 + -14] + A[1][-16 * c1 + c5 + -14 - 1] + A[1][1 + (-16 * c1 + c5 + -14)] + A[1 + 1][-16 * c1 + c5 + -14] + A[1 - 1][-16 * c1 + c5 + -14]);\n", "128": "              }\n", "129": "            }\n", "130": "          }\n", "131": "        }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp taskwait depend(in: x)                  // 1st taskwait\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n  #pragma omp taskwait                                // 2nd taskwait\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n", "targets": {"24": "  #pragma omp task depend(inout: x) shared(x)\n", "25": "  x++;                                                //1st Child Task\n", "27": "  #pragma omp task shared(y)\n", "28": "  y--;                                                // 2nd child task\n", "40": "  #pragma omp single\n", "41": "  foo();\n"}}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }     \n  return 0;      \n}\n\n", "targets": {"65": "  for (i=0;i<len;i++)\n", "64": "#pragma omp parallel for\n", "67": "    a[i] = tmp;\n", "68": "    tmp =a[i]+i;\n", "69": "  }     \n"}}, {"prompt": "#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n//#pragma omp threadprivate(sum0)\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n/*  reference calculation */\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n//  assert(sum==sum1);\n  return 0;\n}\n\n", "targets": {"64": "  {\n", "66": "    for (i=1;i<=1000;i++)\n", "65": "#pragma omp for\n", "68": "      sum0=sum0+i;\n", "69": "    }   \n", "70": "#pragma omp critical\n", "72": "      sum= sum+sum0;\n", "73": "    } \n", "74": "  }  \n"}}, {"prompt": "#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE;\ndouble alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n  /* Initialize initial condition and RHS */\n#pragma omp parallel for private(i,j,xx,yy)\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       /* -1 < x < 1 */\n      yy = (int) (-1.0 + dy * (j - 1));       /* -1 < y < 1 */\n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nint main()\n{\n  initialize();\n  return 0;\n}\n", "targets": {"69": "  for (i = 0; i < n; i++)\n", "68": "#pragma omp parallel for private(i,j,xx,yy)\n", "70": "    for (j = 0; j < m; j++)\n", "72": "      xx = (int) (-1.0 + dx * (i - 1));       /* -1 < x < 1 */\n", "73": "      yy = (int) (-1.0 + dy * (j - 1));       /* -1 < y < 1 */\n", "74": "      u[i][j] = 0.0;\n", "75": "      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n", "76": "        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n", "78": "    }\n"}}, {"prompt": "#include <stdio.h>\n#include <assert.h>\nunsigned int input = 30;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n#pragma omp taskwait\n    return i+j;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf (\"Fib(%d)=%d\\n\", input, result);\n  assert (result==832040);\n  return 0;\n}\n", "targets": {"60": "#pragma omp task shared(i)\n", "61": "    i=fib(n-1);\n", "62": "#pragma omp task shared(j)\n", "63": "    j=fib(n-2);\n", "72": "  {\n", "73": "   #pragma omp single\n", "75": "      result = fib(input);\n", "76": "    }\n", "77": "  }\n"}}, {"prompt": "#include <stdio.h> \n#include <assert.h> \n#include <unistd.h>\n#include \"signaling.h\"\nint main()\n{\n  int i=0, j, k;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      delay(10000);\n      i = 1;    \n    }\n#pragma omp task depend (in:i)\n    j =i; \n#pragma omp task depend (in:i)\n    k =i; \n  }\n  printf (\"j=%d k=%d\\n\", j, k);\n  assert (j==1 && k==1);\n  return 0;\n} \n", "targets": {"58": "#pragma omp single\n", "60": "#pragma omp task depend (out:i)\n", "65": "#pragma omp task depend (in:i)\n", "67": "#pragma omp task depend (in:i)\n", "69": "  }\n", "61": "    {\n", "62": "      delay(10000);\n", "63": "      i = 1;    \n", "66": "    j =i; \n", "68": "    k =i; \n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\n\nvoid incr_b(pair *p){\n  p->b += 1;\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf(\"%d\\n\",p->b);\n  return 0;\n}\n", "targets": {"44": "  {\n", "43": "  #pragma omp parallel sections\n", "47": "      omp_set_nest_lock(&p->lck);\n", "48": "      incr_b(p);\n", "49": "      incr_a(p);\n", "50": "      omp_unset_nest_lock(&p->lck);\n", "45": "    #pragma omp section\n", "53": "      incr_b(p);\n", "52": "    #pragma omp section\n", "54": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  float u[len][len];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5;\n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n  printf (\"sum = %f\\n\", sum); \n  return 0;\n}\n", "targets": {"68": "  for (i = 0; i < len; i++)\n", "67": "#pragma omp parallel for private (temp,i,j)\n", "69": "    for (j = 0; j < len; j++)\n", "71": "      temp = u[i][j];\n", "72": "      sum = sum + temp * temp;\n", "73": "    }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         //2nd child task\n\n  #pragma omp task depend(in: x) if(0)                             // 1st taskwait\n  {}\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n\n  #pragma omp taskwait\t\t                                         // 2nd taskwait\n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n", "targets": {"24": "  #pragma omp task depend(inout: x) shared(x)\n", "25": "  x++;                                                             // 1st child task\n", "27": "  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n", "28": "  y -= x;                                                         //2nd child task\n", "30": "  #pragma omp task depend(in: x) if(0)                             // 1st taskwait\n", "31": "  {}\n", "42": "  #pragma omp single\n", "43": "  foo();\n"}}, {"prompt": "", "targets": {"60": "  for (i = 0; i < N; i++) \n", "59": "#pragma omp parallel for private(j,k)\n", "61": "    for (k = 0; k < K; k++) \n", "62": "      for (j = 0; j < M; j++)\n", "63": "        c[i][j]= c[i][j]+a[i][k]*b[k][j];\n"}}, {"prompt": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 10x1024x1024. */\n#include \"polybench/adi.h\"\n/* Array initialization. */\n\nstatic void init_array(int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c1;\n    int c3;\n    int c2;\n    int c4;\n    if (n >= 1) {\n#pragma omp parallel for private(c4, c2, c3)\n      for (c1 = 0; c1 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < n + -1?16 * c1 + 15 : n + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c4++) {\n              X[c3][c4] = (((double )c3) * (c4 + 1) + 1) / n;\n              A[c3][c4] = (((double )c3) * (c4 + 2) + 2) / n;\n              B[c3][c4] = (((double )c3) * (c4 + 3) + 3) / n;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int n,double X[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",X[i][j]);\n      if ((i * 500 + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_adi(int tsteps,int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int t;\n  //int i1;\n  //int i2;\n  \n  //#pragma scop\n{\n    int c0;\n    int c2;\n    int c8;\n    int c9;\n    int c15;\n    if (n >= 1 && tsteps >= 1) {\n      for (c0 = 0; c0 <= tsteps + -1; c0++) {\n        if (n >= 2) {\n#pragma omp parallel for private(c15, c9, c8)\n          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  B[c15][c9] = B[c15][c9] - A[c15][c9] * A[c15][c9] / B[c15][c9 - 1];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c15][c9] = X[c15][c9] - X[c15][c9 - 1] * A[c15][c9] / B[c15][c9 - 1];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c15][n - c9 - 2] = (X[c15][n - 2 - c9] - X[c15][n - 2 - c9 - 1] * A[c15][n - c9 - 3]) / B[c15][n - 3 - c9];\n                }\n              }\n            }\n          }\n        }\n#pragma omp parallel for private(c15)\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n#pragma omp simd\n          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n            X[c15][n - 1] = X[c15][n - 1] / B[c15][n - 1];\n          }\n        }\n        if (n >= 2) {\n#pragma omp parallel for private(c15, c9, c8)\n          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  B[c9][c15] = B[c9][c15] - A[c9][c15] * A[c9][c15] / B[c9 - 1][c15];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[c9][c15] = X[c9][c15] - X[c9 - 1][c15] * A[c9][c15] / B[c9 - 1][c15];\n                }\n              }\n            }\n            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n#pragma omp simd\n                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n                  X[n - 2 - c9][c15] = (X[n - 2 - c9][c15] - X[n - c9 - 3][c15] * A[n - 3 - c9][c15]) / B[n - 2 - c9][c15];\n                }\n              }\n            }\n          }\n        }\n#pragma omp parallel for private(c15)\n        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n#pragma omp simd\n          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n            X[n - 1][c15] = X[n - 1][c15] / B[n - 1][c15];\n          }\n        }\n      }\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int n = 500;\n  int tsteps = 10;\n/* Variable declaration/allocation. */\n  double (*X)[500 + 0][500 + 0];\n  X = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(n, *X, *A, *B);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_adi(tsteps,n, *X, *A, *B);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *X);\n/* Be clean. */\n  free(((void *)X));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n", "targets": {"31": "      for (c1 = 0; c1 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c1++) {\n", "30": "#pragma omp parallel for private(c4, c2, c3)\n", "32": "        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n", "33": "          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < n + -1?16 * c1 + 15 : n + -1)); c3++) {\n", "35": "            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c4++) {\n", "34": "#pragma omp simd\n", "36": "              X[c3][c4] = (((double )c3) * (c4 + 1) + 1) / n;\n", "37": "              A[c3][c4] = (((double )c3) * (c4 + 2) + 2) / n;\n", "38": "              B[c3][c4] = (((double )c3) * (c4 + 3) + 3) / n;\n", "39": "            }\n", "40": "          }\n", "41": "        }\n", "42": "      }\n", "81": "          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n", "80": "#pragma omp parallel for private(c15, c9, c8)\n", "82": "            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n", "83": "              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n", "85": "                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n", "84": "#pragma omp simd\n", "86": "                  B[c15][c9] = B[c15][c9] - A[c15][c9] * A[c15][c9] / B[c15][c9 - 1];\n", "87": "                }\n", "88": "              }\n", "89": "            }\n", "90": "            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n", "91": "              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n", "93": "                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n", "92": "#pragma omp simd\n", "94": "                  X[c15][c9] = X[c15][c9] - X[c15][c9 - 1] * A[c15][c9] / B[c15][c9 - 1];\n", "95": "                }\n", "96": "              }\n", "97": "            }\n", "98": "            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n", "99": "              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n", "101": "                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n", "100": "#pragma omp simd\n", "102": "                  X[c15][n - c9 - 2] = (X[c15][n - 2 - c9] - X[c15][n - 2 - c9 - 1] * A[c15][n - c9 - 3]) / B[c15][n - 3 - c9];\n", "103": "                }\n", "104": "              }\n", "105": "            }\n", "106": "          }\n", "109": "        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n", "108": "#pragma omp parallel for private(c15)\n", "111": "          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n", "110": "#pragma omp simd\n", "112": "            X[c15][n - 1] = X[c15][n - 1] / B[c15][n - 1];\n", "113": "          }\n", "114": "        }\n", "117": "          for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n", "116": "#pragma omp parallel for private(c15, c9, c8)\n", "118": "            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n", "119": "              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n", "121": "                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n", "120": "#pragma omp simd\n", "122": "                  B[c9][c15] = B[c9][c15] - A[c9][c15] * A[c9][c15] / B[c9 - 1][c15];\n", "123": "                }\n", "124": "              }\n", "125": "            }\n", "126": "            for (c8 = 0; c8 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c8++) {\n", "127": "              for (c9 = (1 > 16 * c8?1 : 16 * c8); c9 <= ((16 * c8 + 15 < n + -1?16 * c8 + 15 : n + -1)); c9++) {\n", "129": "                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n", "128": "#pragma omp simd\n", "130": "                  X[c9][c15] = X[c9][c15] - X[c9 - 1][c15] * A[c9][c15] / B[c9 - 1][c15];\n", "131": "                }\n", "132": "              }\n", "133": "            }\n", "134": "            for (c8 = 0; c8 <= (((n + -3) * 16 < 0?((16 < 0?-((-(n + -3) + 16 + 1) / 16) : -((-(n + -3) + 16 - 1) / 16))) : (n + -3) / 16)); c8++) {\n", "135": "              for (c9 = 16 * c8; c9 <= ((16 * c8 + 15 < n + -3?16 * c8 + 15 : n + -3)); c9++) {\n", "137": "                for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n", "136": "#pragma omp simd\n", "138": "                  X[n - 2 - c9][c15] = (X[n - 2 - c9][c15] - X[n - c9 - 3][c15] * A[n - 3 - c9][c15]) / B[n - 2 - c9][c15];\n", "139": "                }\n", "140": "              }\n", "141": "            }\n", "142": "          }\n", "145": "        for (c2 = 0; c2 <= (((n + -1) * 16 < 0?((16 < 0?-((-(n + -1) + 16 + 1) / 16) : -((-(n + -1) + 16 - 1) / 16))) : (n + -1) / 16)); c2++) {\n", "144": "#pragma omp parallel for private(c15)\n", "147": "          for (c15 = 16 * c2; c15 <= ((16 * c2 + 15 < n + -1?16 * c2 + 15 : n + -1)); c15++) {\n", "146": "#pragma omp simd\n", "148": "            X[n - 1][c15] = X[n - 1][c15] / B[n - 1][c15];\n", "149": "          }\n", "150": "        }\n"}}, {"prompt": "", "targets": {"57": "  for (i = 0; i < N; i++)\n", "56": "#pragma omp parallel for private (i,j)\n", "59": "    float sum = 0.0;\n", "60": "    for (j = 0; j < N; j++)\n", "62": "      sum += a[i][j]*v[j];\n", "63": "    }  \n", "64": "    v_out[i] = sum;\n", "65": "  }         \n"}}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int ret;\n  FILE* pfile;\n  int len=1000;\n\n  int A[1000];\n\n  for (i=0; i<len; i++)\n    A[i]=i;\n\n  pfile = fopen(\"mytempfile.txt\",\"a+\");\n  if (pfile ==NULL)\n  {\n    fprintf(stderr,\"Error in fopen()\\n\");\n  }\n\n#pragma omp parallel for\n  for (i=0; i<len; ++i)\n  {\n    fprintf(pfile, \"%d\\n\", A[i] );\n  }\n\n  fclose(pfile);\n  ret = remove(\"mytempfile.txt\");\n  if (ret != 0)\n  {\n    fprintf(stderr, \"Error: unable to delete mytempfile.txt\\n\");\n  }\n  return 0;\n}\n\n", "targets": {"70": "  for (i=0; i<len; ++i)\n", "69": "#pragma omp parallel for\n", "72": "    fprintf(pfile, \"%d\\n\", A[i] );\n", "73": "  }\n"}}, {"prompt": "", "targets": {"63": "  for (i=0;i< len -1 ;i++)\n", "62": "#pragma omp parallel for\n", "64": "    a[i]=a[i+1]+1;\n"}}, {"prompt": "#include <stdio.h>\n/*\nTwo-dimensional array computation using loops: missing private(j).\nReferences to j in the loop cause data races.\nData race pairs (we allow multiple ones to preserve the pattern):\n  Write_set = {j@61:10, j@61:20}\n  Read_set = {j@62:20, j@62:12, j@61:14, j@61:20}\n  Any pair from Write_set vs. Write_set  and Write_set vs. Read_set is a data race pair.\n*/\nint a[100][100];\nint main()\n{\n  int i,j;\n#pragma omp parallel for\n  for (i=0;i<100;i++)\n    for (j=0;j<100;j++)\n      a[i][j]=a[i][j]+1;\n  return 0;\n}\n\n", "targets": {"60": "  for (i=0;i<100;i++)\n", "59": "#pragma omp parallel for\n", "61": "    for (j=0;j<100;j++)\n", "62": "      a[i][j]=a[i][j]+1;\n"}}, {"prompt": "#include <stdio.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n\n  printf (\"error = %d\\n\", error);\n  return 0;\n}  \n", "targets": {"69": "  {\n", "71": "    for(i = 0; i < len; i++)\n", "70": "#pragma omp for nowait\n", "72": "      a[i] = b + a[i]*5;\n", "74": "#pragma omp single\n", "75": "    error = a[9] + 1;\n", "76": "  }\n"}}, {"prompt": "#include <stdio.h>\n/*\n * This is a program based on a dataset contributed by \n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n \n * sync with busy wait loop using atomic. No data race pair.\n */\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp atomic write seq_cst\n      s = 1;\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp atomic read seq_cst\n        done = s;\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n", "targets": {"21": "  {\n", "20": "#pragma omp parallel sections shared(x, s) num_threads(2)\n", "24": "      x = 1;\n", "26": "      s = 1;\n", "22": "#pragma omp section\n", "30": "      int done = 0;\n", "31": "      while (!done)\n", "34": "        done = s;\n", "36": "      x = 2;\n", "28": "#pragma omp section\n", "38": "  }\n"}}, {"prompt": "#include <stdlib.h>  \nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int numNodes=len, numNodes2=0; \n  int x[len]; \n\n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }         \n  return 0;\n} \n", "targets": {"72": "  for (i=numNodes-1 ; i>-1 ; --i) {\n", "71": "#pragma omp parallel for\n", "73": "    if (x[i]<=0) {\n", "74": "      numNodes2-- ;\n", "75": "    }\n", "76": "  }         \n"}}, {"prompt": "#include <assert.h> \n#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task\n    i = 1;    \n#pragma omp task\n    i = 2;    \n  }\n\n  printf (\"i=%d\\n\",i);\n  return 0;\n} \n", "targets": {"58": "#pragma omp single\n", "60": "#pragma omp task\n", "62": "#pragma omp task\n", "64": "  }\n", "61": "    i = 1;    \n", "63": "    i = 2;    \n"}}, {"prompt": "#include <stdlib.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  return 0;\n}\n", "targets": {"62": "  for (i=0;i<len;i++)\n", "61": "#pragma omp parallel for\n", "63": "    a[i]=a[i]+a[0];\n"}}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n  return 0;\n}\n", "targets": {"63": "  for (i=0;i<len;i++)\n", "62": "#pragma omp parallel for\n", "65": "    tmp =a[i]+i;\n", "66": "    a[i] = tmp;\n", "67": "  }\n"}}, {"prompt": "#include <stdio.h>\n/*\nuse of omp target + map + array sections derived from pointers\n*/\nvoid foo (double* a, double* b, int N)\n{\n  int i; \n#pragma omp target map(to:a[0:N]) map(from:b[0:N])\n#pragma omp parallel for\n  for (i=0;i< N ;i++)\n    b[i]=a[i]*(double)i;\n}\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 1000;\n  double a[len], b[len];\n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]=0.0;\n  }\n\n  foo(a, b, len);\n\n  printf(\"b[50]=%f\\n\",b[50]);\n  return 0;\n}\n", "targets": {"55": "  for (i=0;i< N ;i++)\n", "54": "#pragma omp parallel for\n", "56": "    b[i]=a[i]*(double)i;\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l0);\n    else if (tid == 1)\n      omp_set_lock(&l1);\n#pragma omp barrier\n    if (tid == 0)\n      x = 0;\n    if (tid == 0)\n    {\n      omp_unset_lock(&l0);\n      omp_set_lock(&l1);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l0);\n      omp_unset_lock(&l1);\n    }\n    if (tid == 1)\n      x = 1;\n#pragma omp barrier\n    if (tid == 0)\n      omp_unset_lock(&l1);\n    else if (tid == 1)\n      omp_unset_lock(&l0);\n  } // end of parallel construct\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  printf(\"Done: x=%d\\n\", x);\n}\n", "targets": {"30": "    int tid = omp_get_thread_num();\n", "31": "    if (tid == 0)\n", "32": "      omp_set_lock(&l0);\n", "33": "    else if (tid == 1)\n", "34": "      omp_set_lock(&l1);\n", "35": "#pragma omp barrier\n", "36": "    if (tid == 0)\n", "37": "      x = 0;\n", "38": "    if (tid == 0)\n", "40": "      omp_unset_lock(&l0);\n", "41": "      omp_set_lock(&l1);\n", "42": "    }\n", "43": "    else if (tid == 1)\n", "45": "      omp_set_lock(&l0);\n", "46": "      omp_unset_lock(&l1);\n", "47": "    }\n", "48": "    if (tid == 1)\n", "49": "      x = 1;\n", "50": "#pragma omp barrier\n", "51": "    if (tid == 0)\n", "52": "      omp_unset_lock(&l1);\n", "53": "    else if (tid == 1)\n", "54": "      omp_unset_lock(&l0);\n", "55": "  } // end of parallel construct\n"}}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  return 0;\n}\n\n", "targets": {"64": "    for (j=1;j<m;j++)\n", "63": "#pragma omp parallel for\n", "65": "      b[i][j]=b[i][j-1];\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define N 100\n#define C 8\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  #pragma omp parallel\n  {\n    for(int i=0; i<N ;i++){\n      #pragma omp for\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp for\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf(\"expected %d real %d \\n\",val, b[i]);\n      return 0;\n    }\n  }\n\n  return 0;\n}\n", "targets": {"37": "  {\n", "38": "    for(int i=0; i<N ;i++){\n", "40": "      for(int i=0; i<C; i++){\n", "39": "      #pragma omp for\n", "41": "        temp[i] = b[i] + c[i];\n", "42": "      }\n", "45": "      for(int i=C-1; i>=0; i--){\n", "44": "      #pragma omp for\n", "46": "        b[i] = temp[i] * a;\n", "47": "      }\n", "48": "    }\n", "49": "  }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n  int section_count = 0;\n  omp_set_dynamic(0);\n  \n  omp_set_num_threads(1);\n\n  #pragma omp parallel\n  #pragma omp sections firstprivate( section_count )\n  {\n    #pragma omp section\n    {\n      section_count++;\n      printf(\"%d\\n\",section_count);\n    }\n    #pragma omp section\n    {\n      section_count++;\n      printf(\"%d\\n\",section_count);\n    }\n  }\n  return 0;\n}\n", "targets": {"27": "  #pragma omp sections firstprivate( section_count )\n", "31": "      section_count++;\n", "32": "      printf(\"%d\\n\",section_count);\n", "29": "    #pragma omp section\n", "36": "      section_count++;\n", "37": "      printf(\"%d\\n\",section_count);\n", "34": "    #pragma omp section\n"}}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  return 0;\n} \n", "targets": {"66": "  for (i=0;i< len -1 ;i++)\n", "65": "#pragma omp parallel for\n", "67": "    a[i]=a[i+1]+1;\n"}}, {"prompt": "", "targets": {"58": "  for (i=0;i<n;i++)\n", "57": "#pragma omp parallel for private(j)\n", "59": "    for (j=0;j<m-1;j++) // Be careful about bounds of j\n", "60": "      b[i][j]=b[i][j+1];\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  int len = 20000;\n\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[len], b[len];\n\n  for (int i = 0; i < len; i++) {\n    a[i] = i;\n    b[i] = i + 1;\n  }\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len; i++)\n    a[i] = a[i] + b[i];\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n\n  return 0;\n}\n", "targets": {"30": "  for (int i = 0; i < len; i++)\n", "31": "    a[i] = a[i] + b[i];\n", "29": "#pragma omp parallel for simd schedule(dynamic, 64)\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n    tp=2;\n  }\n\n  if(var==2) printf(\"%d\\n\",var);\n  return 0;\n}\n", "targets": {"31": "      #pragma omp task\n", "32": "      {\n", "28": "    #pragma omp task\n", "29": "    {\n", "30": "      tp = 1;\n", "34": "      var = tp;\n", "26": "  #pragma omp task\n", "27": "  {\n", "36": "    tp=2;\n"}}, {"prompt": "#include <stdio.h>\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp critical(A)\n      {\n        s = 1;\n      }\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp critical(B)\n        {\n          if (s)\n            done = 1;\n        }\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n", "targets": {"24": "  {\n", "23": "#pragma omp parallel sections shared(x, s) num_threads(2)\n", "27": "      x = 1;\n", "28": "#pragma omp critical(A)\n", "30": "        s = 1;\n", "31": "      }\n", "25": "#pragma omp section\n", "35": "      int done = 0;\n", "36": "      while (!done)\n", "38": "#pragma omp critical(B)\n", "40": "          if (s)\n", "41": "            done = 1;\n", "42": "        }\n", "44": "      x = 2;\n", "33": "#pragma omp section\n", "46": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      sum0=sum0+i;\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n  /*  reference calculation */\n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n", "targets": {"63": "  {\n", "62": "#pragma omp parallel copyin(sum0)\n", "65": "    for (i=0;i<len;i++)\n", "64": "#pragma omp for\n", "67": "      sum0=sum0+i;\n", "68": "    }   \n", "69": "#pragma omp critical\n", "71": "      sum= sum+sum0;\n", "72": "    } \n", "73": "  }  \n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int i,j,k,m;\n  double tmp1;\n\n  double a[12][12][12];\n\n  m = 3.0;\n\n  #pragma omp parallel for private(j,k,tmp1)   \n  for (i = 0; i < 12; i++) {\n    for (j = 0; j < 12; j++) {\n      for (k = 0; k < 12; k++) {\n        tmp1 = 6.0/m;\n        a[i][j][k] = tmp1+4;\n      }\n    }\n  }\n\n  return 0;\n}\n\n", "targets": {"27": "  for (i = 0; i < 12; i++) {\n", "26": "  #pragma omp parallel for private(j,k,tmp1)   \n", "28": "    for (j = 0; j < 12; j++) {\n", "29": "      for (k = 0; k < 12; k++) {\n", "30": "        tmp1 = 6.0/m;\n", "31": "        a[i][j][k] = tmp1+4;\n", "32": "      }\n", "33": "    }\n", "34": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  int var = 0;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf(\"%d\\n \",var);\n  return 0;\n}\n", "targets": {"26": "  #pragma omp distribute parallel for\n", "27": "  for (int i=0; i<N; i++){\n", "28": "    var++;\n", "29": "  }\n"}}, {"prompt": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 533, 525, 527, 529, 531, // 521+12=533\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for // default static even scheduling may not trigger data race!\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n", "targets": {"125": "  for (i =0; i< N; ++i) \n", "124": "#pragma omp parallel for // default static even scheduling may not trigger data race!\n", "127": "    int idx = indexSet[i];\n", "128": "    xa1[idx]+= 1.0;\n", "129": "    xa2[idx]+= 3.0;\n", "130": "  }\n"}}, {"prompt": "#include<stdio.h>\n#include<assert.h>\n/*  argument pass-by-value */\nvoid f1(int q)\n{\n  q += 1;\n}\n\nint main()\n{\n  int i=0;\n  #pragma omp parallel \n  {\n     f1(i);\n  }\n  assert (i==0);\n  printf (\"i=%d\\n\",i);\n  return 0;\n}\n\n", "targets": {"64": "  {\n", "65": "     f1(i);\n", "66": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <assert.h>\n\nint sum0=0, sum1=0;\n#pragma omp threadprivate(sum0)\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int len=1000;\n  int i, sum=0;\n#pragma omp parallel copyin(sum0)\n  {\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n/*  reference calculation */\n  for (i=0;i<len;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n  assert(sum==sum1);\n  return 0;\n}\n\n", "targets": {"67": "  {\n", "66": "#pragma omp parallel copyin(sum0)\n", "69": "    for (i=0;i<len;i++)\n", "68": "#pragma omp for\n", "71": "       foo (i);\n", "72": "    }   \n", "73": "#pragma omp critical\n", "75": "      sum= sum+sum0;\n", "76": "    } \n", "77": "  }  \n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var) \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=100){\n      printf(\"%d\\n\",var[i]);\n    }\n  }\n\n  return 0;\n}\n", "targets": {"28": "  for (int i=0; i<N; i++){\n", "27": "  #pragma omp teams distribute parallel for reduction(+:var) \n", "33": "  }\n", "30": "    for(int i=0; i<C; i++){\n", "29": "    #pragma omp simd\n", "31": "      var[i]++;\n", "32": "    }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid load_from_input(int *data, int size)\n{\n  for(int i = 0; i < size; i++) {\n    data[i] = size-i;\n  } \n}\n\n\nint main(int argc, char *argv[]) {\n\n  int *A; \n  int N = 100;\n\n  if (argc>1)\n    N = atoi(argv[1]);\n\n  A = (int*) malloc(sizeof(int) * N);\n\n  load_from_input(A, N);\n  \n#pragma omp parallel for shared(A)\n  for(int i = 0; i < N; i++) {\n    A[i] = i;\n    if (N > 10000) \n    { \n      A[0] = 1; \n    }\n  }\n\n  free(A);\n  return 0;\n}\n", "targets": {"41": "  for(int i = 0; i < N; i++) {\n", "40": "#pragma omp parallel for shared(A)\n", "42": "    A[i] = i;\n", "43": "    if (N > 10000) \n", "45": "      A[0] = 1; \n", "46": "    }\n", "47": "  }\n"}}, {"prompt": "#include <stdio.h>\nint main(int argc, char** argv)\n{\n  double pi = 0.0;\n  long int i;\n  double x, interval_width;\n  interval_width = 1.0/(double)num_steps;\n\n#pragma omp parallel for reduction(+:pi) private(x)\n  for (i = 0; i < num_steps; i++) {\n    x = (i+ 0.5) * interval_width;\n    pi += 1.0 / (x*x + 1.0);\n  }\n\n  pi = pi * 4.0 * interval_width;\n  printf (\"PI=%f\\n\", pi);\n  return 0;\n}\n", "targets": {"62": "  for (i = 0; i < num_steps; i++) {\n", "61": "#pragma omp parallel for reduction(+:pi) private(x)\n", "63": "    x = (i+ 0.5) * interval_width;\n", "64": "    pi += 1.0 / (x*x + 1.0);\n", "65": "  }\n"}}, {"prompt": "", "targets": {"63": "    for (j=1;j<m;j++)\n", "62": "#pragma omp parallel for\n", "64": "      b[i][j]=b[i-1][j-1];\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l);\n#pragma omp barrier\n    if (tid == 0)\n    {\n      x = 0;\n      omp_unset_lock(&l);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l);\n      omp_unset_lock(&l);\n      x = 1;\n    }\n#pragma omp barrier\n  } // end of parallel construct\n  omp_destroy_lock(&l);\n  printf(\"Done: x=%d\\n\", x);\n}", "targets": {"29": "    int tid = omp_get_thread_num();\n", "30": "    if (tid == 0)\n", "31": "      omp_set_lock(&l);\n", "32": "#pragma omp barrier\n", "33": "    if (tid == 0)\n", "35": "      x = 0;\n", "36": "      omp_unset_lock(&l);\n", "37": "    }\n", "38": "    else if (tid == 1)\n", "40": "      omp_set_lock(&l);\n", "41": "      omp_unset_lock(&l);\n", "42": "      x = 1;\n", "43": "    }\n", "44": "#pragma omp barrier\n", "45": "  } // end of parallel construct\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  if (argc>1)\n    inLen= atoi(argv[1]);\n\n  int input[inLen]; \n  int output[inLen];\n  for (i=0; i<inLen; ++i) \n    input[i]=i; \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf(\"output[0]=%d\\n\", output[0]);\n  return 0;\n}\n", "targets": {"72": "  for (i=0; i<inLen; ++i) {\n", "71": "#pragma omp parallel for\n", "73": "    output[outLen++] = input[i] ;\n", "74": "  }  \n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int i = 1;\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      #pragma omp critical (name)\n      {\n        #pragma omp parallel\n        {\n          #pragma omp single\n          {\n            i++;\n          }\n        }\n      }\n    }\n  }\n\n  printf(\"%d\\n\",i);\n  return 0;\n}\n", "targets": {"28": "  {\n", "27": "  #pragma omp parallel sections\n", "31": "      #pragma omp critical (name)\n", "33": "        #pragma omp parallel\n", "40": "      }\n", "29": "    #pragma omp section\n", "42": "  }\n", "34": "        {\n", "35": "          #pragma omp single\n", "37": "            i++;\n", "38": "          }\n", "39": "        }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n    }\n\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n    }\n  }\n\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n", "targets": {"25": "#pragma omp single\n", "27": "#pragma omp task depend(inout : a) shared(a)\n", "33": "#pragma omp task depend(inout : a) shared(a)\n", "38": "  }\n", "29": "#pragma omp task depend(inout : a) shared(a)\n", "30": "      a++;\n", "28": "    {\n", "35": "#pragma omp task depend(inout : a) shared(a)\n", "36": "      a++;\n", "34": "    {\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef long long num_sz;\n\nint max_num_blocks;\nint num_refine;\nint num_vars;\nint x_block_size, y_block_size, z_block_size;\nint error_tol;\n\ndouble tol;\n\ntypedef struct {\n   num_sz number;\n   int level;\n   int refine;\n   int new_proc;\n   num_sz parent;       // if original block -1,\n                     // else if on node, number in structure\n                     // else (-2 - parent->number)\n   double ****array;\n} block;\n\nblock *blocks;\n\nvoid stencil_calc(int var, int stencil_in)\n{\n   int i, j, k, in;\n   double sb, sm, sf, work[x_block_size+2][y_block_size+2][z_block_size+2];\n   block *bp;\n\n   int tid;\n\n#pragma omp parallel default(shared) private(i, j, k, bp)\n  {\n      for (in = 0; in < max_num_blocks; ++in) {\n         bp = &blocks[in];\n         for (i = 1; i <= x_block_size; i++)\n            for (j = 1; j <= y_block_size; j++)\n               for (k = 1; k <= z_block_size; k++)\n                  work[i][j][k] = (bp->array[var][i-1][j  ][k  ] +\n                                   bp->array[var][i  ][j-1][k  ] +\n                                   bp->array[var][i  ][j  ][k-1] +\n                                   bp->array[var][i  ][j  ][k  ] +\n                                   bp->array[var][i  ][j  ][k+1] +\n                                   bp->array[var][i  ][j+1][k  ] +\n                                   bp->array[var][i+1][j  ][k  ])/7.0;\n         for (i = 1; i <= x_block_size; i++)\n            for (j = 1; j <= y_block_size; j++)\n               for (k = 1; k <= z_block_size; k++)\n                  bp->array[var][i][j][k] = work[i][j][k];\n      }\n  }\n}\n\n\nvoid allocate(void)\n{\n   int i, j, k, m, n;\n\n   blocks = (block *) malloc(max_num_blocks*sizeof(block));\n\n   for (n = 0; n < max_num_blocks; n++) {\n      blocks[n].number = -1;\n      blocks[n].array = (double ****) malloc(num_vars*sizeof(double ***));\n      for (m = 0; m < num_vars; m++) {\n         blocks[n].array[m] = (double ***)\n                              malloc((x_block_size+2)*sizeof(double **));\n         for (i = 0; i < x_block_size+2; i++) {\n            blocks[n].array[m][i] = (double **)\n                                   malloc((y_block_size+2)*sizeof(double *));\n            for (j = 0; j < y_block_size+2; j++)\n               blocks[n].array[m][i][j] = (double *)\n                                     malloc((z_block_size+2)*sizeof(double));\n         }\n      }\n   }\n}\n\nvoid deallocate(void)\n{\n   int i, j, m, n;\n\n   for (n = 0; n < max_num_blocks; n++) {\n      for (m = 0; m < num_vars; m++) {\n         for (i = 0; i < x_block_size+2; i++) {\n            for (j = 0; j < y_block_size+2; j++)\n               free(blocks[n].array[m][i][j]);\n            free(blocks[n].array[m][i]);\n         }\n         free(blocks[n].array[m]);\n      }\n      free(blocks[n].array);\n   }\n   free(blocks);\n}\n\nvoid init(void)\n{\n   int n, var, i, j, k, l, m, o, size, dir, i1, i2, j1, j2, k1, k2, ib, jb, kb;\n   num_sz num;\n   block *bp;\n\n\n   /* Determine position of each core in initial mesh */\n   // initialize\n   for (o = n = k1 = k = 0; k < 1; k++)\n      for (k2 = 0; k2 < 1; k1++, k2++)\n         for (j1 = j = 0; j < 1; j++)\n            for (j2 = 0; j2 < 1; j1++, j2++)\n               for (i1 = i = 0; i < 1; i++)\n                  for (i2 = 0; i2 < 1; i1++, i2++, n++) {\n                     bp = &blocks[o];\n                     bp->level = 0;\n                     bp->number = n;\n                     //add_sorted_list(o, n, 0);\n                     for (var = 0; var < num_vars; var++)\n                        for (ib = 1; ib <= x_block_size; ib++)\n                           for (jb = 1; jb <= y_block_size; jb++)\n                              for (kb = 1; kb <= z_block_size; kb++)\n                                 bp->array[var][ib][jb][kb] =\n                                    ((double) rand())/((double) RAND_MAX);\n                    o++;\n                  }\n}\n\n\n\nvoid driver(void)\n{\n  int start, number, var;\n\n  init();\n\n  for (var = 0; var < num_vars; var ++) {\n     stencil_calc(var, 7);\n  }\n}\n\n\nint main(int argc, char* argv[])\n{   \n  max_num_blocks = 500;\n  num_refine = 5;\n  num_vars = 40;\n  x_block_size = 10;\n  y_block_size = 10;\n  z_block_size = 10;\n\n  allocate();\n \n  driver();\n\n  deallocate();\n  return 0;\n} \n", "targets": {"59": "  {\n", "60": "      for (in = 0; in < max_num_blocks; ++in) {\n", "61": "         bp = &blocks[in];\n", "62": "         for (i = 1; i <= x_block_size; i++)\n", "63": "            for (j = 1; j <= y_block_size; j++)\n", "64": "               for (k = 1; k <= z_block_size; k++)\n", "65": "                  work[i][j][k] = (bp->array[var][i-1][j  ][k  ] +\n", "66": "                                   bp->array[var][i  ][j-1][k  ] +\n", "67": "                                   bp->array[var][i  ][j  ][k-1] +\n", "68": "                                   bp->array[var][i  ][j  ][k  ] +\n", "69": "                                   bp->array[var][i  ][j  ][k+1] +\n", "70": "                                   bp->array[var][i  ][j+1][k  ] +\n", "71": "                                   bp->array[var][i+1][j  ][k  ])/7.0;\n", "72": "         for (i = 1; i <= x_block_size; i++)\n", "73": "            for (j = 1; j <= y_block_size; j++)\n", "74": "               for (k = 1; k <= z_block_size; k++)\n", "75": "                  bp->array[var][i][j][k] = work[i][j][k];\n", "76": "      }\n", "77": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n    int thrd = omp_get_thread_num();\n    if (thrd == 0) {\n      #pragma omp critical\n      { x = 10; }\n      #pragma omp atomic write\n      y = 1;\n    } else {\n      int tmp = 0;\n      while (tmp == 0) {\n        #pragma omp atomic read acquire\n        tmp = y;\n    }\n    #pragma omp critical\n    { if (x!=10) printf(\"x = %d\\n\", x); }\n    }\n  }\n  return 0;\n}\n", "targets": {"30": "  {\n", "31": "    int thrd = omp_get_thread_num();\n", "32": "    if (thrd == 0) {\n", "33": "      #pragma omp critical\n", "34": "      { x = 10; }\n", "36": "      y = 1;\n", "37": "    } else {\n", "38": "      int tmp = 0;\n", "39": "      while (tmp == 0) {\n", "41": "        tmp = y;\n", "43": "    #pragma omp critical\n", "44": "    { if (x!=10) printf(\"x = %d\\n\", x); }\n", "46": "  }\n"}}, {"prompt": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 533, // 521+12=533\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for // default static even scheduling may not trigger data race!\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n", "targets": {"125": "  for (i =0; i< N; ++i) \n", "124": "#pragma omp parallel for // default static even scheduling may not trigger data race!\n", "127": "    int idx = indexSet[i];\n", "128": "    xa1[idx]+= 1.0;\n", "129": "    xa2[idx]+= 3.0;\n", "130": "  }\n"}}, {"prompt": "#include <stdio.h>\n\nvoid foo()\n{\n  int i,x;\n#pragma omp parallel for private (i) lastprivate (x)\n  for (i=0;i<100;i++)\n    x=i;\n  printf(\"x=%d\",x);\n}\n\nint main()\n{\n  foo();\n  return 0;\n}\n\n", "targets": {"60": "  for (i=0;i<100;i++)\n", "59": "#pragma omp parallel for private (i) lastprivate (x)\n", "61": "    x=i;\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0, i, res;\n  int sum1 = 0;\n  int sum2 = 0;\n\n  res = omp_get_max_threads();\n\n  #pragma omp parallel reduction(+: var)\n  {\n    #pragma omp for schedule(static) reduction(+: sum1)\n    for (i=0; i<5; i++)\n    sum1+=i;\n    #pragma omp for schedule(static) reduction(+: sum2)\n    for (i=0; i<5; i++)\n    sum2+=i;\n\n    var = sum1 + sum2;\n  }\n\n  int error = (var != 20*res);\n  if (error) printf(\"%d %d\\n\",var,20*res);\n  return error;\n}\n", "targets": {"29": "  {\n", "28": "  #pragma omp parallel reduction(+: var)\n", "31": "    for (i=0; i<5; i++)\n", "30": "    #pragma omp for schedule(static) reduction(+: sum1)\n", "32": "    sum1+=i;\n", "34": "    for (i=0; i<5; i++)\n", "33": "    #pragma omp for schedule(static) reduction(+: sum2)\n", "35": "    sum2+=i;\n", "37": "    var = sum1 + sum2;\n", "38": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <assert.h>\n#include <unistd.h>\n#include \"signaling.h\"\n\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskgroup\n      {\n#pragma omp task\n        {\n          delay(10000);\n          result = 1; \n        }\n      }\n#pragma omp task\n      {\n        result = 2; \n      }\n    }\n  }\n  printf (\"result=%d\\n\", result);\n  assert (result==2);\n  return 0;\n}\n", "targets": {"59": "  {\n", "60": "#pragma omp single\n", "62": "#pragma omp taskgroup\n", "64": "#pragma omp task\n", "69": "      }\n", "70": "#pragma omp task\n", "74": "    }\n", "75": "  }\n", "65": "        {\n", "66": "          delay(10000);\n", "67": "          result = 1; \n", "71": "      {\n", "72": "        result = 2; \n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n\n  #pragma omp parallel shared(var)\n  {\n    #pragma omp single\n    var++;\n\n    #pragma omp barrier\n\n    #pragma omp single\n    var++;\n  }\n\n  if(var != 2) printf(\"%d\\n\",var);\n  int error = (var != 2);\n  return error;\n}\n", "targets": {"23": "  {\n", "24": "    #pragma omp single\n", "25": "    var++;\n", "27": "    #pragma omp barrier\n", "29": "    #pragma omp single\n", "30": "    var++;\n", "31": "  }\n"}}, {"prompt": "", "targets": {"58": "  for (i=0;i<100;i++)\n", "57": "#pragma omp parallel for\n", "59": "    a[i]=a[i]+1;\n"}}, {"prompt": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 4000. */\n#include \"polybench/3mm.h\"\n/* Array initialization. */\n\nstatic void init_array(int ni,int nj,int nk,int nl,int nm,double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c2;\n    int c1;\n    if (nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) < nm + -1?((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)) < nm + -1?((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nl > nm?nl : nm); c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((((nk + -1 < nl + -1?nk + -1 : nl + -1)) < nm + -1?((nk + -1 < nl + -1?nk + -1 : nl + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nj > nl?nj : nl)) > nm?((nj > nl?nj : nl)) : nm); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= ((((nj + -1 < nl + -1?nj + -1 : nl + -1)) < nm + -1?((nj + -1 < nl + -1?nj + -1 : nl + -1)) : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nk > nl?nk : nl); c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nk > nm?nk : nm); c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nk > nl?nk : nl)) > nm?((nk > nl?nk : nl)) : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = (nj > nk?nj : nk); c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (((nj > nk?nj : nk)) > nl?((nj > nk?nj : nk)) : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) < nm + -1?((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nk > nm?nk : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = (nj > nk?nj : nk); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nm; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nj; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nj; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nm?nj : nm); c1 <= ((ni + -1 < nk + -1?ni + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj <= 0 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nj <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > nm?0 : nm); c1 <= ((ni + -1 < nk + -1?ni + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nm + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nk; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nk > nl?nk : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nm + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nk; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nk > nm?nk : nm); c1 <= ((ni + -1 < nj + -1?ni + -1 : nj + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = nk; c1 <= ((ni + -1 < nj + -1?ni + -1 : nj + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nk?nj : nk); c1 <= ((ni + -1 < nm + -1?ni + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n        for (c2 = nk; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (nj > nk?nj : nk); c1 <= ((ni + -1 < nm + -1?ni + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nk >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c1 <= ni + -1; c1++) {\n        for (c2 = 0; c2 <= nk + -1; c2++) {\n          A[c1][c2] = ((double )c1) * c2 / ni;\n        }\n      }\n    }\n    if (nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((((nj + -1 < nl + -1?nj + -1 : nl + -1)) < nm + -1?((nj + -1 < nl + -1?nj + -1 : nl + -1)) : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nl > nm?nl : nm); c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = (nj > nl?nj : nl); c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = (nj > nm?nj : nm); c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nm?ni : nm); c1 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nm <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nj?ni : nj); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n        for (c2 = nj; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nj >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nj?ni : nj); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nj?ni : nj)) > nm?((ni > nj?ni : nj)) : nm); c1 <= nk + -1; c1++) {\n        for (c2 = 0; c2 <= nj + -1; c2++) {\n          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nk?ni : nk); c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = (ni > nk?ni : nk); c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk >= 1 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nk?ni : nk)) > nm?((ni > nk?ni : nk)) : nm); c1 <= nj + -1; c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n        for (c2 = nl; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n        for (c2 = nm; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk <= 0 && nl <= 0) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nk <= 0 && nm >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = nm; c1 <= nj + -1; c1++) {\n        for (c2 = 0; c2 <= nm + -1; c2++) {\n          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n        }\n      }\n    }\n    if (nj <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > ni?0 : ni); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk >= 1 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (((ni > nj?ni : nj)) > nk?((ni > nj?ni : nj)) : nk); c1 <= nm + -1; c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n    if (nk <= 0 && nl >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = (0 > nj?0 : nj); c1 <= nm + -1; c1++) {\n        for (c2 = 0; c2 <= nl + -1; c2++) {\n          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int ni,int nl,double G[128 + 0][128 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < ni; i++) \n    for (j = 0; j < nl; j++) {\n      fprintf(stderr,\"%0.2lf \",G[i][j]);\n      if ((i * ni + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[128 + 0][128 + 0],double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double F[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0],double G[128 + 0][128 + 0])\n{\n  //int i;\n  //int j;\n  //int k;\n  \n  //#pragma scop\n{\n    int c1;\n    int c2;\n    int c5;\n#pragma omp parallel for private(c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        G[c1][c2] = 0;\n        F[c1][c2] = 0;\n      }\n    }\n#pragma omp parallel for private(c5, c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        for (c5 = 0; c5 <= 127; c5++) {\n          F[c1][c2] += C[c1][c5] * D[c5][c2];\n        }\n      }\n    }\n#pragma omp parallel for private(c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        E[c1][c2] = 0;\n      }\n    }\n#pragma omp parallel for private(c5, c2)\n    for (c1 = 0; c1 <= 127; c1++) {\n      for (c2 = 0; c2 <= 127; c2++) {\n        for (c5 = 0; c5 <= 127; c5++) {\n          E[c1][c2] += A[c1][c5] * B[c5][c2];\n        }\n        for (c5 = 0; c5 <= 127; c5++) {\n          G[c1][c5] += E[c1][c2] * F[c2][c5];\n        }\n      }\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int ni = 128;\n  int nj = 128;\n  int nk = 128;\n  int nl = 128;\n  int nm = 128;\n/* Variable declaration/allocation. */\n  double (*E)[128 + 0][128 + 0];\n  E = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[128 + 0][128 + 0];\n  A = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[128 + 0][128 + 0];\n  B = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*F)[128 + 0][128 + 0];\n  F = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*C)[128 + 0][128 + 0];\n  C = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*D)[128 + 0][128 + 0];\n  D = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*G)[128 + 0][128 + 0];\n  G = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(ni,nj,nk,nl,nm, *A, *B, *C, *D);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_3mm(ni,nj,nk,nl,nm, *E, *A, *B, *F, *C, *D, *G);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(ni,nl, *G);\n/* Be clean. */\n  free(((void *)E));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  free(((void *)F));\n  ;\n  free(((void *)C));\n  ;\n  free(((void *)D));\n  ;\n  free(((void *)G));\n  ;\n  return 0;\n}\n", "targets": {"29": "      for (c1 = 0; c1 <= ((((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) < nm + -1?((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) : nm + -1)); c1++) {\n", "28": "#pragma omp parallel for private(c2)\n", "30": "        for (c2 = 0; c2 <= ((((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)) < nm + -1?((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)) : nm + -1)); c2++) {\n", "31": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "32": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "33": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "34": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "35": "        }\n", "36": "        for (c2 = nl; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c2++) {\n", "37": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "38": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "39": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "40": "        }\n", "41": "        for (c2 = nm; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nl + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nl + -1)); c2++) {\n", "42": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "43": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "44": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "45": "        }\n", "46": "        for (c2 = (nl > nm?nl : nm); c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n", "47": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "48": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "49": "        }\n", "50": "        for (c2 = nj; c2 <= ((((nk + -1 < nl + -1?nk + -1 : nl + -1)) < nm + -1?((nk + -1 < nl + -1?nk + -1 : nl + -1)) : nm + -1)); c2++) {\n", "51": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "52": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "53": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "54": "        }\n", "55": "        for (c2 = (nj > nl?nj : nl); c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n", "56": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "57": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "58": "        }\n", "59": "        for (c2 = (nj > nm?nj : nm); c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n", "60": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "61": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "62": "        }\n", "63": "        for (c2 = (((nj > nl?nj : nl)) > nm?((nj > nl?nj : nl)) : nm); c2 <= nk + -1; c2++) {\n", "64": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "65": "        }\n", "66": "        for (c2 = nk; c2 <= ((((nj + -1 < nl + -1?nj + -1 : nl + -1)) < nm + -1?((nj + -1 < nl + -1?nj + -1 : nl + -1)) : nm + -1)); c2++) {\n", "67": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "68": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "69": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "70": "        }\n", "71": "        for (c2 = (nk > nl?nk : nl); c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n", "72": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "73": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "74": "        }\n", "75": "        for (c2 = (nk > nm?nk : nm); c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n", "76": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "77": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "78": "        }\n", "79": "        for (c2 = (((nk > nl?nk : nl)) > nm?((nk > nl?nk : nl)) : nm); c2 <= nj + -1; c2++) {\n", "80": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "81": "        }\n", "82": "        for (c2 = (nj > nk?nj : nk); c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n", "83": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "84": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "85": "        }\n", "86": "        for (c2 = (((nj > nk?nj : nk)) > nl?((nj > nk?nj : nk)) : nl); c2 <= nm + -1; c2++) {\n", "87": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "88": "        }\n", "89": "        for (c2 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c2 <= nl + -1; c2++) {\n", "90": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "91": "        }\n", "92": "      }\n", "96": "      for (c1 = 0; c1 <= ((((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) < nm + -1?((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)) : nm + -1)); c1++) {\n", "95": "#pragma omp parallel for private(c2)\n", "97": "        for (c2 = 0; c2 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c2++) {\n", "98": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "99": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "100": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "101": "        }\n", "102": "        for (c2 = nm; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n", "103": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "104": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "105": "        }\n", "106": "        for (c2 = nj; c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n", "107": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "108": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "109": "        }\n", "110": "        for (c2 = (nj > nm?nj : nm); c2 <= nk + -1; c2++) {\n", "111": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "112": "        }\n", "113": "        for (c2 = nk; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n", "114": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "115": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "116": "        }\n", "117": "        for (c2 = (nk > nm?nk : nm); c2 <= nj + -1; c2++) {\n", "118": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "119": "        }\n", "120": "        for (c2 = (nj > nk?nj : nk); c2 <= nm + -1; c2++) {\n", "121": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "122": "        }\n", "123": "      }\n", "127": "      for (c1 = nm; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)); c1++) {\n", "126": "#pragma omp parallel for private(c2)\n", "128": "        for (c2 = 0; c2 <= nm + -1; c2++) {\n", "129": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "130": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "131": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "132": "        }\n", "133": "        for (c2 = nm; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n", "134": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "135": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "136": "        }\n", "137": "        for (c2 = nj; c2 <= nk + -1; c2++) {\n", "138": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "139": "        }\n", "140": "        for (c2 = nk; c2 <= nj + -1; c2++) {\n", "141": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "142": "        }\n", "143": "      }\n", "147": "      for (c1 = 0; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nk + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nk + -1)); c1++) {\n", "146": "#pragma omp parallel for private(c2)\n", "148": "        for (c2 = 0; c2 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c2++) {\n", "149": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "150": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "151": "        }\n", "152": "        for (c2 = nj; c2 <= nk + -1; c2++) {\n", "153": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "154": "        }\n", "155": "        for (c2 = nk; c2 <= nj + -1; c2++) {\n", "156": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "157": "        }\n", "158": "      }\n", "162": "      for (c1 = nj; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n", "161": "#pragma omp parallel for private(c2)\n", "163": "        for (c2 = 0; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n", "164": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "165": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "166": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "167": "        }\n", "168": "        for (c2 = nl; c2 <= nj + -1; c2++) {\n", "169": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "170": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "171": "        }\n", "172": "        for (c2 = nj; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n", "173": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "174": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "175": "        }\n", "176": "        for (c2 = (nj > nl?nj : nl); c2 <= nk + -1; c2++) {\n", "177": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "178": "        }\n", "179": "        for (c2 = nk; c2 <= nl + -1; c2++) {\n", "180": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "181": "        }\n", "182": "      }\n", "186": "      for (c1 = nj; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n", "185": "#pragma omp parallel for private(c2)\n", "187": "        for (c2 = 0; c2 <= nj + -1; c2++) {\n", "188": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "189": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "190": "        }\n", "191": "        for (c2 = nj; c2 <= nk + -1; c2++) {\n", "192": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "193": "        }\n", "194": "      }\n", "198": "      for (c1 = (nj > nm?nj : nm); c1 <= ((ni + -1 < nk + -1?ni + -1 : nk + -1)); c1++) {\n", "197": "#pragma omp parallel for private(c2)\n", "199": "        for (c2 = 0; c2 <= nj + -1; c2++) {\n", "200": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "201": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "202": "        }\n", "203": "        for (c2 = nj; c2 <= nk + -1; c2++) {\n", "204": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "205": "        }\n", "206": "      }\n", "210": "      for (c1 = 0; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n", "209": "#pragma omp parallel for private(c2)\n", "211": "        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n", "212": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "213": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "214": "        }\n", "215": "        for (c2 = nl; c2 <= nk + -1; c2++) {\n", "216": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "217": "        }\n", "218": "        for (c2 = nk; c2 <= nl + -1; c2++) {\n", "219": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "220": "        }\n", "221": "      }\n", "225": "      for (c1 = 0; c1 <= ((((ni + -1 < nk + -1?ni + -1 : nk + -1)) < nm + -1?((ni + -1 < nk + -1?ni + -1 : nk + -1)) : nm + -1)); c1++) {\n", "224": "#pragma omp parallel for private(c2)\n", "226": "        for (c2 = 0; c2 <= nk + -1; c2++) {\n", "227": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "228": "        }\n", "229": "      }\n", "233": "      for (c1 = (0 > nm?0 : nm); c1 <= ((ni + -1 < nk + -1?ni + -1 : nk + -1)); c1++) {\n", "232": "#pragma omp parallel for private(c2)\n", "234": "        for (c2 = 0; c2 <= nk + -1; c2++) {\n", "235": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "236": "        }\n", "237": "      }\n", "241": "      for (c1 = nk; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nm + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nm + -1)); c1++) {\n", "240": "#pragma omp parallel for private(c2)\n", "242": "        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n", "243": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "244": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "245": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "246": "        }\n", "247": "        for (c2 = nl; c2 <= nk + -1; c2++) {\n", "248": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "249": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "250": "        }\n", "251": "        for (c2 = nk; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n", "252": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "253": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "254": "        }\n", "255": "        for (c2 = (nk > nl?nk : nl); c2 <= nm + -1; c2++) {\n", "256": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "257": "        }\n", "258": "        for (c2 = nm; c2 <= nl + -1; c2++) {\n", "259": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "260": "        }\n", "261": "      }\n", "265": "      for (c1 = nk; c1 <= ((((ni + -1 < nj + -1?ni + -1 : nj + -1)) < nm + -1?((ni + -1 < nj + -1?ni + -1 : nj + -1)) : nm + -1)); c1++) {\n", "264": "#pragma omp parallel for private(c2)\n", "266": "        for (c2 = 0; c2 <= nk + -1; c2++) {\n", "267": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "268": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "269": "        }\n", "270": "        for (c2 = nk; c2 <= nm + -1; c2++) {\n", "271": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "272": "        }\n", "273": "      }\n", "277": "      for (c1 = (nk > nm?nk : nm); c1 <= ((ni + -1 < nj + -1?ni + -1 : nj + -1)); c1++) {\n", "276": "#pragma omp parallel for private(c2)\n", "278": "        for (c2 = 0; c2 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c2++) {\n", "279": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "280": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "281": "        }\n", "282": "        for (c2 = nm; c2 <= nk + -1; c2++) {\n", "283": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "284": "        }\n", "285": "        for (c2 = nk; c2 <= nm + -1; c2++) {\n", "286": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "287": "        }\n", "288": "      }\n", "292": "      for (c1 = nk; c1 <= ((ni + -1 < nj + -1?ni + -1 : nj + -1)); c1++) {\n", "291": "#pragma omp parallel for private(c2)\n", "293": "        for (c2 = 0; c2 <= nk + -1; c2++) {\n", "294": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "295": "        }\n", "296": "      }\n", "300": "      for (c1 = (nj > nk?nj : nk); c1 <= ((ni + -1 < nm + -1?ni + -1 : nm + -1)); c1++) {\n", "299": "#pragma omp parallel for private(c2)\n", "301": "        for (c2 = 0; c2 <= ((nk + -1 < nl + -1?nk + -1 : nl + -1)); c2++) {\n", "302": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "303": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "304": "        }\n", "305": "        for (c2 = nl; c2 <= nk + -1; c2++) {\n", "306": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "307": "        }\n", "308": "        for (c2 = nk; c2 <= nl + -1; c2++) {\n", "309": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "310": "        }\n", "311": "      }\n", "315": "      for (c1 = (nj > nk?nj : nk); c1 <= ((ni + -1 < nm + -1?ni + -1 : nm + -1)); c1++) {\n", "314": "#pragma omp parallel for private(c2)\n", "316": "        for (c2 = 0; c2 <= nk + -1; c2++) {\n", "317": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "318": "        }\n", "319": "      }\n", "323": "      for (c1 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c1 <= ni + -1; c1++) {\n", "322": "#pragma omp parallel for private(c2)\n", "324": "        for (c2 = 0; c2 <= nk + -1; c2++) {\n", "325": "          A[c1][c2] = ((double )c1) * c2 / ni;\n", "326": "        }\n", "327": "      }\n", "331": "      for (c1 = (0 > ni?0 : ni); c1 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c1++) {\n", "330": "#pragma omp parallel for private(c2)\n", "332": "        for (c2 = 0; c2 <= ((((nj + -1 < nl + -1?nj + -1 : nl + -1)) < nm + -1?((nj + -1 < nl + -1?nj + -1 : nl + -1)) : nm + -1)); c2++) {\n", "333": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "334": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "335": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "336": "        }\n", "337": "        for (c2 = nl; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n", "338": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "339": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "340": "        }\n", "341": "        for (c2 = nm; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n", "342": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "343": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "344": "        }\n", "345": "        for (c2 = (nl > nm?nl : nm); c2 <= nj + -1; c2++) {\n", "346": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "347": "        }\n", "348": "        for (c2 = nj; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n", "349": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "350": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "351": "        }\n", "352": "        for (c2 = (nj > nl?nj : nl); c2 <= nm + -1; c2++) {\n", "353": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "354": "        }\n", "355": "        for (c2 = (nj > nm?nj : nm); c2 <= nl + -1; c2++) {\n", "356": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "357": "        }\n", "358": "      }\n", "362": "      for (c1 = (0 > ni?0 : ni); c1 <= ((((nj + -1 < nk + -1?nj + -1 : nk + -1)) < nm + -1?((nj + -1 < nk + -1?nj + -1 : nk + -1)) : nm + -1)); c1++) {\n", "361": "#pragma omp parallel for private(c2)\n", "363": "        for (c2 = 0; c2 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c2++) {\n", "364": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "365": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "366": "        }\n", "367": "        for (c2 = nm; c2 <= nj + -1; c2++) {\n", "368": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "369": "        }\n", "370": "        for (c2 = nj; c2 <= nm + -1; c2++) {\n", "371": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "372": "        }\n", "373": "      }\n", "377": "      for (c1 = (ni > nm?ni : nm); c1 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c1++) {\n", "376": "#pragma omp parallel for private(c2)\n", "378": "        for (c2 = 0; c2 <= nm + -1; c2++) {\n", "379": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "380": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "381": "        }\n", "382": "        for (c2 = nm; c2 <= nj + -1; c2++) {\n", "383": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "384": "        }\n", "385": "      }\n", "389": "      for (c1 = (0 > ni?0 : ni); c1 <= ((nj + -1 < nk + -1?nj + -1 : nk + -1)); c1++) {\n", "388": "#pragma omp parallel for private(c2)\n", "390": "        for (c2 = 0; c2 <= nj + -1; c2++) {\n", "391": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "392": "        }\n", "393": "      }\n", "397": "      for (c1 = (ni > nj?ni : nj); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n", "396": "#pragma omp parallel for private(c2)\n", "398": "        for (c2 = 0; c2 <= ((nj + -1 < nl + -1?nj + -1 : nl + -1)); c2++) {\n", "399": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "400": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "401": "        }\n", "402": "        for (c2 = nl; c2 <= nj + -1; c2++) {\n", "403": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "404": "        }\n", "405": "        for (c2 = nj; c2 <= nl + -1; c2++) {\n", "406": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "407": "        }\n", "408": "      }\n", "412": "      for (c1 = (ni > nj?ni : nj); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n", "411": "#pragma omp parallel for private(c2)\n", "413": "        for (c2 = 0; c2 <= nj + -1; c2++) {\n", "414": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "415": "        }\n", "416": "      }\n", "420": "      for (c1 = (((ni > nj?ni : nj)) > nm?((ni > nj?ni : nj)) : nm); c1 <= nk + -1; c1++) {\n", "419": "#pragma omp parallel for private(c2)\n", "421": "        for (c2 = 0; c2 <= nj + -1; c2++) {\n", "422": "          B[c1][c2] = ((double )c1) * (c2 + 1) / nj;\n", "423": "        }\n", "424": "      }\n", "428": "      for (c1 = (ni > nk?ni : nk); c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n", "427": "#pragma omp parallel for private(c2)\n", "429": "        for (c2 = 0; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n", "430": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "431": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "432": "        }\n", "433": "        for (c2 = nl; c2 <= nm + -1; c2++) {\n", "434": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "435": "        }\n", "436": "        for (c2 = nm; c2 <= nl + -1; c2++) {\n", "437": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "438": "        }\n", "439": "      }\n", "443": "      for (c1 = (ni > nk?ni : nk); c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n", "442": "#pragma omp parallel for private(c2)\n", "444": "        for (c2 = 0; c2 <= nm + -1; c2++) {\n", "445": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "446": "        }\n", "447": "      }\n", "451": "      for (c1 = (((ni > nk?ni : nk)) > nm?((ni > nk?ni : nk)) : nm); c1 <= nj + -1; c1++) {\n", "450": "#pragma omp parallel for private(c2)\n", "452": "        for (c2 = 0; c2 <= nm + -1; c2++) {\n", "453": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "454": "        }\n", "455": "      }\n", "459": "      for (c1 = 0; c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n", "458": "#pragma omp parallel for private(c2)\n", "460": "        for (c2 = 0; c2 <= ((nl + -1 < nm + -1?nl + -1 : nm + -1)); c2++) {\n", "461": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "462": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "463": "        }\n", "464": "        for (c2 = nl; c2 <= nm + -1; c2++) {\n", "465": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "466": "        }\n", "467": "        for (c2 = nm; c2 <= nl + -1; c2++) {\n", "468": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "469": "        }\n", "470": "      }\n", "474": "      for (c1 = 0; c1 <= ((nj + -1 < nm + -1?nj + -1 : nm + -1)); c1++) {\n", "473": "#pragma omp parallel for private(c2)\n", "475": "        for (c2 = 0; c2 <= nm + -1; c2++) {\n", "476": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "477": "        }\n", "478": "      }\n", "482": "      for (c1 = nm; c1 <= nj + -1; c1++) {\n", "481": "#pragma omp parallel for private(c2)\n", "483": "        for (c2 = 0; c2 <= nm + -1; c2++) {\n", "484": "          C[c1][c2] = ((double )c1) * (c2 + 3) / nl;\n", "485": "        }\n", "486": "      }\n", "490": "      for (c1 = (0 > ni?0 : ni); c1 <= ((nk + -1 < nm + -1?nk + -1 : nm + -1)); c1++) {\n", "489": "#pragma omp parallel for private(c2)\n", "491": "        for (c2 = 0; c2 <= nl + -1; c2++) {\n", "492": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "493": "        }\n", "494": "      }\n", "498": "      for (c1 = (((ni > nj?ni : nj)) > nk?((ni > nj?ni : nj)) : nk); c1 <= nm + -1; c1++) {\n", "497": "#pragma omp parallel for private(c2)\n", "499": "        for (c2 = 0; c2 <= nl + -1; c2++) {\n", "500": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "501": "        }\n", "502": "      }\n", "506": "      for (c1 = (0 > nj?0 : nj); c1 <= nm + -1; c1++) {\n", "505": "#pragma omp parallel for private(c2)\n", "507": "        for (c2 = 0; c2 <= nl + -1; c2++) {\n", "508": "          D[c1][c2] = ((double )c1) * (c2 + 2) / nk;\n", "509": "        }\n", "510": "      }\n", "544": "    for (c1 = 0; c1 <= 127; c1++) {\n", "543": "#pragma omp parallel for private(c2)\n", "545": "      for (c2 = 0; c2 <= 127; c2++) {\n", "546": "        G[c1][c2] = 0;\n", "547": "        F[c1][c2] = 0;\n", "548": "      }\n", "549": "    }\n", "551": "    for (c1 = 0; c1 <= 127; c1++) {\n", "550": "#pragma omp parallel for private(c5, c2)\n", "552": "      for (c2 = 0; c2 <= 127; c2++) {\n", "553": "        for (c5 = 0; c5 <= 127; c5++) {\n", "554": "          F[c1][c2] += C[c1][c5] * D[c5][c2];\n", "555": "        }\n", "556": "      }\n", "557": "    }\n", "559": "    for (c1 = 0; c1 <= 127; c1++) {\n", "558": "#pragma omp parallel for private(c2)\n", "560": "      for (c2 = 0; c2 <= 127; c2++) {\n", "561": "        E[c1][c2] = 0;\n", "562": "      }\n", "563": "    }\n", "565": "    for (c1 = 0; c1 <= 127; c1++) {\n", "564": "#pragma omp parallel for private(c5, c2)\n", "566": "      for (c2 = 0; c2 <= 127; c2++) {\n", "567": "        for (c5 = 0; c5 <= 127; c5++) {\n", "568": "          E[c1][c2] += A[c1][c5] * B[c5][c2];\n", "569": "        }\n", "570": "        for (c5 = 0; c5 <= 127; c5++) {\n", "571": "          G[c1][c5] += E[c1][c2] * F[c2][c5];\n", "572": "        }\n", "573": "      }\n", "574": "    }\n"}}, {"prompt": "#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n\nvoid foo()\n{\n   (*counter)++; \n}\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, \"malloc() fails\\n\");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n     foo();\n  }\n  printf(\"%d \\n\", *counter);\n  free (counter);\n  return 0;   \n}\n\n", "targets": {"77": "     foo();\n", "78": "  }\n"}}, {"prompt": "#include <stdio.h>\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n#pragma omp critical\n      {\n        s = 1;\n      }\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp critical\n        {\n          if (s)\n            done = 1;\n        }\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n", "targets": {"22": "  {\n", "21": "#pragma omp parallel sections shared(x, s) num_threads(2)\n", "25": "      x = 1;\n", "26": "#pragma omp critical\n", "28": "        s = 1;\n", "29": "      }\n", "23": "#pragma omp section\n", "33": "      int done = 0;\n", "34": "      while (!done)\n", "36": "#pragma omp critical\n", "38": "          if (s)\n", "39": "            done = 1;\n", "40": "        }\n", "42": "      x = 2;\n", "31": "#pragma omp section\n", "44": "  }\n"}}, {"prompt": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 533, 529, 531, // 521+12=533\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n\n#pragma omp parallel for // default static even scheduling may not trigger data race!\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n", "targets": {"125": "  for (i =0; i< N; ++i) \n", "124": "#pragma omp parallel for // default static even scheduling may not trigger data race!\n", "127": "    int idx = indexSet[i];\n", "128": "    xa1[idx]+= 1.0;\n", "129": "    xa2[idx]+= 3.0;\n", "130": "  }\n"}}, {"prompt": "#include<iostream>\n#include<cassert>\nusing namespace std;\n\nclass A {\npublic:\n  static int counter; \n  static int pcounter; \n#pragma omp threadprivate(pcounter)\n};\n\nint A::counter=0; \nint A::pcounter=0; \n\nA a; \n\nint main()\n{ \n  #pragma omp parallel \n  {\n   a.counter++; \n   a.pcounter++; \n  }\n  assert (A::pcounter == 1);\n  cout<<A::counter <<\" \"<< A::pcounter<<endl;\n  return 0;   \n}\n", "targets": {"74": "   a.counter++; \n", "75": "   a.pcounter++; \n", "76": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                             // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y -= x;                                                         //2nd child task\n\n  #pragma omp taskwait depend(in: x)                               // 1st taskwait\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n\n  #pragma omp taskwait\t\t                                         // 2nd taskwait\n\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n", "targets": {"24": "  #pragma omp task depend(inout: x) shared(x)\n", "25": "  x++;                                                             // 1st child task\n", "27": "  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n", "28": "  y -= x;                                                         //2nd child task\n", "41": "  #pragma omp single\n", "42": "  foo();\n"}}, {"prompt": "#include <string.h>\nint main(int argc,char *argv[])\n{\n  int i;\n  int j;\n  double a[20][20];\n  memset(a,0,(sizeof(a)));\n\n  for (i = 0; i < 20 -1; i += 1) {\n#pragma omp parallel for\n    for (j = 0; j < 20; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n", "targets": {"61": "    for (j = 0; j < 20; j += 1) {\n", "60": "#pragma omp parallel for\n", "62": "      a[i][j] += a[i + 1][j];\n", "63": "    }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char* argv[])\n{\n  int len=100; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf(\"x=%d, a[0]=%d\\n\",x,a[0]);    \n  return 0;\n} \n\n", "targets": {"69": "  for (i=0;i<len;i++)\n", "68": "#pragma omp parallel for \n", "71": "    a[i] = x;\n", "72": "    x=i;\n", "73": "  }\n"}}, {"prompt": "#include <stdio.h>\n/*\n *  loop missing the linear clause\n *  Data race pairs (race on j allows wrong indexing of c):  \n     j@70:7:R vs. j@71:5:W\n     j@71:5:W vs. j@71:5:W \n     c[j]@70:5:W vs. c[j]@70:5:W\n*/\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf (\"c[50]=%f\\n\",c[50]);\n  return 0;\n}\n", "targets": {"68": "  for (i=0;i<len;i++)\n", "67": "#pragma omp parallel for \n", "70": "    c[j]+=a[i]*b[i];\n", "71": "    j++;\n", "72": "  }\n"}}, {"prompt": "#include <stdio.h>\n\nint cap = 10, size = 0;\nunsigned r = 0;\n\nint main()\n{\n#pragma omp parallel sections shared(size, cap) firstprivate(r) num_threads(2)\n  {\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical(A)\n      {\n        if (size < cap)\n        {\n          size++; // produce\n          printf(\"Produced! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n#pragma omp section\n    while (1)\n    {\n#pragma omp critical(B)\n      {\n        if (size > 0)\n        {\n          size--; // consume\n          printf(\"Consumed! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n  }\n}\n", "targets": {"26": "  {\n", "25": "#pragma omp parallel sections shared(size, cap) firstprivate(r) num_threads(2)\n", "28": "    while (1)\n", "30": "#pragma omp critical(A)\n", "32": "        if (size < cap)\n", "34": "          size++; // produce\n", "35": "          printf(\"Produced! size=%d\\n\", size);\n", "36": "          fflush(stdout);\n", "37": "        }\n", "38": "      }\n", "39": "      for (int i = 0; i < 1000; i++)\n", "40": "        r = (r + 1) % 10;\n", "43": "    while (1)\n", "45": "#pragma omp critical(B)\n", "47": "        if (size > 0)\n", "49": "          size--; // consume\n", "50": "          printf(\"Consumed! size=%d\\n\", size);\n", "51": "          fflush(stdout);\n", "52": "        }\n", "53": "      }\n", "54": "      for (int i = 0; i < 1000; i++)\n", "55": "        r = (r + 1) % 10;\n", "42": "#pragma omp section\n", "57": "  }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n  int a, b;\n  omp_nest_lock_t lck;\n} pair;\n\nvoid incr_a(pair *p){\n  p->a += 1;\n}\nvoid incr_b(pair *p){\n  omp_set_nest_lock(&p->lck);\n    p->b += 1;\n  omp_unset_nest_lock(&p->lck);\n}\n\n\nint main(int argc, char* argv[])\n{\n  pair p[1];\n  p->a = 0;\n  p->b = 0;\n  omp_init_nest_lock(&p->lck);\n\n  #pragma omp parallel sections\n  {\n    #pragma omp section\n    {\n      omp_set_nest_lock(&p->lck);\n      incr_b(p);\n      incr_a(p);\n      omp_unset_nest_lock(&p->lck);\n    }\n    #pragma omp section\n      incr_b(p);\n  }\n\n  omp_destroy_nest_lock(&p->lck);\n\n  printf(\"%d\\n\",p->b);\n  return 0;\n}\n", "targets": {"43": "  {\n", "42": "  #pragma omp parallel sections\n", "46": "      omp_set_nest_lock(&p->lck);\n", "47": "      incr_b(p);\n", "48": "      incr_a(p);\n", "49": "      omp_unset_nest_lock(&p->lck);\n", "44": "    #pragma omp section\n", "52": "      incr_b(p);\n", "51": "    #pragma omp section\n", "53": "  }\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble *u1, *u2, c = 0.2;\nint n = 10, nsteps = 10;\n\nint main()\n{\n  u1 = malloc(n * sizeof(double));\n  u2 = malloc(n * sizeof(double));\n  for (int i = 1; i < n - 1; i++)\n    u2[i] = u1[i] = 1.0 * rand() / RAND_MAX;\n  u1[0] = u1[n - 1] = u2[0] = u2[n - 1] = 0.5;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u2[i] = u1[i] + c * (u1[i - 1] + u1[i + 1] - 2 * u1[i]);\n    }\n    double *tmp = u1;\n    u1 = u2; // u2 = tmp;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u1[i]);\n  printf(\"\\n\");\n  free(u1);\n  free(u2);\n}\n", "targets": {"37": "    for (int i = 1; i < n - 1; i++)\n", "36": "#pragma omp parallel for\n", "39": "      u2[i] = u1[i] + c * (u1[i - 1] + u1[i + 1] - 2 * u1[i]);\n", "40": "    }\n"}}, {"prompt": "", "targets": {"59": "  for (i=0;i<100;i++)\n", "58": "#pragma omp parallel for private(j)\n", "60": "    for (j=0;j<100;j++)\n", "61": "      a[i][j]=a[i][j]+1;\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\ntypedef _Bool flag_t;\n\nflag_t f0, f1;\nconst int n = 100;\nint x = 1;\n\nvoid init(flag_t *f)\n{\n  *f = 0;\n}\n\nvoid raise(flag_t *f)\n{\n#pragma omp critical\n  {\n    assert(*f == 0);\n    *f = 1;\n  }\n}\n\nvoid lower(flag_t *f)\n{\n  _Bool done = 0;\n  while (!done)\n  {\n#pragma omp critical\n    if (*f == 1)\n    {\n      *f = 0;\n      done = 1;\n    }\n  }\n}\n\nvoid mybarrier(int tid)\n{\n  if (tid == 0)\n  {\n    raise(&f0);\n    lower(&f1);\n  }\n  else if (tid == 1)\n  {\n    lower(&f0);\n    raise(&f1);\n  }\n}\n\nint main()\n{\n  init(&f0);\n  init(&f1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 1);\n      mybarrier(tid);\n      if (tid == 0)\n        x = 0;\n      mybarrier(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 0);\n      mybarrier(tid);\n      if (tid == 1)\n        x = 1;\n      mybarrier(tid);\n    }\n  } // end of parallel construct\n  printf(\"Done: x=%d\\n\", x);\n}", "targets": {"75": "    int tid = omp_get_thread_num();\n", "76": "#pragma omp barrier\n", "77": "    for (int i = 0; i < n; i++)\n", "79": "      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n", "80": "      fflush(stdout);\n", "81": "      assert(x == 1);\n", "82": "      mybarrier(tid);\n", "83": "      if (tid == 0)\n", "84": "        x = 0;\n", "85": "      mybarrier(tid);\n", "86": "      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n", "87": "      fflush(stdout);\n", "88": "      assert(x == 0);\n", "89": "      mybarrier(tid);\n", "90": "      if (tid == 1)\n", "91": "        x = 1;\n", "92": "      mybarrier(tid);\n", "93": "    }\n", "94": "  } // end of parallel construct\n"}}, {"prompt": "#include <stdio.h>\n#include <assert.h>\nint main()\n{\n  int i,error;\n  int len = 1000;\n  int a[len], b=5;\n\n  for (i=0; i<len; i++)\n    a[i]= i;\n \n#pragma omp parallel shared(b, error) \n  {\n#pragma omp for nowait\n    for(i = 0; i < len; i++)\n      a[i] = b + a[i]*5;\n\n#pragma omp barrier\n\n#pragma omp single\n    error = a[9] + 1;\n  }\n  assert (error == 51);\n  printf (\"error = %d\\n\", error);\n  return 0;\n}  \n", "targets": {"65": "  {\n", "67": "    for(i = 0; i < len; i++)\n", "66": "#pragma omp for nowait\n", "68": "      a[i] = b + a[i]*5;\n", "70": "#pragma omp barrier\n", "72": "#pragma omp single\n", "73": "    error = a[9] + 1;\n", "74": "  }\n"}}, {"prompt": "#include <stdio.h>\n \nfloat x=0.0;\nint y=0;\n#pragma omp threadprivate(x,y)\n\nint main (int argc, char * argv[])\n{\n#pragma omp parallel\n  {\n#pragma omp single copyprivate(x,y)\n    {\n      x=1.0;\n      y=1;\n    }\n  }\n  printf (\"x=%f y=%d\\n\", x, y);\n  return 0;\n}\n", "targets": {"60": "#pragma omp single copyprivate(x,y)\n", "62": "      x=1.0;\n", "63": "      y=1;\n", "64": "    }\n", "65": "  }\n"}}, {"prompt": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 921, \n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999,\n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf(\"Error, malloc() returns NULL. End execution. \\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = base + 12;\n  int i;\n\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.0;\n  }\n\n#pragma omp parallel for\n  for (i =0; i< N; ++i) // this level of loop has no loop carried dependence\n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0;\n    xa2[idx]+= 3.0;\n  }\n\n  // verify the results, no overlapping of xa1 vs. xa2, no addition happens to the same element twice\n  for (i =521; i<= 2025; ++i)\n  {\n    //printf (\"%f  \", base[i]);\n    assert (base[i]!=4.0);\n  }\n\n  free (base);\n  return  0;\n}\n\n", "targets": {"116": "  for (i =0; i< N; ++i) // this level of loop has no loop carried dependence\n", "115": "#pragma omp parallel for\n", "118": "    int idx = indexSet[i];\n", "119": "    xa1[idx]+= 1.0;\n", "120": "    xa2[idx]+= 3.0;\n", "121": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint main(){\n  omp_lock_t lck;\n  int var=0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1)\n  #pragma omp distribute parallel for\n  for (int i=0; i<N; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf(\"%d\\n\",var);\n  return 0;\n}\n", "targets": {"25": "  #pragma omp distribute parallel for\n", "26": "  for (int i=0; i<N; i++){\n", "27": "    omp_set_lock(&lck);\n", "28": "    var++;\n", "29": "    omp_unset_lock(&lck);\n", "30": "  }\n"}}, {"prompt": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 180\nint indexSet[N] = {\n521, 523, 525, 527, 529, 531,\n547, 549, 551, 553, 555, 557,\n573, 575, 577, 579, 581, 583,\n599, 601, 603, 605, 607, 609,\n625, 627, 629, 631, 633, 635,\n\n651, 653, 655, 657, 659, 661,\n859, 861, 863, 865, 867, 869,\n885, 887, 889, 891, 893, 895,\n911, 913, 915, 917, 919, 923, // change original 921 to 923 = 911+12\n937, 939, 941, 943, 945, 947,\n\n963, 965, 967, 969, 971, 973,\n989, 991, 993, 995, 997, 999, \n1197, 1199, 1201, 1203, 1205, 1207,\n1223, 1225, 1227, 1229, 1231, 1233,\n1249, 1251, 1253, 1255, 1257, 1259,\n\n1275, 1277, 1279, 1281, 1283, 1285,\n1301, 1303, 1305, 1307, 1309, 1311,\n1327, 1329, 1331, 1333, 1335, 1337,\n1535, 1537, 1539, 1541, 1543, 1545,\n1561, 1563, 1565, 1567, 1569, 1571,\n\n1587, 1589, 1591, 1593, 1595, 1597,\n1613, 1615, 1617, 1619, 1621, 1623,\n1639, 1641, 1643, 1645, 1647, 1649,\n1665, 1667, 1669, 1671, 1673, 1675,\n1873, 1875, 1877, 1879, 1881, 1883,\n\n1899, 1901, 1903, 1905, 1907, 1909,\n1925, 1927, 1929, 1931, 1933, 1935,\n1951, 1953, 1955, 1957, 1959, 1961,\n1977, 1979, 1981, 1983, 1985, 1987,\n2003, 2005, 2007, 2009, 2011, 2013};\n\nint main (int argc, char* argv[])\n{\n  // max index value is 2013. +12 to obtain a valid xa2[idx] after xa1+12.\n  // +1 to ensure a reference like base[2015] is within the bound.\n  double * base = (double*) malloc(sizeof(double)* (2013+12+1));\n  if (base == 0)\n  {\n    printf (\"Error in malloc(). Aborting ...\\n\");\n    return 1;  \n  }\n\n  double * xa1 = base;\n  double * xa2 = xa1 + 12;\n  int i;\n\n  // initialize segments touched by indexSet\n  for (i =521; i<= 2025; ++i)\n  {\n    base[i]=0.5*i;\n  }\n// default static even scheduling may not trigger data race, using static,1 instead.\n#pragma omp parallel for schedule(static,1)\n  for (i =0; i< N; ++i) \n  {\n    int idx = indexSet[i];\n    xa1[idx]+= 1.0 + i;\n    xa2[idx]+= 3.0 + i;\n  }\n\n  printf(\"x1[999]=%f xa2[1285]=%f\\n\", xa1[999], xa2[1285]);\n  free (base);\n  return  0;\n}\n\n", "targets": {"125": "  for (i =0; i< N; ++i) \n", "124": "#pragma omp parallel for schedule(static,1)\n", "127": "    int idx = indexSet[i];\n", "128": "    xa1[idx]+= 1.0 + i;\n", "129": "    xa2[idx]+= 3.0 + i;\n", "130": "  }\n"}}, {"prompt": "#include <stdio.h>\n\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  double a[20][20];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n\n  printf (\"a[10][10]=%f\\n\", a[10][10]);\n  return 0;\n}\n\n", "targets": {"65": "  for (i = 0; i < len - 1; i += 1) {\n", "64": "#pragma omp parallel for private(j)\n", "66": "    for (j = 0; j < len ; j += 1) {\n", "67": "      a[i][j] += a[i + 1][j];\n", "68": "    }\n", "69": "  }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp critical(addlock)\n    var++;\n\n    #pragma omp critical(sublock)\n    var -= 2;\n  }\n\n  printf(\"%d\\n\",var);\n\n  return 0;\n}\n", "targets": {"29": "  for(int i=0; i<N; i++){\n", "28": "  #pragma omp teams distribute parallel for\n", "35": "  }\n", "30": "    #pragma omp critical(addlock)\n", "31": "    var++;\n", "33": "    #pragma omp critical(sublock)\n", "34": "    var -= 2;\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N*2; i++){\n    #pragma omp critical\n    var++;\n  }\n\n  printf(\"%d\\n \",var);\n\n  return 0;\n}\n", "targets": {"24": "  for(int i=0; i<N*2; i++){\n", "23": "  #pragma omp teams distribute parallel for\n", "27": "  }\n", "25": "    #pragma omp critical\n", "26": "    var++;\n"}}, {"prompt": "#include <stdio.h>\n/*\n * Test if atomic can be recognized properly. No data races.\n * */\nint main (void)\n{\n  int a=0;\n#pragma omp parallel \n  {\n#pragma omp atomic\n    a+=1;\n  }\n  printf (\"a=%d\\n\",a);\n  return 0;\n}\n\n", "targets": {"54": "  {\n", "56": "    a+=1;\n", "57": "  }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n  {\n#pragma omp task depend(inout : a) shared(a)\n    a++;\n  }\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n", "targets": {"26": "  {\n", "27": "#pragma omp task depend(inout : a) shared(a)\n", "29": "  }\n", "28": "    a++;\n"}}, {"prompt": "#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf(\"%d\\n \",var[i]);\n  }\n\n  return 0;\n}\n", "targets": {"27": "  #pragma omp distribute parallel for reduction(+:var)\n", "28": "  for (int i=0; i<N; i++){\n", "30": "    for(int i=0; i<C; i++){\n", "29": "    #pragma omp simd\n", "31": "      var[i]++;\n", "32": "    }\n", "33": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  int len = 20000;\n\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[2 * len], b[len];\n\n  for (int i = 0; i < 2 * len; i++)\n    a[i] = i;\n  for (int i = 0; i < len; i++)\n    b[i] = i + 1;\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len; i++)\n    a[i * 2] = a[i + 64] + b[i];\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n\n  return 0;\n}\n", "targets": {"32": "  for (int i = 0; i < len; i++)\n", "33": "    a[i * 2] = a[i + 64] + b[i];\n", "31": "#pragma omp parallel for simd schedule(dynamic, 64)\n"}}, {"prompt": "", "targets": {"60": "  for (i=0;i<n;i++)\n", "59": "#pragma omp parallel for private(j)\n", "61": "    for (j=1;j<m;j++) // Be careful about bounds of j\n", "62": "      b[i][j]=b[i][j-1];\n"}}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  float temp, sum=0.0;\n  int len=100;\n\n  float u[100][100];\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n        u[i][j] = 0.5; \n\n#pragma omp parallel for private (temp,i,j)\n  for (i = 0; i < len; i++)\n    for (j = 0; j < len; j++)\n    {\n      temp = u[i][j];\n      sum = sum + temp * temp;\n    }\n\n  printf (\"sum = %f\\n\", sum);  \n  return 0;\n}\n", "targets": {"66": "  for (i = 0; i < len; i++)\n", "65": "#pragma omp parallel for private (temp,i,j)\n", "67": "    for (j = 0; j < len; j++)\n", "69": "      temp = u[i][j];\n", "70": "      sum = sum + temp * temp;\n", "71": "    }\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int n=1000, m=1000;\n  double b[1000][1000];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  printf(\"b[500][500]=%f\\n\", b[500][500]);  \n  return 0;\n}\n", "targets": {"64": "  for (i=1;i<n;i++)\n", "63": "#pragma omp parallel for private(j)\n", "65": "    for (j=1;j<m;j++)\n", "66": "      b[i][j]=b[i-1][j-1];\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100];\n\n  for (i=0;i<len;i++)\n    a[i]=i;\n   \n  srand(time(NULL));\n#pragma omp parallel for if (rand()%2)\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  printf(\"a[50]=%d\\n\", a[50]);   \n  return 0;\n}\n", "targets": {"65": "  for (i=0;i<len-1;i++)\n", "64": "#pragma omp parallel for if (rand()%2)\n", "66": "    a[i+1]=a[i]+1;\n"}}, {"prompt": "#include <stdio.h>\nint nprod = 4, ncons = 4;\nint cap = 5, size = 0, packages = 1000;\nint main()\n{\n  int nthread = nprod + ncons;\n#pragma omp parallel for shared(size, cap, nprod, ncons, nthread) firstprivate(packages) num_threads(nthread)\n  for (int i = 0; i < nthread; i++)\n  {\n    if (i < nprod)\n      while (packages)\n      { // I am a producer\n#pragma omp critical(A)\n        if (size < cap)\n        {\n          size++; // produce\n          packages--; // produced a package\n          printf(\"Producer %d produced! size=%d\\n\", i, size);\n          fflush(stdout);\n        }\n      }\n    else\n      while (packages)\n      { // I am a consumer\n#pragma omp critical(B)\n        if (size > 0)\n        {\n          size--; // consume\n          packages--; // consumed a package\n          printf(\"Consumer %d consumed! size=%d\\n\", i - nprod, size);\n          fflush(stdout);\n        }\n      }\n  }\n}\n", "targets": {"25": "  for (int i = 0; i < nthread; i++)\n", "24": "#pragma omp parallel for shared(size, cap, nprod, ncons, nthread) firstprivate(packages) num_threads(nthread)\n", "27": "    if (i < nprod)\n", "28": "      while (packages)\n", "30": "#pragma omp critical(A)\n", "31": "        if (size < cap)\n", "33": "          size++; // produce\n", "34": "          packages--; // produced a package\n", "35": "          printf(\"Producer %d produced! size=%d\\n\", i, size);\n", "36": "          fflush(stdout);\n", "37": "        }\n", "40": "      while (packages)\n", "42": "#pragma omp critical(B)\n", "43": "        if (size > 0)\n", "45": "          size--; // consume\n", "46": "          packages--; // consumed a package\n", "47": "          printf(\"Consumer %d consumed! size=%d\\n\", i - nprod, size);\n", "48": "          fflush(stdout);\n", "49": "        }\n", "51": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\n\nint a;\nint b[C];\nint c[C];\nint temp[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    b[i]=0;\n    c[i]=2;\n    temp[i]=0;\n  }\n  a=2;\n\n  #pragma omp target map(tofrom:b[0:C]) map(to:c[0:C],temp[0:C],a) device(0)\n  {\n    #pragma omp teams\n    for(int i=0; i<N ;i++){\n      #pragma omp distribute\n      for(int i=0; i<C; i++){\n        temp[i] = b[i] + c[i];\n      }\n\n      #pragma omp distribute\n      for(int i=C-1; i>=0; i--){\n        b[i] = temp[i] * a;\n      }\n    }\n  }\n\n  int val = 0;\n\n  for(int i=0; i<N; i++){\n    val = val + 2;\n    val = val * 2;\n  }\n\n  for(int i=0; i<C; i++){\n    if(b[i]!=val){\n      printf(\"index: %d val: %d\\n\",i, b[i]);\n    }\n  }\n\n  return 0;\n}\n", "targets": {"39": "    for(int i=0; i<N ;i++){\n", "41": "      for(int i=0; i<C; i++){\n", "40": "      #pragma omp distribute\n", "42": "        temp[i] = b[i] + c[i];\n", "43": "      }\n", "46": "      for(int i=C-1; i>=0; i--){\n", "45": "      #pragma omp distribute\n", "47": "        b[i] = temp[i] * a;\n", "48": "      }\n", "49": "    }\n"}}, {"prompt": "#include <stdio.h>\nint main()\n{\n  int len=100;\n  double a[len], b[len], c[len];\n  int i,j=0;\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=((double)i)/2.0; \n    b[i]=((double)i)/3.0; \n    c[i]=((double)i)/7.0; \n  }\n\n#pragma omp parallel for linear(j)\n  for (i=0;i<len;i++)\n  {\n    c[j]+=a[i]*b[i];\n    j++;\n  }\n\n  printf (\"c[50]=%f\\n\",c[50]);\n  return 0;\n}\n", "targets": {"67": "  for (i=0;i<len;i++)\n", "66": "#pragma omp parallel for linear(j)\n", "69": "    c[j]+=a[i]*b[i];\n", "70": "    j++;\n", "71": "  }\n"}}, {"prompt": "#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel for ordered(2)\n  for (i = 0; i < 100; i++)\n    for (j = 0; j < 100; j++)\n    {\n      a[i][j] = a[i][j] + 1;\n#pragma omp ordered depend(sink:i-1,j) depend (sink:i,j-1)\n      printf (\"test i=%d j=%d\\n\",i,j);\n#pragma omp ordered depend(source)\n    }\n  return 0;\n}\n\n", "targets": {"63": "  for (i = 0; i < 100; i++)\n", "62": "#pragma omp parallel for ordered(2)\n", "64": "    for (j = 0; j < 100; j++)\n", "66": "      a[i][j] = a[i][j] + 1;\n", "67": "#pragma omp ordered depend(sink:i-1,j) depend (sink:i,j-1)\n", "68": "      printf (\"test i=%d j=%d\\n\",i,j);\n", "69": "#pragma omp ordered depend(source)\n", "70": "    }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\n\nint main(int argc, char *argv[]) {\n\n  int *A; \n  int N = 100;\n\n  A = (int*) malloc(sizeof(int) * N);\n\n  \n#pragma omp parallel for shared(A)\n  for(int i = 0; i < N; i++) {\n    A[i] = i;\n    if (i == 1) \n    { \n      A[0] = 1; \n    }\n  }\n\n  free(A);\n  return 0;\n}\n", "targets": {"30": "  for(int i = 0; i < N; i++) {\n", "29": "#pragma omp parallel for shared(A)\n", "31": "    A[i] = i;\n", "32": "    if (i == 1) \n", "34": "      A[0] = 1; \n", "35": "    }\n", "36": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for reduction(+:var)\n  for (int i=0; i<N; i++){\n    var++;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n", "targets": {"24": "  for (int i=0; i<N; i++){\n", "23": "  #pragma omp teams distribute parallel for reduction(+:var)\n", "26": "  }\n", "25": "    var++;\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\nint main(int argc, char *argv[]) {\n  int len = 20000;\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[len];\n  for (int i = 0; i < len; i++)\n    a[i] = i;\n  double c = M_PI;\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len; i++)\n    a[i] = a[i] + a[64];\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n  return 0;\n}\n", "targets": {"29": "  for (int i = 0; i < len; i++)\n", "30": "    a[i] = a[i] + a[64];\n", "28": "#pragma omp parallel for simd schedule(dynamic, 64)\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp task depend(in: x) if(0)                // 1st taskwait\n  {}\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                // 2nd taskwait\n\n  printf(\"y=%d\\n\",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n", "targets": {"22": "  #pragma omp task depend(inout: x) shared(x)\n", "23": "  x++;                                                //1st Child Task\n", "25": "  #pragma omp task shared(y)\n", "26": "  y--;                                                // 2nd child task\n", "28": "  #pragma omp task depend(in: x) if(0)                // 1st taskwait\n", "29": "  {}\n", "41": "  #pragma omp single\n", "42": "  foo();\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n#define C 64\n\nint main(){\n\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:C]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  printf(\"%d\\n\",var[63]);\n\n  return 0;\n}\n", "targets": {"32": "  for (int i=0; i<N; i++){\n", "31": "  #pragma omp teams distribute parallel for\n", "37": "  }\n", "34": "    for(int i=0; i<C; i++){\n", "33": "    #pragma omp simd\n", "35": "      var[i]++;\n", "36": "    }\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble *u1, *u2, c = 0.2;\nint n = 10, nsteps = 10;\n\nint main()\n{\n  u1 = malloc(n * sizeof(double));\n  u2 = malloc(n * sizeof(double));\n  for (int i = 1; i < n - 1; i++)\n    u2[i] = u1[i] = 1.0 * rand() / RAND_MAX;\n  u1[0] = u1[n - 1] = u2[0] = u2[n - 1] = 0.5;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u2[i] = u1[i] + c * (u1[i - 1] + u1[i + 1] - 2 * u1[i]);\n    }\n    double *tmp = u1;\n    u1 = u2;\n    u2 = tmp;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u1[i]);\n  printf(\"\\n\");\n  free(u1);\n  free(u2);\n}\n", "targets": {"33": "    for (int i = 1; i < n - 1; i++)\n", "32": "#pragma omp parallel for\n", "35": "      u2[i] = u1[i] + c * (u1[i - 1] + u1[i + 1] - 2 * u1[i]);\n", "36": "    }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1, l2;\nconst int n = 2;\nint x = 1;\n\nvoid barrier_init()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n  omp_init_lock(&l2);\n}\n\nvoid barrier_destroy()\n{\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  omp_destroy_lock(&l2);\n}\n\nvoid barrier_start(int tid)\n{\n  if (tid == 0)\n  {\n    omp_set_lock(&l0);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l1);\n  }\n}\n\nvoid barrier_stop(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_unset_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_unset_lock(&l1);\n  }\n}\n\nvoid barrier_wait(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    // omp_unset_lock(&l2);\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    // omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    // omp_set_lock(&l2);\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    // omp_unset_lock(&l2);\n  }\n}\n\nint main()\n{\n  barrier_init();\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    barrier_start(tid);\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      // assert(x==1);\n      barrier_wait(tid);\n      if (tid == 0)\n        x = 0;\n      barrier_wait(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      // assert(x==0);\n      barrier_wait(tid);\n      if (tid == 1)\n        x = 1;\n      barrier_wait(tid);\n    }\n#pragma omp barrier\n    barrier_stop(tid);\n  } // end of parallel construct\n  barrier_destroy();\n  printf(\"Done: x=%d\\n\", x);\n}\n", "targets": {"94": "    int tid = omp_get_thread_num();\n", "95": "    barrier_start(tid);\n", "96": "#pragma omp barrier\n", "97": "    for (int i = 0; i < n; i++)\n", "99": "      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n", "100": "      fflush(stdout);\n", "102": "      barrier_wait(tid);\n", "103": "      if (tid == 0)\n", "104": "        x = 0;\n", "105": "      barrier_wait(tid);\n", "106": "      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n", "107": "      fflush(stdout);\n", "109": "      barrier_wait(tid);\n", "110": "      if (tid == 1)\n", "111": "        x = 1;\n", "112": "      barrier_wait(tid);\n", "113": "    }\n", "114": "#pragma omp barrier\n", "115": "    barrier_stop(tid);\n", "116": "  } // end of parallel construct\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n#define N 100\n\nint var = 0;\n\nint main(){\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for(int i=0; i<N; i++){\n    #pragma omp atomic\n    var++;\n\n    #pragma omp atomic\n    var -= 2;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n", "targets": {"27": "  for(int i=0; i<N; i++){\n", "26": "  #pragma omp teams distribute parallel for\n", "33": "  }\n", "29": "    var++;\n", "32": "    var -= 2;\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{ \n  int i; \n  int tmp;\n  tmp = 10;\n  int len=100;\n\n  int a[100];\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  { \n    a[i] = tmp;\n    tmp =a[i]+i;\n  }\n\n  printf(\"a[50]=%d\\n\", a[50]);\n  return 0;      \n}\n\n", "targets": {"64": "  for (i=0;i<len;i++)\n", "63": "#pragma omp parallel for\n", "66": "    a[i] = tmp;\n", "67": "    tmp =a[i]+i;\n", "68": "  }\n"}}, {"prompt": "#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop collapse(2)\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf (\"a[50][50]=%d\\n\", a[50][50]);\n  return 0;\n}\n", "targets": {"63": "#pragma omp single\n", "65": "#pragma omp taskloop collapse(2)\n", "69": "    }\n", "70": "  }\n", "66": "      for (i = 0; i < 100; i++)\n", "67": "        for (j = 0; j < 100; j++)\n", "68": "          a[i][j]+=1; \n"}}, {"prompt": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 4000. */\n#include \"polybench/3mm.h\"\n/* Array initialization. */\n\nstatic void init_array(int ni,int nj,int nk,int nl,int nm,double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c3;\n    int c4;\n    int c1;\n    int c2;\n    if (ni >= ((0 > -1 * nj + -1 * nm + 1?0 : -1 * nj + -1 * nm + 1)) && nj >= 0 && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + ni + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + ni + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + ni + nj + nm + -1) + 16 - 1) / 16))) : (nk + ni + nj + nm + -1) / 16)) < (((nk + ni + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + ni + nj + 2 * nm + -2) / 16))?(((nk + ni + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + ni + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + ni + nj + nm + -1) + 16 - 1) / 16))) : (nk + ni + nj + nm + -1) / 16)) : (((nk + ni + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + ni + nj + 2 * nm + -2) / 16)))); c1++) {\n        if (c1 <= (((((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)) < nm + -1?((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)) < nm + -1?((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nl?nj : nl)) > nm?((nj > nl?nj : nl)) : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nk > nl?nk : nl)) > nm?((nk > nl?nk : nl)) : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nk?nj : nk)) > nl?((nj > nk?nj : nk)) : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nl + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nl + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n            }\n            for (c3 = nk; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)) < nm + -1?((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)) : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= nk + -1; c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= nm + -1; c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((ni > nj?ni : nj)) > nm?((ni > nj?ni : nj)) : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (((ni > nk?ni : nk)) > nm?((ni > nk?ni : nk)) : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (((ni > nj?ni : nj)) > nk?((ni > nj?ni : nj)) : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n                  A[c3][c4] = ((double )c3) * c4 / ni;\n                }\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nk; c4 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c4++) {\n                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                }\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = (nj > nk?nj : nk); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nm?ni : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) && c1 >= ((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nk > nm?nk : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (ni > nj?ni : nj); c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nk; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nk; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= ((0 > -1 * nj + 1?0 : -1 * nj + 1)) && nj >= 0 && nk >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + ni + -1) * 16 < 0?((16 < 0?-((-(nk + ni + -1) + 16 + 1) / 16) : -((-(nk + ni + -1) + 16 - 1) / 16))) : (nk + ni + -1) / 16)) < (((nk + ni + nj + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + -2) + 16 - 1) / 16))) : (nk + ni + nj + -2) / 16))?(((nk + ni + -1) * 16 < 0?((16 < 0?-((-(nk + ni + -1) + 16 + 1) / 16) : -((-(nk + ni + -1) + 16 - 1) / 16))) : (nk + ni + -1) / 16)) : (((nk + ni + nj + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + -2) + 16 - 1) / 16))) : (nk + ni + nj + -2) / 16)))); c1++) {\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj <= -1 && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((ni + nm + -1) * 16 < 0?((16 < 0?-((-(ni + nm + -1) + 16 + 1) / 16) : -((-(ni + nm + -1) + 16 - 1) / 16))) : (ni + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n#pragma omp simd\n              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n                A[c3][c4] = ((double )c3) * c4 / ni;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (nj <= -1 && nk >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n              A[c3][c4] = ((double )c3) * c4 / ni;\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj >= 0 && nk <= -1 && nm >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nj + nm + -1) * 16 < 0?((16 < 0?-((-(nj + nm + -1) + 16 + 1) / 16) : -((-(nj + nm + -1) + 16 - 1) / 16))) : (nj + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni >= 0 && nj <= -1 && nk <= -1 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nk >= ((0 > -1 * nm + 1?0 : -1 * nm + 1)) && nm >= 0) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((((nk + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + nj + nm + -1) + 16 - 1) / 16))) : (nk + nj + nm + -1) / 16)) < (((nk + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + nj + 2 * nm + -2) / 16))?(((nk + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + nj + nm + -1) + 16 - 1) / 16))) : (nk + nj + nm + -1) / 16)) : (((nk + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + nj + 2 * nm + -2) / 16)))); c1++) {\n        if (c1 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                }\n              }\n            }\n            for (c3 = nj; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n              if (c1 == c2) {\n#pragma omp simd\n                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n                }\n              }\n            }\n            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n#pragma omp simd\n              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n              }\n            }\n          }\n        }\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= 1 && nm <= -1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n              B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj <= -1 && nk >= 0 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj >= 0 && nk <= -1 && nm >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nj + nm + -1) * 16 < 0?((16 < 0?-((-(nj + nm + -1) + 16 + 1) / 16) : -((-(nj + nm + -1) + 16 - 1) / 16))) : (nj + nm + -1) / 16)); c1++) {\n        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n#pragma omp simd\n              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n#pragma omp simd\n              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nj <= -1 && nk <= -1 && nl >= 1) {\n#pragma omp parallel for private(c2, c4, c3)\n      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n#pragma omp simd\n            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int ni,int nl,double G[128 + 0][128 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < ni; i++) \n    for (j = 0; j < nl; j++) {\n      fprintf(stderr,\"%0.2lf \",G[i][j]);\n      if ((i * ni + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_3mm(int ni,int nj,int nk,int nl,int nm,double E[128 + 0][128 + 0],double A[128 + 0][128 + 0],double B[128 + 0][128 + 0],double F[128 + 0][128 + 0],double C[128 + 0][128 + 0],double D[128 + 0][128 + 0],double G[128 + 0][128 + 0])\n{\n  // int i;\n  // int j;\n  // int k;\n  \n  //#pragma scop\n{\n    int c5;\n    int c10;\n    int c2;\n    int c1;\n    int c6;\n    int c7;\n    if (ni >= 0 && nj >= 0 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((nj + ni + -1) * 16 < 0?((16 < 0?-((-(nj + ni + -1) + 16 + 1) / 16) : -((-(nj + ni + -1) + 16 - 1) / 16))) : (nj + ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n            for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n              for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                G[c10][c7] = 0;\n              }\n            }\n          }\n          if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n            for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n              for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n                F[c10][c7] = 0;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (ni <= -1 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n              F[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nj <= -1 && nl >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n              G[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nl >= 1 && nm >= 1) {\n#pragma omp parallel for private(c7, c6, c2, c10, c5)\n      for (c1 = 0; c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n          for (c5 = 0; c5 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nm + -1?16 * c5 + 15 : nm + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n                  F[c10][c7] += C[c10][c6] * D[c6][c7];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c7, c2, c10)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n              E[c10][c7] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (nj >= 1) {\n#pragma omp parallel for private(c7, c6, c2, c10, c5)\n      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n          for (c5 = 0; c5 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nk + -1?16 * c5 + 15 : nk + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                  E[c10][c7] += A[c10][c6] * B[c6][c7];\n                }\n              }\n            }\n          }\n          for (c5 = 0; c5 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c5++) {\n            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nl + -1?16 * c5 + 15 : nl + -1)); c6++) {\n              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n#pragma omp simd\n                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n                  G[c10][c6] += E[c10][c7] * F[c7][c6];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  //#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int ni = 128;\n  int nj = 128;\n  int nk = 128;\n  int nl = 128;\n  int nm = 128;\n/* Variable declaration/allocation. */\n  double (*E)[128 + 0][128 + 0];\n  E = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[128 + 0][128 + 0];\n  A = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[128 + 0][128 + 0];\n  B = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*F)[128 + 0][128 + 0];\n  F = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*C)[128 + 0][128 + 0];\n  C = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*D)[128 + 0][128 + 0];\n  D = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n  double (*G)[128 + 0][128 + 0];\n  G = ((double (*)[128 + 0][128 + 0])(polybench_alloc_data(((128 + 0) * (128 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(ni,nj,nk,nl,nm, *A, *B, *C, *D);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_3mm(ni,nj,nk,nl,nm, *E, *A, *B, *F, *C, *D, *G);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(ni,nl, *G);\n/* Be clean. */\n  free(((void *)E));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  free(((void *)F));\n  ;\n  free(((void *)C));\n  ;\n  free(((void *)D));\n  ;\n  free(((void *)G));\n  ;\n  return 0;\n}\n", "targets": {"31": "      for (c1 = 0; c1 <= (((((nk + ni + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + ni + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + ni + nj + nm + -1) + 16 - 1) / 16))) : (nk + ni + nj + nm + -1) / 16)) < (((nk + ni + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + ni + nj + 2 * nm + -2) / 16))?(((nk + ni + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + ni + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + ni + nj + nm + -1) + 16 - 1) / 16))) : (nk + ni + nj + nm + -1) / 16)) : (((nk + ni + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + ni + nj + 2 * nm + -2) / 16)))); c1++) {\n", "30": "#pragma omp parallel for private(c2, c4, c3)\n", "32": "        if (c1 <= (((((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n", "33": "          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "34": "            for (c3 = 16 * c1; c3 <= ((((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)) < nm + -1?((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n", "36": "              for (c4 = 16 * c2; c4 <= ((((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)) < nm + -1?((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n", "35": "#pragma omp simd\n", "37": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "38": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "39": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "40": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "41": "              }\n", "43": "              for (c4 = nl; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c4++) {\n", "42": "#pragma omp simd\n", "44": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "45": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "46": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "47": "              }\n", "49": "              for (c4 = nm; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)); c4++) {\n", "48": "#pragma omp simd\n", "50": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "51": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "52": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "53": "              }\n", "55": "              for (c4 = (nl > nm?nl : nm); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n", "54": "#pragma omp simd\n", "56": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "57": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "58": "              }\n", "60": "              for (c4 = nj; c4 <= ((((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n", "59": "#pragma omp simd\n", "61": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "62": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "63": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "64": "              }\n", "66": "              for (c4 = (nj > nl?nj : nl); c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n", "65": "#pragma omp simd\n", "67": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "68": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "69": "              }\n", "71": "              for (c4 = (nj > nm?nj : nm); c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n", "70": "#pragma omp simd\n", "72": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "73": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "74": "              }\n", "76": "              for (c4 = (((nj > nl?nj : nl)) > nm?((nj > nl?nj : nl)) : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "75": "#pragma omp simd\n", "77": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "78": "              }\n", "80": "              for (c4 = nk; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n", "79": "#pragma omp simd\n", "81": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "82": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "83": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "84": "              }\n", "86": "              for (c4 = (nk > nl?nk : nl); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n", "85": "#pragma omp simd\n", "87": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "88": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "89": "              }\n", "91": "              for (c4 = (nk > nm?nk : nm); c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "90": "#pragma omp simd\n", "92": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "93": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "94": "              }\n", "96": "              for (c4 = (((nk > nl?nk : nl)) > nm?((nk > nl?nk : nl)) : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "95": "#pragma omp simd\n", "97": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "98": "              }\n", "100": "              for (c4 = (nj > nk?nj : nk); c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "99": "#pragma omp simd\n", "101": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "102": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "103": "              }\n", "105": "              for (c4 = (((nj > nk?nj : nk)) > nl?((nj > nk?nj : nk)) : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "104": "#pragma omp simd\n", "106": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "107": "              }\n", "109": "              for (c4 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "108": "#pragma omp simd\n", "110": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "111": "              }\n", "112": "            }\n", "113": "            for (c3 = nm; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n", "115": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "114": "#pragma omp simd\n", "116": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "117": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "118": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "119": "              }\n", "120": "              if (c1 == c2) {\n", "122": "                for (c4 = nm; c4 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c4++) {\n", "121": "#pragma omp simd\n", "123": "                  A[c3][c4] = ((double )c3) * c4 / ni;\n", "124": "                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "125": "                }\n", "126": "              }\n", "127": "              if (c1 == c2) {\n", "129": "                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n", "128": "#pragma omp simd\n", "130": "                  A[c3][c4] = ((double )c3) * c4 / ni;\n", "131": "                }\n", "132": "              }\n", "133": "              if (c1 == c2) {\n", "135": "                for (c4 = nk; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n", "134": "#pragma omp simd\n", "136": "                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "137": "                }\n", "138": "              }\n", "139": "            }\n", "140": "            for (c3 = nj; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) : nm + -1)); c3++) {\n", "142": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "141": "#pragma omp simd\n", "143": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "144": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "145": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "146": "              }\n", "148": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "147": "#pragma omp simd\n", "149": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "150": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "151": "              }\n", "152": "              if (c1 == c2) {\n", "154": "                for (c4 = nj; c4 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nl + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nl + -1)); c4++) {\n", "153": "#pragma omp simd\n", "155": "                  A[c3][c4] = ((double )c3) * c4 / ni;\n", "156": "                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "157": "                }\n", "158": "              }\n", "159": "              if (c1 == c2) {\n", "161": "                for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n", "160": "#pragma omp simd\n", "162": "                  A[c3][c4] = ((double )c3) * c4 / ni;\n", "163": "                }\n", "164": "              }\n", "165": "              if (c1 == c2) {\n", "167": "                for (c4 = nk; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n", "166": "#pragma omp simd\n", "168": "                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "169": "                }\n", "170": "              }\n", "171": "            }\n", "172": "            for (c3 = (nj > nm?nj : nm); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n", "174": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "173": "#pragma omp simd\n", "175": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "176": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "177": "              }\n", "178": "              if (c1 == c2) {\n", "180": "                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n", "179": "#pragma omp simd\n", "181": "                  A[c3][c4] = ((double )c3) * c4 / ni;\n", "182": "                }\n", "183": "              }\n", "184": "            }\n", "185": "            for (c3 = nk; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nm + -1)); c3++) {\n", "187": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n", "186": "#pragma omp simd\n", "188": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "189": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "190": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "191": "              }\n", "193": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "192": "#pragma omp simd\n", "194": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "195": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "196": "              }\n", "197": "              if (c1 == c2) {\n", "199": "                for (c4 = nk; c4 <= ((((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)) < nm + -1?((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "198": "#pragma omp simd\n", "200": "                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "201": "                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "202": "                }\n", "203": "              }\n", "204": "              if (c1 == c2) {\n", "206": "                for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c4++) {\n", "205": "#pragma omp simd\n", "207": "                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "208": "                }\n", "209": "              }\n", "210": "              if (c1 == c2) {\n", "212": "                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n", "211": "#pragma omp simd\n", "213": "                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "214": "                }\n", "215": "              }\n", "216": "            }\n", "217": "            for (c3 = (nk > nm?nk : nm); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n", "219": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n", "218": "#pragma omp simd\n", "220": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "221": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "222": "              }\n", "223": "              if (c1 == c2) {\n", "225": "                for (c4 = nm; c4 <= nk + -1; c4++) {\n", "224": "#pragma omp simd\n", "226": "                  A[c3][c4] = ((double )c3) * c4 / ni;\n", "227": "                }\n", "228": "              }\n", "229": "              if (c1 == c2) {\n", "231": "                for (c4 = nk; c4 <= nm + -1; c4++) {\n", "230": "#pragma omp simd\n", "232": "                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "233": "                }\n", "234": "              }\n", "235": "            }\n", "236": "            for (c3 = (nj > nk?nj : nk); c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n", "238": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n", "237": "#pragma omp simd\n", "239": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "240": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "241": "              }\n", "243": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "242": "#pragma omp simd\n", "244": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "245": "              }\n", "246": "              if (c1 == c2) {\n", "248": "                for (c4 = nk; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n", "247": "#pragma omp simd\n", "249": "                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "250": "                }\n", "251": "              }\n", "252": "            }\n", "253": "            for (c3 = (((nj > nk?nj : nk)) > nm?((nj > nk?nj : nk)) : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "255": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "254": "#pragma omp simd\n", "256": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "257": "              }\n", "258": "            }\n", "259": "            for (c3 = ni; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n", "261": "              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n", "260": "#pragma omp simd\n", "262": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "263": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "264": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "265": "              }\n", "267": "              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n", "266": "#pragma omp simd\n", "268": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "269": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "270": "              }\n", "272": "              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "271": "#pragma omp simd\n", "273": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "274": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "275": "              }\n", "277": "              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "276": "#pragma omp simd\n", "278": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "279": "              }\n", "281": "              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "280": "#pragma omp simd\n", "282": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "283": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "284": "              }\n", "286": "              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "285": "#pragma omp simd\n", "287": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "288": "              }\n", "290": "              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "289": "#pragma omp simd\n", "291": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "292": "              }\n", "293": "            }\n", "294": "            for (c3 = (ni > nm?ni : nm); c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n", "296": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "295": "#pragma omp simd\n", "297": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "298": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "299": "              }\n", "300": "              if (c1 == c2) {\n", "302": "                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n", "301": "#pragma omp simd\n", "303": "                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "304": "                }\n", "305": "              }\n", "306": "            }\n", "307": "            for (c3 = (ni > nj?ni : nj); c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n", "309": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "308": "#pragma omp simd\n", "310": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "311": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "312": "              }\n", "314": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "313": "#pragma omp simd\n", "315": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "316": "              }\n", "317": "              if (c1 == c2) {\n", "319": "                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n", "318": "#pragma omp simd\n", "320": "                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "321": "                }\n", "322": "              }\n", "323": "            }\n", "324": "            for (c3 = (((ni > nj?ni : nj)) > nm?((ni > nj?ni : nj)) : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "326": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "325": "#pragma omp simd\n", "327": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "328": "              }\n", "329": "            }\n", "330": "            for (c3 = (ni > nk?ni : nk); c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n", "332": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "331": "#pragma omp simd\n", "333": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "334": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "335": "              }\n", "337": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "336": "#pragma omp simd\n", "338": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "339": "              }\n", "340": "              if (c1 == c2) {\n", "342": "                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n", "341": "#pragma omp simd\n", "343": "                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "344": "                }\n", "345": "              }\n", "346": "            }\n", "347": "            for (c3 = (((ni > nk?ni : nk)) > nm?((ni > nk?ni : nk)) : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "349": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "348": "#pragma omp simd\n", "350": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "351": "              }\n", "352": "            }\n", "353": "            for (c3 = (((ni > nj?ni : nj)) > nk?((ni > nj?ni : nj)) : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "355": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "354": "#pragma omp simd\n", "356": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "357": "              }\n", "358": "            }\n", "359": "          }\n", "360": "        }\n", "361": "        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n", "362": "          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "363": "            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n", "365": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "364": "#pragma omp simd\n", "366": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "367": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "368": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "369": "              }\n", "371": "              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n", "370": "#pragma omp simd\n", "372": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "373": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "374": "              }\n", "375": "            }\n", "376": "            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n", "378": "              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n", "377": "#pragma omp simd\n", "379": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "380": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "381": "              }\n", "382": "            }\n", "383": "            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n", "385": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "384": "#pragma omp simd\n", "386": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "387": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "388": "              }\n", "390": "              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n", "389": "#pragma omp simd\n", "391": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "392": "              }\n", "393": "            }\n", "394": "            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "396": "              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n", "395": "#pragma omp simd\n", "397": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "398": "              }\n", "399": "            }\n", "400": "            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n", "402": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "401": "#pragma omp simd\n", "403": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "404": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "405": "              }\n", "407": "              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n", "406": "#pragma omp simd\n", "408": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "409": "              }\n", "410": "            }\n", "411": "            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "413": "              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n", "412": "#pragma omp simd\n", "414": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "415": "              }\n", "416": "            }\n", "417": "            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "419": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "418": "#pragma omp simd\n", "420": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "421": "              }\n", "422": "            }\n", "423": "          }\n", "424": "        }\n", "425": "        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n", "426": "          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "427": "            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nk + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nk + -1)); c3++) {\n", "429": "              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c4++) {\n", "428": "#pragma omp simd\n", "430": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "431": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "432": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "433": "              }\n", "435": "              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n", "434": "#pragma omp simd\n", "436": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "437": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "438": "              }\n", "440": "              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n", "439": "#pragma omp simd\n", "441": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "442": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "443": "              }\n", "445": "              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "444": "#pragma omp simd\n", "446": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "447": "              }\n", "449": "              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n", "448": "#pragma omp simd\n", "450": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "451": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "452": "              }\n", "454": "              for (c4 = (nk > nm?nk : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "453": "#pragma omp simd\n", "455": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "456": "              }\n", "458": "              for (c4 = (nj > nk?nj : nk); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "457": "#pragma omp simd\n", "459": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "460": "              }\n", "461": "            }\n", "462": "            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n", "464": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "463": "#pragma omp simd\n", "465": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "466": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "467": "              }\n", "468": "              if (c1 == c2) {\n", "470": "                for (c4 = nj; c4 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c4++) {\n", "469": "#pragma omp simd\n", "471": "                  A[c3][c4] = ((double )c3) * c4 / ni;\n", "472": "                }\n", "473": "              }\n", "474": "            }\n", "475": "            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n", "477": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n", "476": "#pragma omp simd\n", "478": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "479": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "480": "              }\n", "482": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "481": "#pragma omp simd\n", "483": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "484": "              }\n", "485": "              if (c1 == c2) {\n", "487": "                for (c4 = nk; c4 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c4++) {\n", "486": "#pragma omp simd\n", "488": "                  C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "489": "                }\n", "490": "              }\n", "491": "            }\n", "492": "            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "494": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "493": "#pragma omp simd\n", "495": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "496": "              }\n", "497": "            }\n", "498": "            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n", "500": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n", "499": "#pragma omp simd\n", "501": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "502": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "503": "              }\n", "505": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "504": "#pragma omp simd\n", "506": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "507": "              }\n", "509": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "508": "#pragma omp simd\n", "510": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "511": "              }\n", "512": "            }\n", "513": "            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "515": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "514": "#pragma omp simd\n", "516": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "517": "              }\n", "518": "            }\n", "519": "            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "521": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "520": "#pragma omp simd\n", "522": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "523": "              }\n", "524": "            }\n", "525": "          }\n", "526": "        }\n", "527": "        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n", "528": "          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "529": "            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)) : nm + -1)); c3++) {\n", "531": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "530": "#pragma omp simd\n", "532": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "533": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "534": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "535": "              }\n", "537": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "536": "#pragma omp simd\n", "538": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "539": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "540": "              }\n", "542": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "541": "#pragma omp simd\n", "543": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "544": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "545": "              }\n", "547": "              for (c4 = (nj > nl?nj : nl); c4 <= 16 * c2 + 15; c4++) {\n", "546": "#pragma omp simd\n", "548": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "549": "              }\n", "550": "            }\n", "551": "            for (c3 = nm; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n", "553": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "552": "#pragma omp simd\n", "554": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "555": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "556": "              }\n", "558": "              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n", "557": "#pragma omp simd\n", "559": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "560": "              }\n", "561": "            }\n", "562": "            for (c3 = nk; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n", "564": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "563": "#pragma omp simd\n", "565": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "566": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "567": "              }\n", "569": "              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n", "568": "#pragma omp simd\n", "570": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "571": "              }\n", "572": "            }\n", "573": "            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "575": "              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n", "574": "#pragma omp simd\n", "576": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "577": "              }\n", "578": "            }\n", "579": "            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n", "581": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "580": "#pragma omp simd\n", "582": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "583": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "584": "              }\n", "586": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "585": "#pragma omp simd\n", "587": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "588": "              }\n", "590": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "589": "#pragma omp simd\n", "591": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "592": "              }\n", "593": "            }\n", "594": "            for (c3 = (ni > nm?ni : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "596": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "595": "#pragma omp simd\n", "597": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "598": "              }\n", "599": "            }\n", "600": "            for (c3 = (ni > nk?ni : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "602": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "601": "#pragma omp simd\n", "603": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "604": "              }\n", "605": "            }\n", "606": "          }\n", "607": "        }\n", "608": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n", "609": "          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "610": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n", "612": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "611": "#pragma omp simd\n", "613": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "614": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "615": "              }\n", "617": "              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n", "616": "#pragma omp simd\n", "618": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "619": "              }\n", "620": "            }\n", "621": "            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "623": "              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n", "622": "#pragma omp simd\n", "624": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "625": "              }\n", "626": "            }\n", "627": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "629": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "628": "#pragma omp simd\n", "630": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "631": "              }\n", "632": "            }\n", "633": "          }\n", "634": "        }\n", "635": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n", "636": "          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "637": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n", "639": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "638": "#pragma omp simd\n", "640": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "641": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "642": "              }\n", "644": "              for (c4 = nj; c4 <= 16 * c2 + 15; c4++) {\n", "643": "#pragma omp simd\n", "645": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "646": "              }\n", "647": "            }\n", "648": "            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "650": "              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n", "649": "#pragma omp simd\n", "651": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "652": "              }\n", "653": "            }\n", "654": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "656": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "655": "#pragma omp simd\n", "657": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "658": "              }\n", "659": "            }\n", "660": "          }\n", "661": "        }\n", "662": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n", "663": "          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "664": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n", "666": "              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) < nl + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)) : nl + -1)); c4++) {\n", "665": "#pragma omp simd\n", "667": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "668": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "669": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "670": "              }\n", "672": "              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n", "671": "#pragma omp simd\n", "673": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "674": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "675": "              }\n", "677": "              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n", "676": "#pragma omp simd\n", "678": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "679": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "680": "              }\n", "682": "              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "681": "#pragma omp simd\n", "683": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "684": "              }\n", "686": "              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "685": "#pragma omp simd\n", "687": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "688": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "689": "              }\n", "691": "              for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "690": "#pragma omp simd\n", "692": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "693": "              }\n", "695": "              for (c4 = (nj > nk?nj : nk); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "694": "#pragma omp simd\n", "696": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "697": "              }\n", "698": "            }\n", "699": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "701": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n", "700": "#pragma omp simd\n", "702": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "703": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "704": "              }\n", "706": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "705": "#pragma omp simd\n", "707": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "708": "              }\n", "710": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "709": "#pragma omp simd\n", "711": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "712": "              }\n", "713": "            }\n", "714": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "716": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "715": "#pragma omp simd\n", "717": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "718": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "719": "              }\n", "721": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "720": "#pragma omp simd\n", "722": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "723": "              }\n", "725": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "724": "#pragma omp simd\n", "726": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "727": "              }\n", "728": "            }\n", "729": "            for (c3 = (ni > nm?ni : nm); c3 <= 16 * c1 + 15; c3++) {\n", "731": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "730": "#pragma omp simd\n", "732": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "733": "              }\n", "734": "            }\n", "735": "          }\n", "736": "        }\n", "737": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n", "738": "          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "739": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n", "741": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n", "740": "#pragma omp simd\n", "742": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "743": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "744": "              }\n", "746": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "745": "#pragma omp simd\n", "747": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "748": "              }\n", "750": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "749": "#pragma omp simd\n", "751": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "752": "              }\n", "753": "            }\n", "754": "            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "756": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "755": "#pragma omp simd\n", "757": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "758": "              }\n", "759": "            }\n", "760": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "762": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "761": "#pragma omp simd\n", "763": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "764": "              }\n", "765": "            }\n", "766": "          }\n", "767": "        }\n", "768": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n", "769": "          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n", "770": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n", "772": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n", "771": "#pragma omp simd\n", "773": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "774": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "775": "              }\n", "777": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "776": "#pragma omp simd\n", "778": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "779": "              }\n", "781": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "780": "#pragma omp simd\n", "782": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "783": "              }\n", "784": "            }\n", "785": "            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "787": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "786": "#pragma omp simd\n", "788": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "789": "              }\n", "790": "            }\n", "791": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "793": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "792": "#pragma omp simd\n", "794": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "795": "              }\n", "796": "            }\n", "797": "          }\n", "798": "        }\n", "799": "        if (c1 <= (((((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n", "800": "          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "801": "            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) < nm + -1?((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)) : nm + -1)); c3++) {\n", "803": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n", "802": "#pragma omp simd\n", "804": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "805": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "806": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "807": "              }\n", "809": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "808": "#pragma omp simd\n", "810": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "811": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "812": "              }\n", "814": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "813": "#pragma omp simd\n", "815": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "816": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "817": "              }\n", "819": "              for (c4 = (nk > nl?nk : nl); c4 <= 16 * c2 + 15; c4++) {\n", "818": "#pragma omp simd\n", "820": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "821": "              }\n", "822": "            }\n", "823": "            for (c3 = nm; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n", "825": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "824": "#pragma omp simd\n", "826": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "827": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "828": "              }\n", "830": "              for (c4 = nk; c4 <= 16 * c2 + 15; c4++) {\n", "829": "#pragma omp simd\n", "831": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "832": "              }\n", "833": "            }\n", "834": "            for (c3 = nj; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n", "836": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n", "835": "#pragma omp simd\n", "837": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "838": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "839": "              }\n", "841": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "840": "#pragma omp simd\n", "842": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "843": "              }\n", "845": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "844": "#pragma omp simd\n", "846": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "847": "              }\n", "848": "            }\n", "849": "            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "851": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "850": "#pragma omp simd\n", "852": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "853": "              }\n", "854": "            }\n", "855": "            for (c3 = ni; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n", "857": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "856": "#pragma omp simd\n", "858": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "859": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "860": "              }\n", "862": "              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n", "861": "#pragma omp simd\n", "863": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "864": "              }\n", "865": "            }\n", "866": "            for (c3 = (ni > nm?ni : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "868": "              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n", "867": "#pragma omp simd\n", "869": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "870": "              }\n", "871": "            }\n", "872": "            for (c3 = (ni > nj?ni : nj); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "874": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "873": "#pragma omp simd\n", "875": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "876": "              }\n", "877": "            }\n", "878": "          }\n", "879": "        }\n", "880": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) && c1 >= ((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n", "881": "          for (c2 = 0; c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "882": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n", "884": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n", "883": "#pragma omp simd\n", "885": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "886": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "887": "              }\n", "889": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "888": "#pragma omp simd\n", "890": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "891": "              }\n", "893": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "892": "#pragma omp simd\n", "894": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "895": "              }\n", "896": "            }\n", "897": "            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "899": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "898": "#pragma omp simd\n", "900": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "901": "              }\n", "902": "            }\n", "903": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "905": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "904": "#pragma omp simd\n", "906": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "907": "              }\n", "908": "            }\n", "909": "          }\n", "910": "        }\n", "911": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n", "912": "          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "913": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n", "915": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n", "914": "#pragma omp simd\n", "916": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "917": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "918": "              }\n", "920": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "919": "#pragma omp simd\n", "921": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "922": "              }\n", "924": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "923": "#pragma omp simd\n", "925": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "926": "              }\n", "927": "            }\n", "928": "            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "930": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "929": "#pragma omp simd\n", "931": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "932": "              }\n", "933": "            }\n", "934": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "936": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "935": "#pragma omp simd\n", "937": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "938": "              }\n", "939": "            }\n", "940": "          }\n", "941": "        }\n", "942": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n", "943": "          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "944": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n", "946": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n", "945": "#pragma omp simd\n", "947": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "948": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "949": "              }\n", "951": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "950": "#pragma omp simd\n", "952": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "953": "              }\n", "955": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "954": "#pragma omp simd\n", "956": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "957": "              }\n", "958": "            }\n", "959": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "961": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "960": "#pragma omp simd\n", "962": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "963": "              }\n", "964": "            }\n", "965": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "967": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "966": "#pragma omp simd\n", "968": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "969": "              }\n", "970": "            }\n", "971": "          }\n", "972": "        }\n", "973": "        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n", "974": "          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "975": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "977": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "976": "#pragma omp simd\n", "978": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "979": "              }\n", "980": "            }\n", "981": "          }\n", "982": "        }\n", "983": "        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n", "984": "          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "985": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "987": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "986": "#pragma omp simd\n", "988": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "989": "              }\n", "990": "            }\n", "991": "          }\n", "992": "        }\n", "993": "        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n", "994": "          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n", "995": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "997": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "996": "#pragma omp simd\n", "998": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "999": "              }\n", "1000": "            }\n", "1001": "          }\n", "1002": "        }\n", "1003": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))))) {\n", "1004": "          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1005": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n", "1007": "              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)) : nm + -1)); c4++) {\n", "1006": "#pragma omp simd\n", "1008": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1009": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1010": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1011": "              }\n", "1013": "              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n", "1012": "#pragma omp simd\n", "1014": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1015": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1016": "              }\n", "1018": "              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n", "1017": "#pragma omp simd\n", "1019": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1020": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1021": "              }\n", "1023": "              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1022": "#pragma omp simd\n", "1024": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1025": "              }\n", "1027": "              for (c4 = nk; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "1026": "#pragma omp simd\n", "1028": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1029": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1030": "              }\n", "1032": "              for (c4 = (nk > nl?nk : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1031": "#pragma omp simd\n", "1033": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1034": "              }\n", "1036": "              for (c4 = (nk > nm?nk : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1035": "#pragma omp simd\n", "1037": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1038": "              }\n", "1039": "            }\n", "1040": "            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1042": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n", "1041": "#pragma omp simd\n", "1043": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1044": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1045": "              }\n", "1047": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1046": "#pragma omp simd\n", "1048": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1049": "              }\n", "1051": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1050": "#pragma omp simd\n", "1052": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1053": "              }\n", "1054": "            }\n", "1055": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1057": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "1056": "#pragma omp simd\n", "1058": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1059": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1060": "              }\n", "1062": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1061": "#pragma omp simd\n", "1063": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1064": "              }\n", "1066": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1065": "#pragma omp simd\n", "1067": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1068": "              }\n", "1069": "            }\n", "1070": "            for (c3 = (ni > nj?ni : nj); c3 <= 16 * c1 + 15; c3++) {\n", "1072": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1071": "#pragma omp simd\n", "1073": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1074": "              }\n", "1075": "            }\n", "1076": "          }\n", "1077": "        }\n", "1078": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))))) {\n", "1079": "          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1080": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nj + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nj + -1)); c3++) {\n", "1082": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nm + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nm + -1)); c4++) {\n", "1081": "#pragma omp simd\n", "1083": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1084": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1085": "              }\n", "1087": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1086": "#pragma omp simd\n", "1088": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1089": "              }\n", "1091": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1090": "#pragma omp simd\n", "1092": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1093": "              }\n", "1094": "            }\n", "1095": "            for (c3 = nj; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1097": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1096": "#pragma omp simd\n", "1098": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1099": "              }\n", "1100": "            }\n", "1101": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1103": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1102": "#pragma omp simd\n", "1104": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1105": "              }\n", "1106": "            }\n", "1107": "          }\n", "1108": "        }\n", "1109": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n", "1110": "          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1111": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n", "1113": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n", "1112": "#pragma omp simd\n", "1114": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1115": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1116": "              }\n", "1118": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1117": "#pragma omp simd\n", "1119": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1120": "              }\n", "1122": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1121": "#pragma omp simd\n", "1123": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1124": "              }\n", "1125": "            }\n", "1126": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1128": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1127": "#pragma omp simd\n", "1129": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1130": "              }\n", "1131": "            }\n", "1132": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1134": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1133": "#pragma omp simd\n", "1135": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1136": "              }\n", "1137": "            }\n", "1138": "          }\n", "1139": "        }\n", "1140": "        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n", "1141": "          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1142": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1144": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1143": "#pragma omp simd\n", "1145": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1146": "              }\n", "1147": "            }\n", "1148": "          }\n", "1149": "        }\n", "1150": "        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n", "1151": "          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1152": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1154": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1153": "#pragma omp simd\n", "1155": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1156": "              }\n", "1157": "            }\n", "1158": "          }\n", "1159": "        }\n", "1160": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n", "1161": "          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1162": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n", "1164": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n", "1163": "#pragma omp simd\n", "1165": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1166": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1167": "              }\n", "1169": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1168": "#pragma omp simd\n", "1170": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1171": "              }\n", "1173": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1172": "#pragma omp simd\n", "1174": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1175": "              }\n", "1176": "            }\n", "1177": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1179": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1178": "#pragma omp simd\n", "1180": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1181": "              }\n", "1182": "            }\n", "1183": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1185": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1184": "#pragma omp simd\n", "1186": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1187": "              }\n", "1188": "            }\n", "1189": "          }\n", "1190": "        }\n", "1191": "        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n", "1192": "          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1193": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1195": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1194": "#pragma omp simd\n", "1196": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1197": "              }\n", "1198": "            }\n", "1199": "          }\n", "1200": "        }\n", "1201": "        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n", "1202": "          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n", "1203": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1205": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1204": "#pragma omp simd\n", "1206": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1207": "              }\n", "1208": "            }\n", "1209": "          }\n", "1210": "        }\n", "1211": "        if (c1 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n", "1212": "          for (c2 = 0; c2 <= (((((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1213": "            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n", "1215": "              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n", "1214": "#pragma omp simd\n", "1216": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1217": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1218": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1219": "              }\n", "1221": "              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n", "1220": "#pragma omp simd\n", "1222": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1223": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1224": "              }\n", "1226": "              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "1225": "#pragma omp simd\n", "1227": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1228": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1229": "              }\n", "1231": "              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1230": "#pragma omp simd\n", "1232": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1233": "              }\n", "1235": "              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "1234": "#pragma omp simd\n", "1236": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1237": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1238": "              }\n", "1240": "              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1239": "#pragma omp simd\n", "1241": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1242": "              }\n", "1244": "              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1243": "#pragma omp simd\n", "1245": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1246": "              }\n", "1247": "            }\n", "1248": "            for (c3 = nm; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n", "1250": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1249": "#pragma omp simd\n", "1251": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1252": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1253": "              }\n", "1254": "              if (c1 == c2) {\n", "1256": "                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n", "1255": "#pragma omp simd\n", "1257": "                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1258": "                }\n", "1259": "              }\n", "1260": "            }\n", "1261": "            for (c3 = nj; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n", "1263": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "1262": "#pragma omp simd\n", "1264": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1265": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1266": "              }\n", "1268": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1267": "#pragma omp simd\n", "1269": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1270": "              }\n", "1271": "              if (c1 == c2) {\n", "1273": "                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n", "1272": "#pragma omp simd\n", "1274": "                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1275": "                }\n", "1276": "              }\n", "1277": "            }\n", "1278": "            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1280": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1279": "#pragma omp simd\n", "1281": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1282": "              }\n", "1283": "            }\n", "1284": "            for (c3 = nk; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n", "1286": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "1285": "#pragma omp simd\n", "1287": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1288": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1289": "              }\n", "1291": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1290": "#pragma omp simd\n", "1292": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1293": "              }\n", "1294": "              if (c1 == c2) {\n", "1296": "                for (c4 = nm; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n", "1295": "#pragma omp simd\n", "1297": "                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1298": "                }\n", "1299": "              }\n", "1300": "            }\n", "1301": "            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1303": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1302": "#pragma omp simd\n", "1304": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1305": "              }\n", "1306": "            }\n", "1307": "            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1309": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1308": "#pragma omp simd\n", "1310": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1311": "              }\n", "1312": "            }\n", "1313": "          }\n", "1314": "        }\n", "1315": "        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n", "1316": "          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1317": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n", "1319": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1318": "#pragma omp simd\n", "1320": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1321": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1322": "              }\n", "1324": "              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n", "1323": "#pragma omp simd\n", "1325": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1326": "              }\n", "1327": "            }\n", "1328": "            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1330": "              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n", "1329": "#pragma omp simd\n", "1331": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1332": "              }\n", "1333": "            }\n", "1334": "            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1336": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1335": "#pragma omp simd\n", "1337": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1338": "              }\n", "1339": "            }\n", "1340": "          }\n", "1341": "        }\n", "1342": "        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n", "1343": "          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1344": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n", "1346": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n", "1345": "#pragma omp simd\n", "1347": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1348": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1349": "              }\n", "1351": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1350": "#pragma omp simd\n", "1352": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1353": "              }\n", "1355": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1354": "#pragma omp simd\n", "1356": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1357": "              }\n", "1358": "            }\n", "1359": "            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1361": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1360": "#pragma omp simd\n", "1362": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1363": "              }\n", "1364": "            }\n", "1365": "            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1367": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1366": "#pragma omp simd\n", "1368": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1369": "              }\n", "1370": "            }\n", "1371": "          }\n", "1372": "        }\n", "1373": "        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n", "1374": "          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1375": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n", "1377": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "1376": "#pragma omp simd\n", "1378": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1379": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1380": "              }\n", "1382": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1381": "#pragma omp simd\n", "1383": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1384": "              }\n", "1386": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1385": "#pragma omp simd\n", "1387": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1388": "              }\n", "1389": "            }\n", "1390": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1392": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1391": "#pragma omp simd\n", "1393": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1394": "              }\n", "1395": "            }\n", "1396": "            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1398": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1397": "#pragma omp simd\n", "1399": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1400": "              }\n", "1401": "            }\n", "1402": "          }\n", "1403": "        }\n", "1404": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n", "1405": "          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1406": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1408": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1407": "#pragma omp simd\n", "1409": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1410": "              }\n", "1411": "            }\n", "1412": "          }\n", "1413": "        }\n", "1414": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n", "1415": "          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1416": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1418": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1417": "#pragma omp simd\n", "1419": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1420": "              }\n", "1421": "            }\n", "1422": "          }\n", "1423": "        }\n", "1424": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n", "1425": "          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1426": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1428": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "1427": "#pragma omp simd\n", "1429": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1430": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1431": "              }\n", "1433": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1432": "#pragma omp simd\n", "1434": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1435": "              }\n", "1437": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1436": "#pragma omp simd\n", "1438": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1439": "              }\n", "1440": "            }\n", "1441": "            for (c3 = nm; c3 <= 16 * c1 + 15; c3++) {\n", "1443": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1442": "#pragma omp simd\n", "1444": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1445": "              }\n", "1446": "            }\n", "1447": "          }\n", "1448": "        }\n", "1449": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n", "1450": "          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1451": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1453": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1452": "#pragma omp simd\n", "1454": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1455": "              }\n", "1456": "            }\n", "1457": "          }\n", "1458": "        }\n", "1459": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n", "1460": "          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n", "1461": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1463": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1462": "#pragma omp simd\n", "1464": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1465": "              }\n", "1466": "            }\n", "1467": "          }\n", "1468": "        }\n", "1469": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n", "1470": "          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1471": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1473": "              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n", "1472": "#pragma omp simd\n", "1474": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1475": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1476": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1477": "              }\n", "1479": "              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n", "1478": "#pragma omp simd\n", "1480": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1481": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1482": "              }\n", "1484": "              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "1483": "#pragma omp simd\n", "1485": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1486": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1487": "              }\n", "1489": "              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1488": "#pragma omp simd\n", "1490": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1491": "              }\n", "1493": "              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "1492": "#pragma omp simd\n", "1494": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1495": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1496": "              }\n", "1498": "              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1497": "#pragma omp simd\n", "1499": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1500": "              }\n", "1502": "              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1501": "#pragma omp simd\n", "1503": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1504": "              }\n", "1505": "            }\n", "1506": "            for (c3 = nk; c3 <= 16 * c1 + 15; c3++) {\n", "1508": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "1507": "#pragma omp simd\n", "1509": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1510": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1511": "              }\n", "1513": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1512": "#pragma omp simd\n", "1514": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1515": "              }\n", "1517": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1516": "#pragma omp simd\n", "1518": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1519": "              }\n", "1520": "            }\n", "1521": "          }\n", "1522": "        }\n", "1523": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n", "1524": "          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1525": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1527": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n", "1526": "#pragma omp simd\n", "1528": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1529": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1530": "              }\n", "1532": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1531": "#pragma omp simd\n", "1533": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1534": "              }\n", "1536": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1535": "#pragma omp simd\n", "1537": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1538": "              }\n", "1539": "            }\n", "1540": "            for (c3 = nk; c3 <= 16 * c1 + 15; c3++) {\n", "1542": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1541": "#pragma omp simd\n", "1543": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1544": "              }\n", "1545": "            }\n", "1546": "          }\n", "1547": "        }\n", "1548": "        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n", "1549": "          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1550": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n", "1552": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "1551": "#pragma omp simd\n", "1553": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1554": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1555": "              }\n", "1557": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1556": "#pragma omp simd\n", "1558": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1559": "              }\n", "1561": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1560": "#pragma omp simd\n", "1562": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1563": "              }\n", "1564": "            }\n", "1565": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1567": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1566": "#pragma omp simd\n", "1568": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1569": "              }\n", "1570": "            }\n", "1571": "            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1573": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1572": "#pragma omp simd\n", "1574": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1575": "              }\n", "1576": "            }\n", "1577": "          }\n", "1578": "        }\n", "1579": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n", "1580": "          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1581": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1583": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1582": "#pragma omp simd\n", "1584": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1585": "              }\n", "1586": "            }\n", "1587": "          }\n", "1588": "        }\n", "1589": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n", "1590": "          for (c2 = (((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n", "1591": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1593": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1592": "#pragma omp simd\n", "1594": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1595": "              }\n", "1596": "            }\n", "1597": "          }\n", "1598": "        }\n", "1599": "        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n", "1600": "          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1601": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n", "1603": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1602": "#pragma omp simd\n", "1604": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1605": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1606": "              }\n", "1608": "              for (c4 = nl; c4 <= 16 * c2 + 15; c4++) {\n", "1607": "#pragma omp simd\n", "1609": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1610": "              }\n", "1611": "            }\n", "1612": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1614": "              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n", "1613": "#pragma omp simd\n", "1615": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1616": "              }\n", "1617": "            }\n", "1618": "            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1620": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1619": "#pragma omp simd\n", "1621": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1622": "              }\n", "1623": "            }\n", "1624": "          }\n", "1625": "        }\n", "1626": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n", "1627": "          for (c2 = 0; c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1628": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1630": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1629": "#pragma omp simd\n", "1631": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1632": "              }\n", "1633": "            }\n", "1634": "          }\n", "1635": "        }\n", "1636": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n", "1637": "          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1638": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1640": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1639": "#pragma omp simd\n", "1641": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1642": "              }\n", "1643": "            }\n", "1644": "          }\n", "1645": "        }\n", "1646": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n", "1647": "          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1648": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1650": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "1649": "#pragma omp simd\n", "1651": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1652": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1653": "              }\n", "1655": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1654": "#pragma omp simd\n", "1656": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1657": "              }\n", "1659": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1658": "#pragma omp simd\n", "1660": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1661": "              }\n", "1662": "            }\n", "1663": "            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n", "1665": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1664": "#pragma omp simd\n", "1666": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1667": "              }\n", "1668": "            }\n", "1669": "          }\n", "1670": "        }\n", "1671": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n", "1672": "          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1673": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1675": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1674": "#pragma omp simd\n", "1676": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1677": "              }\n", "1678": "            }\n", "1679": "          }\n", "1680": "        }\n", "1681": "        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n", "1682": "          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1683": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n", "1685": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "1684": "#pragma omp simd\n", "1686": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1687": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1688": "              }\n", "1690": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1689": "#pragma omp simd\n", "1691": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1692": "              }\n", "1694": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1693": "#pragma omp simd\n", "1695": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1696": "              }\n", "1697": "            }\n", "1698": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1700": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1699": "#pragma omp simd\n", "1701": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1702": "              }\n", "1703": "            }\n", "1704": "            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1706": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1705": "#pragma omp simd\n", "1707": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1708": "              }\n", "1709": "            }\n", "1710": "          }\n", "1711": "        }\n", "1712": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n", "1713": "          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1714": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1716": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1715": "#pragma omp simd\n", "1717": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1718": "              }\n", "1719": "            }\n", "1720": "          }\n", "1721": "        }\n", "1722": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n", "1723": "          for (c2 = (((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1724": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1726": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1725": "#pragma omp simd\n", "1727": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1728": "              }\n", "1729": "            }\n", "1730": "          }\n", "1731": "        }\n", "1732": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n", "1733": "          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1734": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1736": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "1735": "#pragma omp simd\n", "1737": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1738": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1739": "              }\n", "1741": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1740": "#pragma omp simd\n", "1742": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1743": "              }\n", "1745": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1744": "#pragma omp simd\n", "1746": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1747": "              }\n", "1748": "            }\n", "1749": "            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n", "1751": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1750": "#pragma omp simd\n", "1752": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1753": "              }\n", "1754": "            }\n", "1755": "          }\n", "1756": "        }\n", "1757": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n", "1758": "          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n", "1759": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "1761": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "1760": "#pragma omp simd\n", "1762": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "1763": "              }\n", "1764": "            }\n", "1765": "          }\n", "1766": "        }\n", "1767": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n", "1768": "          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1769": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1771": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1770": "#pragma omp simd\n", "1772": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1773": "              }\n", "1774": "            }\n", "1775": "          }\n", "1776": "        }\n", "1777": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n", "1778": "          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1779": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1781": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1780": "#pragma omp simd\n", "1782": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1783": "              }\n", "1784": "            }\n", "1785": "          }\n", "1786": "        }\n", "1787": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) > ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))?((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16)))) : ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))))) {\n", "1788": "          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1789": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1791": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1790": "#pragma omp simd\n", "1792": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1793": "              }\n", "1794": "            }\n", "1795": "          }\n", "1796": "        }\n", "1797": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n", "1798": "          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1799": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1801": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1800": "#pragma omp simd\n", "1802": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1803": "              }\n", "1804": "            }\n", "1805": "          }\n", "1806": "        }\n", "1807": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n", "1808": "          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1809": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1811": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1810": "#pragma omp simd\n", "1812": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1813": "              }\n", "1814": "            }\n", "1815": "          }\n", "1816": "        }\n", "1817": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n", "1818": "          for (c2 = (((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n", "1819": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1821": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1820": "#pragma omp simd\n", "1822": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1823": "              }\n", "1824": "            }\n", "1825": "          }\n", "1826": "        }\n", "1827": "      }\n", "1831": "      for (c1 = 0; c1 <= (((((nk + ni + -1) * 16 < 0?((16 < 0?-((-(nk + ni + -1) + 16 + 1) / 16) : -((-(nk + ni + -1) + 16 - 1) / 16))) : (nk + ni + -1) / 16)) < (((nk + ni + nj + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + -2) + 16 - 1) / 16))) : (nk + ni + nj + -2) / 16))?(((nk + ni + -1) * 16 < 0?((16 < 0?-((-(nk + ni + -1) + 16 + 1) / 16) : -((-(nk + ni + -1) + 16 - 1) / 16))) : (nk + ni + -1) / 16)) : (((nk + ni + nj + -2) * 16 < 0?((16 < 0?-((-(nk + ni + nj + -2) + 16 + 1) / 16) : -((-(nk + ni + nj + -2) + 16 - 1) / 16))) : (nk + ni + nj + -2) / 16)))); c1++) {\n", "1830": "#pragma omp parallel for private(c2, c4, c3)\n", "1832": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n", "1833": "          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n", "1834": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nk + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nk + -1)); c3++) {\n", "1836": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nk + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nk + -1)); c4++) {\n", "1835": "#pragma omp simd\n", "1837": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1838": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1839": "              }\n", "1841": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1840": "#pragma omp simd\n", "1842": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1843": "              }\n", "1845": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1844": "#pragma omp simd\n", "1846": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1847": "              }\n", "1848": "            }\n", "1849": "            for (c3 = nk; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1851": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1850": "#pragma omp simd\n", "1852": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1853": "              }\n", "1854": "            }\n", "1855": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1857": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1856": "#pragma omp simd\n", "1858": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1859": "              }\n", "1860": "            }\n", "1861": "          }\n", "1862": "        }\n", "1863": "        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n", "1864": "          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n", "1865": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1867": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1866": "#pragma omp simd\n", "1868": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1869": "              }\n", "1870": "            }\n", "1871": "          }\n", "1872": "        }\n", "1873": "        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n", "1874": "          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n", "1875": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1877": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1876": "#pragma omp simd\n", "1878": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1879": "              }\n", "1880": "            }\n", "1881": "          }\n", "1882": "        }\n", "1883": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n", "1884": "          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))); c2++) {\n", "1885": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1887": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1886": "#pragma omp simd\n", "1888": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1889": "              }\n", "1890": "            }\n", "1891": "          }\n", "1892": "        }\n", "1893": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n", "1894": "          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n", "1895": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "1897": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "1896": "#pragma omp simd\n", "1898": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "1899": "              }\n", "1900": "            }\n", "1901": "          }\n", "1902": "        }\n", "1903": "      }\n", "1907": "      for (c1 = 0; c1 <= (((ni + nm + -1) * 16 < 0?((16 < 0?-((-(ni + nm + -1) + 16 + 1) / 16) : -((-(ni + nm + -1) + 16 - 1) / 16))) : (ni + nm + -1) / 16)); c1++) {\n", "1906": "#pragma omp parallel for private(c2, c4, c3)\n", "1908": "        if (c1 <= (((((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n", "1909": "          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1910": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) < nm + -1?((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)) : nm + -1)); c3++) {\n", "1912": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) < nl + -1?((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)) : nl + -1)); c4++) {\n", "1911": "#pragma omp simd\n", "1913": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1914": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1915": "              }\n", "1917": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1916": "#pragma omp simd\n", "1918": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1919": "              }\n", "1921": "              for (c4 = nk; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1920": "#pragma omp simd\n", "1922": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1923": "              }\n", "1924": "            }\n", "1925": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1927": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1926": "#pragma omp simd\n", "1928": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1929": "              }\n", "1930": "            }\n", "1931": "            for (c3 = ni; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1933": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1932": "#pragma omp simd\n", "1934": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1935": "              }\n", "1936": "            }\n", "1937": "          }\n", "1938": "        }\n", "1939": "        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n", "1940": "          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1941": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1943": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1942": "#pragma omp simd\n", "1944": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1945": "              }\n", "1946": "            }\n", "1947": "          }\n", "1948": "        }\n", "1949": "        if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n", "1950": "          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n", "1951": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1953": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1952": "#pragma omp simd\n", "1954": "                A[c3][c4] = ((double )c3) * c4 / ni;\n", "1955": "              }\n", "1956": "            }\n", "1957": "          }\n", "1958": "        }\n", "1959": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((ni * 16 < 0?-(-ni / 16) : ((16 < 0?(-ni + - 16 - 1) / - 16 : (ni + 16 - 1) / 16))))) {\n", "1960": "          for (c2 = 0; c2 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "1961": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1963": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1962": "#pragma omp simd\n", "1964": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1965": "              }\n", "1966": "            }\n", "1967": "          }\n", "1968": "        }\n", "1969": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n", "1970": "          for (c2 = (nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n", "1971": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "1973": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "1972": "#pragma omp simd\n", "1974": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "1975": "              }\n", "1976": "            }\n", "1977": "          }\n", "1978": "        }\n", "1979": "      }\n", "1983": "      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n", "1982": "#pragma omp parallel for private(c2, c4, c3)\n", "1984": "        for (c2 = 0; c2 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c2++) {\n", "1985": "          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c3++) {\n", "1987": "            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nk + -1?16 * c2 + 15 : nk + -1)); c4++) {\n", "1986": "#pragma omp simd\n", "1988": "              A[c3][c4] = ((double )c3) * c4 / ni;\n", "1989": "            }\n", "1990": "          }\n", "1991": "        }\n", "1992": "      }\n", "1996": "      for (c1 = 0; c1 <= (((nj + nm + -1) * 16 < 0?((16 < 0?-((-(nj + nm + -1) + 16 + 1) / 16) : -((-(nj + nm + -1) + 16 - 1) / 16))) : (nj + nm + -1) / 16)); c1++) {\n", "1995": "#pragma omp parallel for private(c2, c4, c3)\n", "1997": "        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n", "1998": "          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "1999": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n", "2001": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "2000": "#pragma omp simd\n", "2002": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2003": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2004": "              }\n", "2006": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2005": "#pragma omp simd\n", "2007": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2008": "              }\n", "2010": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2009": "#pragma omp simd\n", "2011": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2012": "              }\n", "2013": "            }\n", "2014": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2016": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2015": "#pragma omp simd\n", "2017": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2018": "              }\n", "2019": "            }\n", "2020": "            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2022": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2021": "#pragma omp simd\n", "2023": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2024": "              }\n", "2025": "            }\n", "2026": "          }\n", "2027": "        }\n", "2028": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n", "2029": "          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2030": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2032": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2031": "#pragma omp simd\n", "2033": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2034": "              }\n", "2035": "            }\n", "2036": "          }\n", "2037": "        }\n", "2038": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n", "2039": "          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n", "2040": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2042": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2041": "#pragma omp simd\n", "2043": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2044": "              }\n", "2045": "            }\n", "2046": "          }\n", "2047": "        }\n", "2048": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n", "2049": "          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2050": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2052": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2051": "#pragma omp simd\n", "2053": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2054": "              }\n", "2055": "            }\n", "2056": "          }\n", "2057": "        }\n", "2058": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n", "2059": "          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n", "2060": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2062": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2061": "#pragma omp simd\n", "2063": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2064": "              }\n", "2065": "            }\n", "2066": "          }\n", "2067": "        }\n", "2068": "      }\n", "2072": "      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n", "2071": "#pragma omp parallel for private(c2, c4, c3)\n", "2073": "        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n", "2074": "          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2076": "            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2075": "#pragma omp simd\n", "2077": "              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2078": "            }\n", "2079": "          }\n", "2080": "        }\n", "2081": "      }\n", "2085": "      for (c1 = 0; c1 <= (((((nk + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + nj + nm + -1) + 16 - 1) / 16))) : (nk + nj + nm + -1) / 16)) < (((nk + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + nj + 2 * nm + -2) / 16))?(((nk + nj + nm + -1) * 16 < 0?((16 < 0?-((-(nk + nj + nm + -1) + 16 + 1) / 16) : -((-(nk + nj + nm + -1) + 16 - 1) / 16))) : (nk + nj + nm + -1) / 16)) : (((nk + nj + 2 * nm + -2) * 16 < 0?((16 < 0?-((-(nk + nj + 2 * nm + -2) + 16 + 1) / 16) : -((-(nk + nj + 2 * nm + -2) + 16 - 1) / 16))) : (nk + nj + 2 * nm + -2) / 16)))); c1++) {\n", "2084": "#pragma omp parallel for private(c2, c4, c3)\n", "2086": "        if (c1 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n", "2087": "          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2088": "            for (c3 = 16 * c1; c3 <= ((((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) < nm + -1?((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)) : nm + -1)); c3++) {\n", "2090": "              for (c4 = 16 * c2; c4 <= ((((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) < nm + -1?((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)) : nm + -1)); c4++) {\n", "2089": "#pragma omp simd\n", "2091": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2092": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2093": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2094": "              }\n", "2096": "              for (c4 = nl; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n", "2095": "#pragma omp simd\n", "2097": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2098": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2099": "              }\n", "2101": "              for (c4 = nm; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "2100": "#pragma omp simd\n", "2102": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2103": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2104": "              }\n", "2106": "              for (c4 = (nl > nm?nl : nm); c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2105": "#pragma omp simd\n", "2107": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2108": "              }\n", "2110": "              for (c4 = nj; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "2109": "#pragma omp simd\n", "2111": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2112": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2113": "              }\n", "2115": "              for (c4 = (nj > nl?nj : nl); c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2114": "#pragma omp simd\n", "2116": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2117": "              }\n", "2119": "              for (c4 = (nj > nm?nj : nm); c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2118": "#pragma omp simd\n", "2120": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2121": "              }\n", "2122": "            }\n", "2123": "            for (c3 = nm; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n", "2125": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2124": "#pragma omp simd\n", "2126": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2127": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2128": "              }\n", "2129": "              if (c1 == c2) {\n", "2131": "                for (c4 = nm; c4 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c4++) {\n", "2130": "#pragma omp simd\n", "2132": "                  B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2133": "                }\n", "2134": "              }\n", "2135": "            }\n", "2136": "            for (c3 = nj; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n", "2138": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "2137": "#pragma omp simd\n", "2139": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2140": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2141": "              }\n", "2143": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2142": "#pragma omp simd\n", "2144": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2145": "              }\n", "2146": "              if (c1 == c2) {\n", "2148": "                for (c4 = nj; c4 <= ((16 * c1 + 15 < nl + -1?16 * c1 + 15 : nl + -1)); c4++) {\n", "2147": "#pragma omp simd\n", "2149": "                  D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2150": "                }\n", "2151": "              }\n", "2152": "            }\n", "2153": "            for (c3 = (nj > nm?nj : nm); c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "2155": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2154": "#pragma omp simd\n", "2156": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2157": "              }\n", "2158": "            }\n", "2159": "            for (c3 = nk; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n", "2161": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "2160": "#pragma omp simd\n", "2162": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2163": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2164": "              }\n", "2166": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2165": "#pragma omp simd\n", "2167": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2168": "              }\n", "2170": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2169": "#pragma omp simd\n", "2171": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2172": "              }\n", "2173": "            }\n", "2174": "            for (c3 = (nk > nm?nk : nm); c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2176": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2175": "#pragma omp simd\n", "2177": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2178": "              }\n", "2179": "            }\n", "2180": "            for (c3 = (nj > nk?nj : nk); c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2182": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2181": "#pragma omp simd\n", "2183": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2184": "              }\n", "2185": "            }\n", "2186": "          }\n", "2187": "        }\n", "2188": "        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)))) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n", "2189": "          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2190": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n", "2192": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2191": "#pragma omp simd\n", "2193": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2194": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2195": "              }\n", "2197": "              for (c4 = nm; c4 <= 16 * c2 + 15; c4++) {\n", "2196": "#pragma omp simd\n", "2198": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2199": "              }\n", "2200": "            }\n", "2201": "            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "2203": "              for (c4 = 16 * c2; c4 <= 16 * c2 + 15; c4++) {\n", "2202": "#pragma omp simd\n", "2204": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2205": "              }\n", "2206": "            }\n", "2207": "            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2209": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2208": "#pragma omp simd\n", "2210": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2211": "              }\n", "2212": "            }\n", "2213": "          }\n", "2214": "        }\n", "2215": "        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))))) {\n", "2216": "          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2217": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nk + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nk + -1)); c3++) {\n", "2219": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nm + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nm + -1)); c4++) {\n", "2218": "#pragma omp simd\n", "2220": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2221": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2222": "              }\n", "2224": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2223": "#pragma omp simd\n", "2225": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2226": "              }\n", "2228": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2227": "#pragma omp simd\n", "2229": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2230": "              }\n", "2231": "            }\n", "2232": "            for (c3 = nj; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "2234": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2233": "#pragma omp simd\n", "2235": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2236": "              }\n", "2237": "            }\n", "2238": "            for (c3 = nk; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2240": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2239": "#pragma omp simd\n", "2241": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2242": "              }\n", "2243": "            }\n", "2244": "          }\n", "2245": "        }\n", "2246": "        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n", "2247": "          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "2248": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n", "2250": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "2249": "#pragma omp simd\n", "2251": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2252": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2253": "              }\n", "2255": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2254": "#pragma omp simd\n", "2256": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2257": "              }\n", "2259": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2258": "#pragma omp simd\n", "2260": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2261": "              }\n", "2262": "            }\n", "2263": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "2265": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2264": "#pragma omp simd\n", "2266": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2267": "              }\n", "2268": "            }\n", "2269": "            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2271": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2270": "#pragma omp simd\n", "2272": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2273": "              }\n", "2274": "            }\n", "2275": "          }\n", "2276": "        }\n", "2277": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n", "2278": "          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2279": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "2281": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2280": "#pragma omp simd\n", "2282": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2283": "              }\n", "2284": "            }\n", "2285": "          }\n", "2286": "        }\n", "2287": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n", "2288": "          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2289": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "2291": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2290": "#pragma omp simd\n", "2292": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2293": "              }\n", "2294": "            }\n", "2295": "          }\n", "2296": "        }\n", "2297": "        if (c1 <= (((((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n", "2298": "          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "2299": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) < nm + -1?((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)) : nm + -1)); c3++) {\n", "2301": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) < nl + -1?((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)) : nl + -1)); c4++) {\n", "2300": "#pragma omp simd\n", "2302": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2303": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2304": "              }\n", "2306": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2305": "#pragma omp simd\n", "2307": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2308": "              }\n", "2310": "              for (c4 = nj; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2309": "#pragma omp simd\n", "2311": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2312": "              }\n", "2313": "            }\n", "2314": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "2316": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2315": "#pragma omp simd\n", "2317": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2318": "              }\n", "2319": "            }\n", "2320": "            for (c3 = nk; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2322": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2321": "#pragma omp simd\n", "2323": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2324": "              }\n", "2325": "            }\n", "2326": "          }\n", "2327": "        }\n", "2328": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n", "2329": "          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "2330": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "2332": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2331": "#pragma omp simd\n", "2333": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2334": "              }\n", "2335": "            }\n", "2336": "          }\n", "2337": "        }\n", "2338": "        if (c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16))) {\n", "2339": "          for (c2 = (((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n", "2340": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "2342": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2341": "#pragma omp simd\n", "2343": "                B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2344": "              }\n", "2345": "            }\n", "2346": "          }\n", "2347": "        }\n", "2348": "        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n", "2349": "          for (c2 = 0; c2 <= (((((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2350": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n", "2352": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "2351": "#pragma omp simd\n", "2353": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2354": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2355": "              }\n", "2357": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2356": "#pragma omp simd\n", "2358": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2359": "              }\n", "2361": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2360": "#pragma omp simd\n", "2362": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2363": "              }\n", "2364": "            }\n", "2365": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2367": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2366": "#pragma omp simd\n", "2368": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2369": "              }\n", "2370": "            }\n", "2371": "            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2373": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2372": "#pragma omp simd\n", "2374": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2375": "              }\n", "2376": "            }\n", "2377": "          }\n", "2378": "        }\n", "2379": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))))) {\n", "2380": "          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2381": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2383": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2382": "#pragma omp simd\n", "2384": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2385": "              }\n", "2386": "            }\n", "2387": "          }\n", "2388": "        }\n", "2389": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n", "2390": "          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2391": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2393": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2392": "#pragma omp simd\n", "2394": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2395": "              }\n", "2396": "            }\n", "2397": "          }\n", "2398": "        }\n", "2399": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n", "2400": "          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2401": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2403": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "2402": "#pragma omp simd\n", "2404": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2405": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2406": "              }\n", "2408": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2407": "#pragma omp simd\n", "2409": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2410": "              }\n", "2412": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2411": "#pragma omp simd\n", "2413": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2414": "              }\n", "2415": "            }\n", "2416": "            for (c3 = nj; c3 <= 16 * c1 + 15; c3++) {\n", "2418": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2417": "#pragma omp simd\n", "2419": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2420": "              }\n", "2421": "            }\n", "2422": "          }\n", "2423": "        }\n", "2424": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n", "2425": "          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n", "2426": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2428": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2427": "#pragma omp simd\n", "2429": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2430": "              }\n", "2431": "            }\n", "2432": "          }\n", "2433": "        }\n", "2434": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))))) {\n", "2435": "          for (c2 = 0; c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "2436": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2438": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2437": "#pragma omp simd\n", "2439": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2440": "              }\n", "2441": "            }\n", "2442": "          }\n", "2443": "        }\n", "2444": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nk * 16 < 0?-(-nk / 16) : ((16 < 0?(-nk + - 16 - 1) / - 16 : (nk + 16 - 1) / 16))))) {\n", "2445": "          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)))); c2++) {\n", "2446": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2448": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2447": "#pragma omp simd\n", "2449": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2450": "              }\n", "2451": "            }\n", "2452": "          }\n", "2453": "        }\n", "2454": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n", "2455": "          for (c2 = (nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))); c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2456": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2458": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2457": "#pragma omp simd\n", "2459": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2460": "              }\n", "2461": "            }\n", "2462": "          }\n", "2463": "        }\n", "2464": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n", "2465": "          for (c2 = (((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) > ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))?((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16)))) : ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n", "2466": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2468": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2467": "#pragma omp simd\n", "2469": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2470": "              }\n", "2471": "            }\n", "2472": "          }\n", "2473": "        }\n", "2474": "      }\n", "2478": "      for (c1 = 0; c1 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c1++) {\n", "2477": "#pragma omp parallel for private(c2, c4, c3)\n", "2479": "        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n", "2480": "          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nk + -1?16 * c1 + 15 : nk + -1)); c3++) {\n", "2482": "            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c4++) {\n", "2481": "#pragma omp simd\n", "2483": "              B[c3][c4] = ((double )c3) * (c4 + 1) / nj;\n", "2484": "            }\n", "2485": "          }\n", "2486": "        }\n", "2487": "      }\n", "2491": "      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n", "2490": "#pragma omp parallel for private(c2, c4, c3)\n", "2492": "        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n", "2493": "          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2495": "            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2494": "#pragma omp simd\n", "2496": "              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2497": "            }\n", "2498": "          }\n", "2499": "        }\n", "2500": "      }\n", "2504": "      for (c1 = 0; c1 <= (((nj + nm + -1) * 16 < 0?((16 < 0?-((-(nj + nm + -1) + 16 + 1) / 16) : -((-(nj + nm + -1) + 16 - 1) / 16))) : (nj + nm + -1) / 16)); c1++) {\n", "2503": "#pragma omp parallel for private(c2, c4, c3)\n", "2505": "        if (c1 <= (((((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))))) {\n", "2506": "          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2507": "            for (c3 = 16 * c1; c3 <= ((((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) < nm + -1?((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)) : nm + -1)); c3++) {\n", "2509": "              for (c4 = 16 * c2; c4 <= ((((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) < nm + -1?((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)) : nm + -1)); c4++) {\n", "2508": "#pragma omp simd\n", "2510": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2511": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2512": "              }\n", "2514": "              for (c4 = nl; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2513": "#pragma omp simd\n", "2515": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2516": "              }\n", "2518": "              for (c4 = nm; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2517": "#pragma omp simd\n", "2519": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2520": "              }\n", "2521": "            }\n", "2522": "            for (c3 = nm; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2524": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2523": "#pragma omp simd\n", "2525": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2526": "              }\n", "2527": "            }\n", "2528": "            for (c3 = nj; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2530": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2529": "#pragma omp simd\n", "2531": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2532": "              }\n", "2533": "            }\n", "2534": "          }\n", "2535": "        }\n", "2536": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)) && c1 >= ((nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))))) {\n", "2537": "          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2538": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2540": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2539": "#pragma omp simd\n", "2541": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2542": "              }\n", "2543": "            }\n", "2544": "          }\n", "2545": "        }\n", "2546": "        if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n", "2547": "          for (c2 = (0 > ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))?0 : ((nl * 16 < 0?-(-nl / 16) : ((16 < 0?(-nl + - 16 - 1) / - 16 : (nl + 16 - 1) / 16))))); c2 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c2++) {\n", "2548": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c3++) {\n", "2550": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nm + -1?16 * c2 + 15 : nm + -1)); c4++) {\n", "2549": "#pragma omp simd\n", "2551": "                C[c3][c4] = ((double )c3) * (c4 + 3) / nl;\n", "2552": "              }\n", "2553": "            }\n", "2554": "          }\n", "2555": "        }\n", "2556": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)) && c1 >= ((nj * 16 < 0?-(-nj / 16) : ((16 < 0?(-nj + - 16 - 1) / - 16 : (nj + 16 - 1) / 16))))) {\n", "2557": "          for (c2 = 0; c2 <= (((((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) < (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))?(((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)) : (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)))); c2++) {\n", "2558": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2560": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2559": "#pragma omp simd\n", "2561": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2562": "              }\n", "2563": "            }\n", "2564": "          }\n", "2565": "        }\n", "2566": "        if (c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16))) {\n", "2567": "          for (c2 = (nm * 16 < 0?-(-nm / 16) : ((16 < 0?(-nm + - 16 - 1) / - 16 : (nm + 16 - 1) / 16))); c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n", "2568": "            for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2570": "              for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2569": "#pragma omp simd\n", "2571": "                D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2572": "              }\n", "2573": "            }\n", "2574": "          }\n", "2575": "        }\n", "2576": "      }\n", "2580": "      for (c1 = 0; c1 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c1++) {\n", "2579": "#pragma omp parallel for private(c2, c4, c3)\n", "2581": "        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n", "2582": "          for (c3 = 16 * c1; c3 <= ((16 * c1 + 15 < nm + -1?16 * c1 + 15 : nm + -1)); c3++) {\n", "2584": "            for (c4 = 16 * c2; c4 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c4++) {\n", "2583": "#pragma omp simd\n", "2585": "              D[c3][c4] = ((double )c3) * (c4 + 2) / nk;\n", "2586": "            }\n", "2587": "          }\n", "2588": "        }\n", "2589": "      }\n", "2627": "      for (c1 = 0; c1 <= (((nj + ni + -1) * 16 < 0?((16 < 0?-((-(nj + ni + -1) + 16 + 1) / 16) : -((-(nj + ni + -1) + 16 - 1) / 16))) : (nj + ni + -1) / 16)); c1++) {\n", "2626": "#pragma omp parallel for private(c7, c2, c10)\n", "2628": "        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n", "2629": "          if (c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16))) {\n", "2630": "            for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n", "2632": "              for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n", "2631": "#pragma omp simd\n", "2633": "                G[c10][c7] = 0;\n", "2634": "              }\n", "2635": "            }\n", "2636": "          }\n", "2637": "          if (c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16))) {\n", "2638": "            for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n", "2640": "              for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n", "2639": "#pragma omp simd\n", "2641": "                F[c10][c7] = 0;\n", "2642": "              }\n", "2643": "            }\n", "2644": "          }\n", "2645": "        }\n", "2646": "      }\n", "2650": "      for (c1 = 0; c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c1++) {\n", "2649": "#pragma omp parallel for private(c7, c2, c10)\n", "2651": "        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n", "2652": "          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n", "2654": "            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n", "2653": "#pragma omp simd\n", "2655": "              F[c10][c7] = 0;\n", "2656": "            }\n", "2657": "          }\n", "2658": "        }\n", "2659": "      }\n", "2663": "      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n", "2662": "#pragma omp parallel for private(c7, c2, c10)\n", "2664": "        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n", "2665": "          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n", "2667": "            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n", "2666": "#pragma omp simd\n", "2668": "              G[c10][c7] = 0;\n", "2669": "            }\n", "2670": "          }\n", "2671": "        }\n", "2672": "      }\n", "2676": "      for (c1 = 0; c1 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c1++) {\n", "2675": "#pragma omp parallel for private(c7, c6, c2, c10, c5)\n", "2677": "        for (c2 = 0; c2 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c2++) {\n", "2678": "          for (c5 = 0; c5 <= (((nm + -1) * 16 < 0?((16 < 0?-((-(nm + -1) + 16 + 1) / 16) : -((-(nm + -1) + 16 - 1) / 16))) : (nm + -1) / 16)); c5++) {\n", "2679": "            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nm + -1?16 * c5 + 15 : nm + -1)); c6++) {\n", "2680": "              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nl + -1?16 * c2 + 15 : nl + -1)); c7++) {\n", "2682": "                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < nj + -1?16 * c1 + 15 : nj + -1)); c10++) {\n", "2681": "#pragma omp simd\n", "2683": "                  F[c10][c7] += C[c10][c6] * D[c6][c7];\n", "2684": "                }\n", "2685": "              }\n", "2686": "            }\n", "2687": "          }\n", "2688": "        }\n", "2689": "      }\n", "2693": "      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n", "2692": "#pragma omp parallel for private(c7, c2, c10)\n", "2694": "        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n", "2695": "          for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n", "2697": "            for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n", "2696": "#pragma omp simd\n", "2698": "              E[c10][c7] = 0;\n", "2699": "            }\n", "2700": "          }\n", "2701": "        }\n", "2702": "      }\n", "2706": "      for (c1 = 0; c1 <= (((ni + -1) * 16 < 0?((16 < 0?-((-(ni + -1) + 16 + 1) / 16) : -((-(ni + -1) + 16 - 1) / 16))) : (ni + -1) / 16)); c1++) {\n", "2705": "#pragma omp parallel for private(c7, c6, c2, c10, c5)\n", "2707": "        for (c2 = 0; c2 <= (((nj + -1) * 16 < 0?((16 < 0?-((-(nj + -1) + 16 + 1) / 16) : -((-(nj + -1) + 16 - 1) / 16))) : (nj + -1) / 16)); c2++) {\n", "2708": "          for (c5 = 0; c5 <= (((nk + -1) * 16 < 0?((16 < 0?-((-(nk + -1) + 16 + 1) / 16) : -((-(nk + -1) + 16 - 1) / 16))) : (nk + -1) / 16)); c5++) {\n", "2709": "            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nk + -1?16 * c5 + 15 : nk + -1)); c6++) {\n", "2710": "              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n", "2712": "                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n", "2711": "#pragma omp simd\n", "2713": "                  E[c10][c7] += A[c10][c6] * B[c6][c7];\n", "2714": "                }\n", "2715": "              }\n", "2716": "            }\n", "2717": "          }\n", "2718": "          for (c5 = 0; c5 <= (((nl + -1) * 16 < 0?((16 < 0?-((-(nl + -1) + 16 + 1) / 16) : -((-(nl + -1) + 16 - 1) / 16))) : (nl + -1) / 16)); c5++) {\n", "2719": "            for (c6 = 16 * c5; c6 <= ((16 * c5 + 15 < nl + -1?16 * c5 + 15 : nl + -1)); c6++) {\n", "2720": "              for (c7 = 16 * c2; c7 <= ((16 * c2 + 15 < nj + -1?16 * c2 + 15 : nj + -1)); c7++) {\n", "2722": "                for (c10 = 16 * c1; c10 <= ((16 * c1 + 15 < ni + -1?16 * c1 + 15 : ni + -1)); c10++) {\n", "2721": "#pragma omp simd\n", "2723": "                  G[c10][c6] += E[c10][c7] * F[c7][c6];\n", "2724": "                }\n", "2725": "              }\n", "2726": "            }\n", "2727": "          }\n", "2728": "        }\n", "2729": "      }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp single\n    {\n    init = 10;\n    }\n    local = init;\n  }\n\n  return 0;\n}\n\n\n", "targets": {"30": "  {\n", "31": "    #pragma omp single\n", "33": "    init = 10;\n", "34": "    }\n", "35": "    local = init;\n", "36": "  }\n"}}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n\n  printf(\"x=%d\",x);\n  return 0;\n}\n\n", "targets": {"58": "  for (i=0;i<len;i++)\n", "57": "#pragma omp parallel for private (i) \n", "59": "    x=i;\n"}}, {"prompt": "", "targets": {"54": "  for (i = 0; i < len; ++i) {\n", "53": "#pragma omp parallel for\n", "55": "    double volnew_o8 = 0.5 * c[i];\n", "56": "    o1[i] = volnew_o8;\n", "57": "  } \n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\ndouble b[1000][1000];\n\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=1000, m=1000;\n  for (i=0;i<n;i++)\n#pragma omp parallel for\n    for (j=1;j<m;j++)\n      b[i][j]=b[i][j-1];\n\n  printf(\"b[500][500]=%f\\n\", b[500][500]);\n  return 0;\n}\n\n", "targets": {"62": "    for (j=1;j<m;j++)\n", "61": "#pragma omp parallel for\n", "63": "      b[i][j]=b[i][j-1];\n"}}, {"prompt": "#include <stdlib.h>\nint main(int argc,char *argv[])\n{\n  int i, j;\n  int len = 20; \n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  double a[len][len];\n\n  for (i=0; i< len; i++)\n    for (j=0; j<len; j++)\n      a[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i = 0; i < len - 1; i += 1) {\n    for (j = 0; j < len ; j += 1) {\n      a[i][j] += a[i + 1][j];\n    }\n  }\n  return 0;\n}\n\n", "targets": {"68": "  for (i = 0; i < len - 1; i += 1) {\n", "67": "#pragma omp parallel for private(j)\n", "69": "    for (j = 0; j < len ; j += 1) {\n", "70": "      a[i][j] += a[i + 1][j];\n", "71": "    }\n", "72": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <omp.h>\n#include <time.h>\n\n\n/*--------------------------------------------------------------------\n * Constants\n */\n#define PATH -1\n#define NONE 0\n#define UP 1\n#define LEFT 2\n#define DIAGONAL 3\n/* End of constants */\n\n/*--------------------------------------------------------------------\n* Helpers\n*/\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n#define max(a,b) ((a) > (b) ? a : b)\n\n// #define DEBUG\n/* End of Helpers */\n\n/*--------------------------------------------------------------------\n * Global Variables\n */\n//Defines size of strings to be compared\nlong long int m ; //Columns - Size of string a\nlong long int n ;  //Lines - Size of string b\n\n//Defines scores\nint matchScore = 5;\nint missmatchScore = -3;\nint gapScore = -4;\n\n//Strings over the Alphabet Sigma\nchar *a, *b;\n\n/* End of global variables */\nvoid generate() {\n    //Random seed\n    srand(time(NULL));\n\n    //Generates the values of a\n    long long int i;\n    for (i = 0; i < m; i++) {\n        int aux = rand() % 4;\n        if (aux == 0)\n            a[i] = 'A';\n        else if (aux == 2)\n            a[i] = 'C';\n        else if (aux == 3)\n            a[i] = 'G';\n        else\n            a[i] = 'T';\n    }\n\n    //Generates the values of b\n    for (i = 0; i < n; i++) {\n        int aux = rand() % 4;\n        if (aux == 0)\n            b[i] = 'A';\n        else if (aux == 2)\n            b[i] = 'C';\n        else if (aux == 3)\n            b[i] = 'G';\n        else\n            b[i] = 'T';\n    }\n} /* End of generate */\n\n\n/*--------------------------------------------------------------------\n * Function:    nElement\n * Purpose:     Calculate the number of i-diagonal elements\n */\nlong long int nElement(long long int i) {\n    if (i < m && i < n) {\n        //Number of elements in the diagonal is increasing\n        return i;\n    }\n    else if (i < max(m, n)) {\n        //Number of elements in the diagonal is stable\n        long long int min = min(m, n);\n        return min - 1;\n    }\n    else {\n        //Number of elements in the diagonal is decreasing\n        long long int min = min(m, n);\n        return 2 * min - i + labs(m - n) - 2;\n    }\n}\n\n/*--------------------------------------------------------------------\n * Function:    matchMissmatchScore\n * Purpose:     Similarity function on the alphabet for match/missmatch\n */\nint matchMissmatchScore(long long int i, long long int j) {\n    if (a[j - 1] == b[i - 1])\n        return matchScore;\n    else\n        return missmatchScore;\n}  /* End of matchMissmatchScore */\n\n\nvoid similarityScore(long long int i, long long int j, int* H, int* P, long long int* maxPos) {\n\n    int up, left, diag;\n\n    //Stores index of element\n    long long int index = m * i + j;\n\n    //Get element above\n    up = H[index - m] + gapScore;\n\n    //Get element on the left\n    left = H[index - 1] + gapScore;\n\n    //Get element on the diagonal\n    diag = H[index - m - 1] + matchMissmatchScore(i, j);\n\n    //Calculates the maximum\n    int max = NONE;\n    int pred = NONE;\n    /* === Matrix ===\n     *      a[0] ... a[n]\n     * b[0]\n     * ...\n     * b[n]\n     *\n     * generate 'a' from 'b', if '\u2190' insert e '\u2191' remove\n     * a=GAATTCA\n     * b=GACTT-A\n     *\n     * generate 'b' from 'a', if '\u2190' insert e '\u2191' remove\n     * b=GACTT-A\n     * a=GAATTCA\n    */\n\n    if (diag > max) { //same letter \u2196\n        max = diag;\n        pred = DIAGONAL;\n    }\n\n    if (up > max) { //remove letter \u2191\n        max = up;\n        pred = UP;\n    }\n\n    if (left > max) { //insert letter \u2190\n        max = left;\n        pred = LEFT;\n    }\n    //Inserts the value in the similarity and predecessor matrixes\n    H[index] = max;\n    P[index] = pred;\n\n    //Updates maximum score to be used as seed on backtrack\n    if (max > H[*maxPos]) {        \n    #pragma omp critical\n        *maxPos = index;\n    }\n\n}  /* End of similarityScore */\n\n/*--------------------------------------------------------------------\n * Function:    calcElement\n * Purpose:     Calculate the position of (si, sj)-element\n */\nvoid calcFirstDiagElement(long long int *i, long long int *si, long long int *sj) {\n    // Calculate the first element of diagonal\n    if (*i < n) {\n        *si = *i;\n        *sj = 1;\n    } else {\n        *si = n - 1;\n        *sj = *i - n + 2;\n    }\n}\n\n\nint main(int argc, char* argv[]) {\n    m = 2048;\n    n = 2048;\n\n#ifdef DEBUG\n    printf(\"\\nMatrix[%lld][%lld]\\n\", n, m);\n#endif\n\n    //Allocates a and b\n    a = malloc(m * sizeof(char));\n    b = malloc(n * sizeof(char));\n\n    //Because now we have zeros\n    m++;\n    n++;\n\n    //Allocates similarity matrix H\n    int *H;\n    H = calloc(m * n, sizeof(int));\n\n    //Allocates predecessor matrix P\n    int *P;\n    P = calloc(m * n, sizeof(int));\n\n\n    //Gen rand arrays a and b\n    generate();\n\n\n    //Start position for backtrack\n    long long int maxPos = 0;\n    //Calculates the similarity matrix\n    long long int i, j;\n\n    //Gets Initial time\n    double initialTime = omp_get_wtime();\n\n    long long int si, sj, ai, aj;\n\n    //Because now we have zeros ((m-1) + (n-1) - 1)\n    long long int nDiag = m + n - 3;\n    long long int nEle;\n\n    #pragma omp parallel \\\n    default(none) shared(H, P, maxPos, nDiag) private(nEle, i, si, sj, ai, aj)\n    {\n        for (i = 1; i <= nDiag; ++i)\n        {\n            nEle = nElement(i);\n            calcFirstDiagElement(&i, &si, &sj);\n            #pragma omp for\n            for (j = 1; j <= nEle; ++j)\n            {\n                ai = si - j + 1;\n                aj = sj + j - 1;\n                similarityScore(ai, aj, H, P, &maxPos);\n            }\n        }\n    }\n}\n", "targets": {"245": "    {\n", "246": "        for (i = 1; i <= nDiag; ++i)\n", "248": "            nEle = nElement(i);\n", "249": "            calcFirstDiagElement(&i, &si, &sj);\n", "251": "            for (j = 1; j <= nEle; ++j)\n", "250": "            #pragma omp for\n", "253": "                ai = si - j + 1;\n", "254": "                aj = sj + j - 1;\n", "255": "                similarityScore(ai, aj, H, P, &maxPos);\n", "256": "            }\n", "257": "        }\n", "258": "    }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n  }\n  printf (\"numThreads=%d\\n\", numThreads);\n  return 0;\n}\n", "targets": {"57": "  {\n", "58": "    if ( omp_get_thread_num()==0 ) {\n", "59": "      numThreads = omp_get_num_threads();\n", "60": "    }\n", "61": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\ntypedef _Bool flag_t;\n\nflag_t f0, f1;\nconst int n = 2;\nint x = 1;\n\nvoid init(flag_t *f)\n{\n  *f = 0;\n}\n\nvoid raise(flag_t *f)\n{\n#pragma omp critical\n  {\n    assert(*f == 0);\n    *f = 1;\n  }\n}\n\nvoid lower(flag_t *f)\n{\n  _Bool done = 0;\n  while (!done)\n  {\n#pragma omp critical\n    if (*f == 1)\n    {\n      *f = 0;\n      done = 1;\n    }\n  }\n}\n\nvoid mybarrier(int tid)\n{\n  if (tid == 0)\n  {\n    raise(&f0);\n    lower(&f0);\n  }\n  else if (tid == 1)\n  {\n    raise(&f1);\n    lower(&f1);\n  }\n}\n\nint main()\n{\n  init(&f0);\n  init(&f1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      // assert(x==1);\n      mybarrier(tid);\n      if (tid == 0)\n        x = 0;\n      mybarrier(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      // assert(x==0);\n      mybarrier(tid);\n      if (tid == 1)\n        x = 1;\n      mybarrier(tid);\n    }\n  } // end of parallel construct\n  printf(\"Done: x=%d\\n\", x);\n}\n", "targets": {"76": "    int tid = omp_get_thread_num();\n", "77": "#pragma omp barrier\n", "78": "    for (int i = 0; i < n; i++)\n", "80": "      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n", "81": "      fflush(stdout);\n", "83": "      mybarrier(tid);\n", "84": "      if (tid == 0)\n", "85": "        x = 0;\n", "86": "      mybarrier(tid);\n", "87": "      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n", "88": "      fflush(stdout);\n", "90": "      mybarrier(tid);\n", "91": "      if (tid == 1)\n", "92": "        x = 1;\n", "93": "      mybarrier(tid);\n", "94": "    }\n", "95": "  } // end of parallel construct\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint input[1000]; \nint output[1000];\n\nint main()\n{\n  int i ;\n  int inLen=1000 ; \n  int outLen = 0;\n\n  for (i=0; i<inLen; ++i) \n    input[i]= i;  \n\n#pragma omp parallel for\n  for (i=0; i<inLen; ++i) \n  {\n    output[outLen++] = input[i] ;\n  }  \n\n  printf(\"output[500]=%d\\n\",output[500]);\n\n  return 0;\n}\n", "targets": {"71": "  for (i=0; i<inLen; ++i) \n", "70": "#pragma omp parallel for\n", "73": "    output[outLen++] = input[i] ;\n", "74": "  }  \n"}}, {"prompt": "#include <stdio.h>\n\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int i)\n{\n#pragma omp task\n  {\n    a[i]= i+1;\n  }\n}\n\nint main()\n{\n  int i=0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n      for (i=0; i<MYLEN; i++)\n      {\n        gen_task(i);\n      }\n    }\n  }\n  \n  /* correctness checking */\n  for (i=0; i<MYLEN; i++)\n  {\n    //assert (a[i]==i+1);\n    if (a[i]!= i+1)\n    {\n      printf(\"warning: a[%d] = %d, not expected %d\\n\", i, a[i], i+1);\n    }\n  }\n  return 0;\n}\n\n", "targets": {"58": "#pragma omp task\n", "60": "    a[i]= i+1;\n", "62": "}\n", "59": "  {\n", "68": "  {\n", "69": "#pragma omp single\n", "71": "      for (i=0; i<MYLEN; i++)\n", "73": "        gen_task(i);\n", "74": "      }\n", "75": "    }\n", "76": "  }\n"}}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=2000;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n  int a[len];\n\n  for (i=0; i<len; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<len/2;i++)\n    a[2*i+1]=a[i]+1;\n\n  return 0;\n}\n\n", "targets": {"65": "  for (i=0;i<len/2;i++)\n", "64": "#pragma omp parallel for\n", "66": "    a[2*i+1]=a[i]+1;\n"}}, {"prompt": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 20x1000. */\n#include \"polybench/jacobi-2d-imper.h\"\n/* Array initialization. */\n\nstatic void init_array(int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c2;\n    int c1;\n    if (n >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= n + -1; c1++) {\n        for (c2 = 0; c2 <= n + -1; c2++) {\n          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int n,double A[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",A[i][j]);\n      if ((i * n + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_jacobi_2d_imper(int tsteps,int n,double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int t;\n  //int i;\n  //int j;\n  \n  //#pragma scop\n{\n    int c2;\n    int c1;\n    int c0;\n    for (c2 = 1; c2 <= 498; c2++) {\n      B[1][c2] = 0.2 * (A[1][c2] + A[1][c2 - 1] + A[1][1 + c2] + A[1 + 1][c2] + A[1 - 1][c2]);\n    }\n    for (c0 = 2; c0 <= 525; c0++) {\n      if (c0 <= 28) {\n        if ((2 * c0 + 1) % 3 == 0) {\n          for (c2 = ((2 * c0 + 1) * 3 < 0?-(-(2 * c0 + 1) / 3) : ((3 < 0?(-(2 * c0 + 1) + - 3 - 1) / - 3 : (2 * c0 + 1 + 3 - 1) / 3))); c2 <= (((2 * c0 + 1492) * 3 < 0?((3 < 0?-((-(2 * c0 + 1492) + 3 + 1) / 3) : -((-(2 * c0 + 1492) + 3 - 1) / 3))) : (2 * c0 + 1492) / 3)); c2++) {\n            B[1][(-2 * c0 + 3 * c2 + 2) / 3] = 0.2 * (A[1][(-2 * c0 + 3 * c2 + 2) / 3] + A[1][(-2 * c0 + 3 * c2 + 2) / 3 - 1] + A[1][1 + (-2 * c0 + 3 * c2 + 2) / 3] + A[1 + 1][(-2 * c0 + 3 * c2 + 2) / 3] + A[1 - 1][(-2 * c0 + 3 * c2 + 2) / 3]);\n          }\n        }\n      }\n#pragma omp parallel for private(c2)\n      for (c1 = ((((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) > c0 + -9?(((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) : c0 + -9); c1 <= (((((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) < c0?(((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) : c0)); c1++) {\n        B[-2 * c0 + 3 * c1][1] = 0.2 * (A[-2 * c0 + 3 * c1][1] + A[-2 * c0 + 3 * c1][1 - 1] + A[-2 * c0 + 3 * c1][1 + 1] + A[1 + (-2 * c0 + 3 * c1)][1] + A[-2 * c0 + 3 * c1 - 1][1]);\n        for (c2 = 2 * c0 + -2 * c1 + 2; c2 <= 2 * c0 + -2 * c1 + 498; c2++) {\n          A[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1] = B[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1];\n          B[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] = 0.2 * (A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2 - 1] + A[-2 * c0 + 3 * c1][1 + (-2 * c0 + 2 * c1 + c2)] + A[1 + (-2 * c0 + 3 * c1)][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1 - 1][-2 * c0 + 2 * c1 + c2]);\n        }\n        A[-2 * c0 + 3 * c1 + -1][498] = B[-2 * c0 + 3 * c1 + -1][498];\n      }\n      if (c0 >= 499) {\n        if ((2 * c0 + 1) % 3 == 0) {\n          for (c2 = ((2 * c0 + -992) * 3 < 0?-(-(2 * c0 + -992) / 3) : ((3 < 0?(-(2 * c0 + -992) + - 3 - 1) / - 3 : (2 * c0 + -992 + 3 - 1) / 3))); c2 <= (((2 * c0 + 499) * 3 < 0?((3 < 0?-((-(2 * c0 + 499) + 3 + 1) / 3) : -((-(2 * c0 + 499) + 3 - 1) / 3))) : (2 * c0 + 499) / 3)); c2++) {\n            A[498][(-2 * c0 + 3 * c2 + 995) / 3] = B[498][(-2 * c0 + 3 * c2 + 995) / 3];\n          }\n        }\n      }\n    }\n    for (c2 = 20; c2 <= 517; c2++) {\n      A[498][c2 + -19] = B[498][c2 + -19];\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int n = 500;\n  int tsteps = 10;\n/* Variable declaration/allocation. */\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(n, *A, *B);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_jacobi_2d_imper(tsteps,n, *A, *B);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *A);\n/* Be clean. */\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n", "targets": {"29": "      for (c1 = 0; c1 <= n + -1; c1++) {\n", "28": "#pragma omp parallel for private(c2)\n", "30": "        for (c2 = 0; c2 <= n + -1; c2++) {\n", "31": "          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n", "32": "          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n", "33": "        }\n", "34": "      }\n", "79": "      for (c1 = ((((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) > c0 + -9?(((2 * c0 + 2) * 3 < 0?-(-(2 * c0 + 2) / 3) : ((3 < 0?(-(2 * c0 + 2) + - 3 - 1) / - 3 : (2 * c0 + 2 + 3 - 1) / 3)))) : c0 + -9); c1 <= (((((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) < c0?(((2 * c0 + 498) * 3 < 0?((3 < 0?-((-(2 * c0 + 498) + 3 + 1) / 3) : -((-(2 * c0 + 498) + 3 - 1) / 3))) : (2 * c0 + 498) / 3)) : c0)); c1++) {\n", "78": "#pragma omp parallel for private(c2)\n", "80": "        B[-2 * c0 + 3 * c1][1] = 0.2 * (A[-2 * c0 + 3 * c1][1] + A[-2 * c0 + 3 * c1][1 - 1] + A[-2 * c0 + 3 * c1][1 + 1] + A[1 + (-2 * c0 + 3 * c1)][1] + A[-2 * c0 + 3 * c1 - 1][1]);\n", "81": "        for (c2 = 2 * c0 + -2 * c1 + 2; c2 <= 2 * c0 + -2 * c1 + 498; c2++) {\n", "82": "          A[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1] = B[-2 * c0 + 3 * c1 + -1][-2 * c0 + 2 * c1 + c2 + -1];\n", "83": "          B[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] = 0.2 * (A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1][-2 * c0 + 2 * c1 + c2 - 1] + A[-2 * c0 + 3 * c1][1 + (-2 * c0 + 2 * c1 + c2)] + A[1 + (-2 * c0 + 3 * c1)][-2 * c0 + 2 * c1 + c2] + A[-2 * c0 + 3 * c1 - 1][-2 * c0 + 2 * c1 + c2]);\n", "84": "        }\n", "85": "        A[-2 * c0 + 3 * c1 + -1][498] = B[-2 * c0 + 3 * c1 + -1][498];\n", "86": "      }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              //2nd child task\n\n  #pragma omp taskwait depend(in: x)                                    // 1st taskwait\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                                  // 2nd taskwait\n\n  printf(\"y=%d\\n\",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n", "targets": {"24": "  #pragma omp task depend(inout: x) shared(x)\n", "25": "  x++;                                                                  // 1st child task\n", "27": "  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n", "28": "  y = y-x;                                                              //2nd child task\n", "41": "  #pragma omp single\n", "42": "  foo();\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n) {\n  int i, j, s;\n  if (n < 2)\n    return n;\n#pragma omp task shared(i) depend(out : i)\n  i = fib(n - 1);\n#pragma omp task shared(j) depend(out : j)\n  j = fib(n - 2);\n#pragma omp task shared(i, j, s) depend(in : i, j)\n  s = i + j;\n#pragma omp taskwait\n  return s;\n}\n\nint main(int argc, char **argv) {\n  int n = 10;\n  if (argc > 1)\n    n = atoi(argv[1]);\n#pragma omp parallel sections\n  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n  return 0;\n}\n", "targets": {"22": "#pragma omp task shared(i) depend(out : i)\n", "23": "  i = fib(n - 1);\n", "24": "#pragma omp task shared(j) depend(out : j)\n", "25": "  j = fib(n - 2);\n", "26": "#pragma omp task shared(i, j, s) depend(in : i, j)\n", "27": "  s = i + j;\n", "37": "  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n", "36": "#pragma omp parallel sections\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf(\"%d\\n\",x);\n  return 0;\n}\n", "targets": {"25": "  #pragma omp task mergeable\n", "26": "  {\n", "27": "    x++;\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  omp_lock_t lck;\n  int var = 0;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute reduction(+:var)\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n  printf(\"%d\\n \",var);\n  return 0;\n}\n", "targets": {"25": "  for (int i=0; i<100; i++){\n", "24": "  #pragma omp teams distribute reduction(+:var)\n", "26": "    omp_set_lock(&lck);\n", "27": "    var++;\n", "28": "    omp_unset_lock(&lck);\n", "29": "  }\n"}}, {"prompt": "#include <stdio.h>\nint a[100];\n\nint main()\n{\n  int len=100; \n  int i,x=10;\n\n#pragma omp parallel for \n  for (i=0;i<len;i++)\n  {\n    a[i] = x;\n    x=i;\n  }\n  printf(\"x=%d\",x);    \n  return 0;\n} \n\n", "targets": {"71": "  for (i=0;i<len;i++)\n", "70": "#pragma omp parallel for \n", "73": "    a[i] = x;\n", "74": "    x=i;\n", "75": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n/* Include polybench common header. */\n#include \"polybench/polybench.h\"\n/* Include benchmark-specific header. */\n/* Default data type is double, default size is 10x1024x1024. */\n#include \"polybench/adi.h\"\n/* Array initialization. */\n\nstatic void init_array(int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int i;\n  //int j;\n{\n    int c1;\n    int c2;\n    if (n >= 1) {\n#pragma omp parallel for private(c2)\n      for (c1 = 0; c1 <= n + -1; c1++) {\n        for (c2 = 0; c2 <= n + -1; c2++) {\n          X[c1][c2] = (((double )c1) * (c2 + 1) + 1) / n;\n          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n        }\n      }\n    }\n  }\n}\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\nstatic void print_array(int n,double X[500 + 0][500 + 0])\n{\n  int i;\n  int j;\n  for (i = 0; i < n; i++) \n    for (j = 0; j < n; j++) {\n      fprintf(stderr,\"%0.2lf \",X[i][j]);\n      if ((i * 500 + j) % 20 == 0) \n        fprintf(stderr,\"\\n\");\n    }\n  fprintf(stderr,\"\\n\");\n}\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n\nstatic void kernel_adi(int tsteps,int n,double X[500 + 0][500 + 0],double A[500 + 0][500 + 0],double B[500 + 0][500 + 0])\n{\n  //int t;\n  //int i1;\n  //int i2;\n  \n  //#pragma scop\n{\n    int c0;\n    int c2;\n    int c8;\n    for (c0 = 0; c0 <= 9; c0++) {\n#pragma omp parallel for private(c8)\n      for (c2 = 0; c2 <= 499; c2++) {\n        for (c8 = 1; c8 <= 499; c8++) {\n          B[c2][c8] = B[c2][c8] - A[c2][c8] * A[c2][c8] / B[c2][c8 - 1];\n        }\n        for (c8 = 1; c8 <= 499; c8++) {\n          X[c2][c8] = X[c2][c8] - X[c2][c8 - 1] * A[c2][c8] / B[c2][c8 - 1];\n        }\n        for (c8 = 0; c8 <= 497; c8++) {\n          X[c2][500 - c8 - 2] = (X[c2][500 - 2 - c8] - X[c2][500 - 2 - c8 - 1] * A[c2][500 - c8 - 3]) / B[c2][500 - 3 - c8];\n        }\n      }\n#pragma omp parallel for\n      for (c2 = 0; c2 <= 499; c2++) {\n        X[c2][500 - 1] = X[c2][500 - 1] / B[c2][500 - 1];\n      }\n#pragma omp parallel for private(c8)\n      for (c2 = 0; c2 <= 499; c2++) {\n        for (c8 = 1; c8 <= 499; c8++) {\n          B[c8][c2] = B[c8][c2] - A[c8][c2] * A[c8][c2] / B[c8 - 1][c2];\n        }\n        for (c8 = 1; c8 <= 499; c8++) {\n          X[c8][c2] = X[c8][c2] - X[c8 - 1][c2] * A[c8][c2] / B[c8 - 1][c2];\n        }\n        for (c8 = 0; c8 <= 497; c8++) {\n          X[500 - 2 - c8][c2] = (X[500 - 2 - c8][c2] - X[500 - c8 - 3][c2] * A[500 - 3 - c8][c2]) / B[500 - 2 - c8][c2];\n        }\n      }\n#pragma omp parallel for\n      for (c2 = 0; c2 <= 499; c2++) {\n        X[500 - 1][c2] = X[500 - 1][c2] / B[500 - 1][c2];\n      }\n    }\n  }\n  \n//#pragma endscop\n}\n\nint main(int argc,char **argv)\n{\n/* Retrieve problem size. */\n  int n = 500;\n  int tsteps = 10;\n/* Variable declaration/allocation. */\n  double (*X)[500 + 0][500 + 0];\n  X = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*A)[500 + 0][500 + 0];\n  A = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n  double (*B)[500 + 0][500 + 0];\n  B = ((double (*)[500 + 0][500 + 0])(polybench_alloc_data(((500 + 0) * (500 + 0)),(sizeof(double )))));\n  ;\n/* Initialize array(s). */\n  init_array(n, *X, *A, *B);\n/* Start timer. */\n  polybench_timer_start();\n  ;\n/* Run kernel. */\n  kernel_adi(tsteps,n, *X, *A, *B);\n/* Stop and print timer. */\n  polybench_timer_stop();\n  ;\n  polybench_timer_print();\n  ;\n/* Prevent dead-code elimination. All live-out data must be printed\n     by the function call in argument. */\n  if (argc > 42 && !strcmp(argv[0],\"\")) \n    print_array(n, *X);\n/* Be clean. */\n  free(((void *)X));\n  ;\n  free(((void *)A));\n  ;\n  free(((void *)B));\n  ;\n  return 0;\n}\n", "targets": {"30": "      for (c1 = 0; c1 <= n + -1; c1++) {\n", "29": "#pragma omp parallel for private(c2)\n", "31": "        for (c2 = 0; c2 <= n + -1; c2++) {\n", "32": "          X[c1][c2] = (((double )c1) * (c2 + 1) + 1) / n;\n", "33": "          A[c1][c2] = (((double )c1) * (c2 + 2) + 2) / n;\n", "34": "          B[c1][c2] = (((double )c1) * (c2 + 3) + 3) / n;\n", "35": "        }\n", "36": "      }\n", "71": "      for (c2 = 0; c2 <= 499; c2++) {\n", "70": "#pragma omp parallel for private(c8)\n", "72": "        for (c8 = 1; c8 <= 499; c8++) {\n", "73": "          B[c2][c8] = B[c2][c8] - A[c2][c8] * A[c2][c8] / B[c2][c8 - 1];\n", "74": "        }\n", "75": "        for (c8 = 1; c8 <= 499; c8++) {\n", "76": "          X[c2][c8] = X[c2][c8] - X[c2][c8 - 1] * A[c2][c8] / B[c2][c8 - 1];\n", "77": "        }\n", "78": "        for (c8 = 0; c8 <= 497; c8++) {\n", "79": "          X[c2][500 - c8 - 2] = (X[c2][500 - 2 - c8] - X[c2][500 - 2 - c8 - 1] * A[c2][500 - c8 - 3]) / B[c2][500 - 3 - c8];\n", "80": "        }\n", "81": "      }\n", "83": "      for (c2 = 0; c2 <= 499; c2++) {\n", "82": "#pragma omp parallel for\n", "84": "        X[c2][500 - 1] = X[c2][500 - 1] / B[c2][500 - 1];\n", "85": "      }\n", "87": "      for (c2 = 0; c2 <= 499; c2++) {\n", "86": "#pragma omp parallel for private(c8)\n", "88": "        for (c8 = 1; c8 <= 499; c8++) {\n", "89": "          B[c8][c2] = B[c8][c2] - A[c8][c2] * A[c8][c2] / B[c8 - 1][c2];\n", "90": "        }\n", "91": "        for (c8 = 1; c8 <= 499; c8++) {\n", "92": "          X[c8][c2] = X[c8][c2] - X[c8 - 1][c2] * A[c8][c2] / B[c8 - 1][c2];\n", "93": "        }\n", "94": "        for (c8 = 0; c8 <= 497; c8++) {\n", "95": "          X[500 - 2 - c8][c2] = (X[500 - 2 - c8][c2] - X[500 - c8 - 3][c2] * A[500 - 3 - c8][c2]) / B[500 - 2 - c8][c2];\n", "96": "        }\n", "97": "      }\n", "99": "      for (c2 = 0; c2 <= 499; c2++) {\n", "98": "#pragma omp parallel for\n", "100": "        X[500 - 1][c2] = X[500 - 1][c2] / B[500 - 1][c2];\n", "101": "      }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections \n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var) if(0)\n      {\n        var++;\n      }\n    }\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n", "targets": {"26": "  {\n", "25": "  #pragma omp parallel sections \n", "27": "    for (i = 0; i < 10; i++) {\n", "28": "      #pragma omp task shared(var) if(0)\n", "32": "    }\n", "33": "  }\n", "29": "      {\n", "30": "        var++;\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,x;\n  int len = 10000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n#pragma omp parallel for private (i) \n  for (i=0;i<len;i++)\n    x=i;\n  printf(\"x=%d\",x);\n  return 0;\n}\n\n", "targets": {"62": "  for (i=0;i<len;i++)\n", "61": "#pragma omp parallel for private (i) \n", "63": "    x=i;\n"}}, {"prompt": "#include <stdio.h>\nint nprod = 4, ncons = 4;\nint cap = 5, size = 0, packages = 1000;\nint main()\n{\n  int nthread = nprod + ncons;\n#pragma omp parallel for shared(size, cap, nprod, ncons, nthread) firstprivate(packages) num_threads(nthread)\n  for (int i = 0; i < nthread; i++)\n  {\n    if (i < nprod)\n      while (packages)\n      { // I am a producer\n#pragma omp critical\n        if (size < cap)\n        {\n          size++; // produce\n          packages--; // produced a package\n          printf(\"Producer %d produced! size=%d\\n\", i, size);\n          fflush(stdout);\n        }\n      }\n    else\n      while (packages)\n      { // I am a consumer\n#pragma omp critical\n        if (size > 0)\n        {\n          size--; // consume\n          packages--; // consumed a package\n          printf(\"Consumer %d consumed! size=%d\\n\", i - nprod, size);\n          fflush(stdout);\n        }\n      }\n  }\n}\n", "targets": {"24": "  for (int i = 0; i < nthread; i++)\n", "23": "#pragma omp parallel for shared(size, cap, nprod, ncons, nthread) firstprivate(packages) num_threads(nthread)\n", "26": "    if (i < nprod)\n", "27": "      while (packages)\n", "29": "#pragma omp critical\n", "30": "        if (size < cap)\n", "32": "          size++; // produce\n", "33": "          packages--; // produced a package\n", "34": "          printf(\"Producer %d produced! size=%d\\n\", i, size);\n", "35": "          fflush(stdout);\n", "36": "        }\n", "39": "      while (packages)\n", "41": "#pragma omp critical\n", "42": "        if (size > 0)\n", "44": "          size--; // consume\n", "45": "          packages--; // consumed a package\n", "46": "          printf(\"Consumer %d consumed! size=%d\\n\", i - nprod, size);\n", "47": "          fflush(stdout);\n", "48": "        }\n", "50": "  }\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble c = 0.2;\nint n = 20, nsteps = 100;\n\nint main()\n{\n  double *b = malloc(2 * n * sizeof(double));\n  double *u[2] = {&b[0], &b[n]};\n  for (int i = 1; i < n - 1; i++)\n    u[0][i] = u[1][i] = 1.0 * rand() / RAND_MAX;\n  u[0][0] = u[0][n - 1] = u[1][0] = u[1][n - 1] = 0.5;\n  int p = 0;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u[1 - p][i] = u[p][i] + c * (u[p][i - 1] + u[p][i + 1] - 2 * u[p][i]);\n    }\n    p = 1 - p;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u[p][i]);\n  printf(\"\\n\");\n  free(b);\n}\n", "targets": {"34": "    for (int i = 1; i < n - 1; i++)\n", "33": "#pragma omp parallel for\n", "36": "      u[1 - p][i] = u[p][i] + c * (u[p][i - 1] + u[p][i + 1] - 2 * u[p][i]);\n", "37": "    }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  omp_lock_t lck;\n  int var=0,i;\n  omp_init_lock(&lck);\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    omp_set_lock(&lck);\n    var++;\n    omp_unset_lock(&lck);\n  }\n\n  omp_destroy_lock(&lck);\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n", "targets": {"28": "  for (int i=0; i<100; i++){\n", "27": "  #pragma omp teams distribute parallel for\n", "32": "  }\n", "29": "    omp_set_lock(&lck);\n", "30": "    var++;\n", "31": "    omp_unset_lock(&lck);\n"}}, {"prompt": "#include <assert.h> \n#include <stdio.h>\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Proper user of ordered directive and clause, no data races\n * */\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n#pragma omp ordered\n    {\n      x++;\n    }\n  }\n  assert (x==100);\n  printf (\"x=%d\\n\",x);\n  return 0;\n} \n", "targets": {"55": "  for (int i = 0; i < 100; ++i) {\n", "56": "#pragma omp ordered\n", "58": "      x++;\n", "59": "    }\n", "60": "  }\n", "54": "#pragma omp parallel for ordered \n"}}, {"prompt": "", "targets": {"63": "     foo();\n", "64": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\n#define N 8\n\nint main()\n{\n  int i,j,k;\n  double r1[N], r[N][N][N];\n\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) {\n      for (k = 0; k < N; k++) {\n        r[i][j][k] = i;\n      }\n    }\n  }\n\n\n  #pragma omp parallel for default(shared) private(j,k)\n  for (i = 1; i < N-1; i++) {\n    for (j = 1; j < N-1; j++) {\n      for (k = 0; k < N; k++) {\n        r1[k] = r[i][j-1][k] + r[i][j+1][k] + r[i-1][j][k] + r[i+1][j][k];\n      }\n    }\n  }\n\n  for (k = 0; k < N; k++) printf(\"%f \",r1[k]);\n\n  printf(\"\\n\");\n\n  return 0;\n}\n\n", "targets": {"35": "  for (i = 1; i < N-1; i++) {\n", "34": "  #pragma omp parallel for default(shared) private(j,k)\n", "36": "    for (j = 1; j < N-1; j++) {\n", "37": "      for (k = 0; k < N; k++) {\n", "38": "        r1[k] = r[i][j-1][k] + r[i][j+1][k] + r[i-1][j][k] + r[i+1][j][k];\n", "39": "      }\n", "40": "    }\n", "41": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n  int var[N];\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=1; i<N; i++){\n    var[i]=var[i-1]+1;\n  }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf(\"Data Race Present\\n\");\n      return 0;\n    }\n  }\n  return 0;\n}\n", "targets": {"27": "  for (int i=1; i<N; i++){\n", "26": "  #pragma omp teams distribute parallel for\n", "29": "  }\n", "28": "    var[i]=var[i-1]+1;\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a)\n      c += a;\n    #pragma omp task depend(in: b)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf(\"%d\\n\",d);\n  return 0;\n}\n", "targets": {"23": "  #pragma omp single\n", "25": "    #pragma omp task depend(out: c)\n", "27": "    #pragma omp task depend(out: a)\n", "29": "    #pragma omp task depend(out: b)\n", "31": "    #pragma omp task depend(in: a)\n", "33": "    #pragma omp task depend(in: b)\n", "35": "    #pragma omp task depend(in: c)\n", "37": "  }\n", "26": "      c = 1;\n", "28": "      a = 2;\n", "30": "      b = 3;\n", "32": "      c += a;\n", "34": "      c += b;\n", "36": "      d = c;\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\nvoid foo(int n, int * restrict  a, int * restrict b, int * restrict  c)\n{\n  int i;\n#pragma omp parallel for \n  for (i = 0; i < n; i++)\n    a[i] = b[i] + c[i];  \n}\n\nint main()\n{\n  int n = 1000;\n  int * a , *b, *c;\n\n  a = (int*) malloc (n* sizeof (int));\n  if (a ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  b = (int*) malloc (n* sizeof (int));\n  if (b ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  c = (int*) malloc (n* sizeof (int));\n  if (c ==0)\n  {\n    fprintf (stderr, \"skip the execution due to malloc failures.\\n\");\n    return 1;\n  }\n\n  foo (n, a, b,c);\n\n  free (a);\n  free (b);\n  free (c);\n  return 0;\n}  \n\n", "targets": {"62": "  for (i = 0; i < n; i++)\n", "61": "#pragma omp parallel for \n", "63": "    a[i] = b[i] + c[i];  \n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint tp;\n#pragma omp threadprivate(tp)\nint var;\n\nint main(){\n  #pragma omp task\n  {\n    #pragma omp task\n    {\n      tp = 1;\n      #pragma omp task\n      {\n      }\n      var = tp;\n    }\n  }\n  return 0;\n}\n", "targets": {"32": "      #pragma omp task\n", "33": "      {\n", "29": "    #pragma omp task\n", "30": "    {\n", "31": "      tp = 1;\n", "35": "      var = tp;\n", "27": "  #pragma omp task\n", "28": "  {\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n  int i;\n  double q[10], qq[10];\n\n  for (i = 0; i < 10; i++) qq[i] = (double)i;\n  for (i = 0; i < 10; i++) q[i] = (double)i;\n\n  #pragma omp parallel default(shared)\n  {\n    #pragma omp for private(i)\n    for (i = 0; i < 10; i++)\n      q[i] += qq[i];\n\n    #pragma omp critical\n    {\n      q[9] += 1.0;\n    }\n    #pragma omp barrier\n    #pragma omp single\n    {\n      q[9] = q[9] - 1.0;\n    }\n\n  } \n\n  for (i = 0; i < 10; i++)printf(\"%f %f\\n\",qq[i],q[i]);\n\n  return 0;\n}\n\n", "targets": {"26": "  {\n", "28": "    for (i = 0; i < 10; i++)\n", "27": "    #pragma omp for private(i)\n", "29": "      q[i] += qq[i];\n", "31": "    #pragma omp critical\n", "33": "      q[9] += 1.0;\n", "34": "    }\n", "35": "    #pragma omp barrier\n", "36": "    #pragma omp single\n", "38": "      q[9] = q[9] - 1.0;\n", "39": "    }\n", "41": "  } \n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main (int argc, char **argv)\n{\n  int init, local;\n\n  #pragma omp parallel shared(init) private(local)\n  {\n    #pragma omp master\n    {\n      init = 10;\n    }\n\n    local = init;\n  }\n\n  return 0;\n}\n\n\n", "targets": {"30": "  {\n", "31": "    #pragma omp master\n", "33": "      init = 10;\n", "34": "    }\n", "36": "    local = init;\n", "37": "  }\n"}}, {"prompt": "#include <stdio.h>\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Classic Fibonacci calculation using task but missing taskwait. \n * Data races pairs: i@61:5:W vs. i@65:14:R\n *                   j@63:5:W vs. j@65:16:R\n * */\nunsigned int input = 10;\nint fib(unsigned int n)\n{\n  if (n<2)\n    return n;\n  else\n  {\n    int i, j;\n#pragma omp task shared(i)\n    i=fib(n-1);\n#pragma omp task shared(j)\n    j=fib(n-2);\n\n    int res= i+j; \n/* We move the original taskwait to a location after i+j to \n * simulate the missing taskwait mistake.\n * Directly removing the taskwait may cause a child task to write to i or j\n * within the stack of a parent task which may already be gone, causing seg fault.\n * This change is suggested by Joachim Protze @RWTH-Aachen. \n * */\n#pragma omp taskwait\n    return res;\n  }\n}\nint main()\n{\n  int result = 0;\n#pragma omp parallel\n  {\n   #pragma omp single\n    {\n      result = fib(input);\n    }\n  }\n  printf (\"Fib(%d)=%d (correct answer should be 55)\\n\", input, result);\n  return 0;\n}\n", "targets": {"60": "#pragma omp task shared(i)\n", "61": "    i=fib(n-1);\n", "62": "#pragma omp task shared(j)\n", "63": "    j=fib(n-2);\n", "80": "  {\n", "81": "   #pragma omp single\n", "83": "      result = fib(input);\n", "84": "    }\n", "85": "  }\n"}}, {"prompt": "#include <stdio.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel sections\n  {\n#pragma omp section\n    i = 1;    \n#pragma omp section\n    i = 2;    \n  }\n  printf(\"i=%d\\n\",i);\n  return 0;\n} \n", "targets": {"56": "  {\n", "55": "#pragma omp parallel sections\n", "58": "    i = 1;    \n", "57": "#pragma omp section\n", "60": "    i = 2;    \n", "59": "#pragma omp section\n", "61": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n) {\n  int i, j, s;\n  if (n < 2)\n    return n;\n#pragma omp task shared(i) depend(out : i)\n  i = fib(n - 1);\n#pragma omp task shared(j) depend(out : j)\n  j = fib(n - 2);\n#pragma omp task shared(i, j) depend(in : j)\n  s = i + j;\n#pragma omp taskwait\n  return i + j;\n}\n\nint main(int argc, char **argv) {\n  int n = 10;\n  if (argc > 1)\n    n = atoi(argv[1]);\n#pragma omp parallel sections\n  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n  return 0;\n}\n", "targets": {"24": "#pragma omp task shared(i) depend(out : i)\n", "25": "  i = fib(n - 1);\n", "26": "#pragma omp task shared(j) depend(out : j)\n", "27": "  j = fib(n - 2);\n", "28": "#pragma omp task shared(i, j) depend(in : j)\n", "29": "  s = i + j;\n", "39": "  { printf(\"fib(%i) = %i\\n\", n, fib(n)); }\n", "38": "#pragma omp parallel sections\n"}}, {"prompt": "#include<stdio.h>\n#include<stdlib.h>\n\nint* counter; \n#pragma omp threadprivate(counter)\n\nint main()\n{ \n  counter = (int*) malloc(sizeof(int));\n  if (counter== NULL)\n  {\n    fprintf(stderr, \"malloc() fails\\n\");\n    exit(1);\n  }\n  *counter = 0; \n #pragma omp parallel \n  {\n    (*counter)++; \n  }\n  printf(\"%d \\n\", *counter);\n  free (counter);\n  return 0;   \n}\n\n", "targets": {"73": "    (*counter)++; \n", "74": "  }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\nint main()\n{\n  int numThreads=0 ; \n#pragma omp parallel\n  {\n    if ( omp_get_thread_num()==0 ) {\n      numThreads = omp_get_num_threads();\n    }\n    else\n    {\n      printf(\"numThreads=%d\\n\", numThreads);\n    }\n  }\n  return 0;\n}\n", "targets": {"58": "  {\n", "59": "    if ( omp_get_thread_num()==0 ) {\n", "60": "      numThreads = omp_get_num_threads();\n", "61": "    }\n", "64": "      printf(\"numThreads=%d\\n\", numThreads);\n", "66": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\nint main(int argc, char *argv[]) {\n  int len = 20000;\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[len];\n  for (int i = 0; i < len; i++)\n    a[i] = i;\n  double c = M_PI;\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len; i++)\n    a[i] = a[i] + c;\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n  return 0;\n}\n", "targets": {"27": "  for (int i = 0; i < len; i++)\n", "28": "    a[i] = a[i] + c;\n", "26": "#pragma omp parallel for simd schedule(dynamic, 64)\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  int len = 20000;\n\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[2 * len], b[len];\n\n  for (int i = 0; i < 2 * len; i++)\n    a[i] = i;\n  for (int i = 0; i < len; i++)\n    b[i] = i + 1;\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len; i++)\n    a[i * 2] = a[i * 2] + b[i];\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n\n  return 0;\n}\n", "targets": {"30": "  for (int i = 0; i < len; i++)\n", "31": "    a[i * 2] = a[i * 2] + b[i];\n", "29": "#pragma omp parallel for simd schedule(dynamic, 64)\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(){\n\n  int a[4];\n  int psum[2];\n  int sum;\n\n  #pragma omp parallel num_threads(2)\n  {\n    #pragma omp for schedule(dynamic, 1)\n    for (int i=0; i < 4; ++i){\n      a[i] = i;\n      int s;\n      s = (- 3 - 3) / - 3;\n    }\n\n    #pragma omp single\n    {\n      #pragma omp task\n      {\n       #pragma omp task\n       {\n         psum[1] = a[2] + a[3];\n       }\n        psum[0] = a[0] + a[1];\n      }\n\n      #pragma omp taskwait\n      sum = psum[1] + psum[0];\n    }\n  }\n\n  printf(\"sum = %d\\n\", sum);\n  return 0;\n }\n", "targets": {"27": "  {\n", "29": "    for (int i=0; i < 4; ++i){\n", "28": "    #pragma omp for schedule(dynamic, 1)\n", "30": "      a[i] = i;\n", "32": "      s = (- 3 - 3) / - 3;\n", "33": "    }\n", "35": "    #pragma omp single\n", "37": "      #pragma omp task\n", "46": "      #pragma omp taskwait\n", "47": "      sum = psum[1] + psum[0];\n", "48": "    }\n", "49": "  }\n", "39": "       #pragma omp task\n", "40": "       {\n", "41": "         psum[1] = a[2] + a[3];\n", "38": "      {\n", "43": "        psum[0] = a[0] + a[1];\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1, l2;\nconst int n = 100;\nint x = 1;\n\nvoid barrier_init()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n  omp_init_lock(&l2);\n}\n\nvoid barrier_destroy()\n{\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  omp_destroy_lock(&l2);\n}\n\nvoid barrier_start(int tid)\n{\n  if (tid == 0)\n  {\n    omp_set_lock(&l0);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l1);\n  }\n}\n\nvoid barrier_stop(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_unset_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_unset_lock(&l1);\n  }\n}\n\nvoid barrier_wait(int tid)\n{\n  if (tid == 0)\n  {\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    omp_unset_lock(&l2);\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    omp_set_lock(&l2);\n  }\n  else if (tid == 1)\n  {\n    omp_set_lock(&l0);\n    omp_unset_lock(&l1);\n    omp_set_lock(&l2);\n    omp_unset_lock(&l0);\n    omp_set_lock(&l1);\n    omp_unset_lock(&l2);\n  }\n}\n\nint main()\n{\n  barrier_init();\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    barrier_start(tid);\n#pragma omp barrier\n    for (int i = 0; i < n; i++)\n    {\n      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 1);\n      barrier_wait(tid);\n      if (tid == 0)\n        x = 0;\n      barrier_wait(tid);\n      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n      fflush(stdout);\n      assert(x == 0);\n      barrier_wait(tid);\n      if (tid == 1)\n        x = 1;\n      barrier_wait(tid);\n    }\n#pragma omp barrier\n    barrier_stop(tid);\n  } // end of parallel construct\n  barrier_destroy();\n  printf(\"Done: x=%d\\n\", x);\n}\n", "targets": {"92": "    int tid = omp_get_thread_num();\n", "93": "    barrier_start(tid);\n", "94": "#pragma omp barrier\n", "95": "    for (int i = 0; i < n; i++)\n", "97": "      printf(\"Thread %d: phase 1, i=%d, x=%d\\n\", tid, i, x);\n", "98": "      fflush(stdout);\n", "99": "      assert(x == 1);\n", "100": "      barrier_wait(tid);\n", "101": "      if (tid == 0)\n", "102": "        x = 0;\n", "103": "      barrier_wait(tid);\n", "104": "      printf(\"Thread %d: phase 3, i=%d, x=%d\\n\", tid, i, x);\n", "105": "      fflush(stdout);\n", "106": "      assert(x == 0);\n", "107": "      barrier_wait(tid);\n", "108": "      if (tid == 1)\n", "109": "        x = 1;\n", "110": "      barrier_wait(tid);\n", "111": "    }\n", "112": "#pragma omp barrier\n", "113": "    barrier_stop(tid);\n", "114": "  } // end of parallel construct\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                                  // 1st child task\n\n  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n  y = y-x;                                                              //2nd child task\n\n  #pragma omp task depend(in: x) if(0)                                  // 1st taskwait\n  {}\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                                  // 2nd taskwait\n\n  printf(\"y=%d\\n\",y);\n}\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n", "targets": {"24": "  #pragma omp task depend(inout: x) shared(x)\n", "25": "  x++;                                                                  // 1st child task\n", "27": "  #pragma omp task depend(in: x) depend(inout: y) shared(x, y)\n", "28": "  y = y-x;                                                              //2nd child task\n", "30": "  #pragma omp task depend(in: x) if(0)                                  // 1st taskwait\n", "31": "  {}\n", "42": "  #pragma omp single\n", "43": "  foo();\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n#define C 16\n\nint main(){\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n  #pragma omp teams distribute parallel for simd safelen(C)\n  for (int i=C; i<N; i++){\n    var[i]=var[i-C]+1;\n  }\n\n  printf(\"%d\\n\",var[97]);\n\n  return 0;\n}\n", "targets": {"32": "  for (int i=C; i<N; i++){\n", "31": "  #pragma omp teams distribute parallel for simd safelen(C)\n", "34": "  }\n", "33": "    var[i]=var[i-C]+1;\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main()\n{\n  int k;\n\n#pragma omp parallel\n  {\n#pragma omp master\n    {\n      k = omp_get_num_threads();\n      printf (\"Number of Threads requested = %i\\n\",k);\n    }\n  }\n  return 0;\n}\n", "targets": {"52": "  {\n", "53": "#pragma omp master\n", "55": "      k = omp_get_num_threads();\n", "56": "      printf (\"Number of Threads requested = %i\\n\",k);\n", "57": "    }\n", "58": "  }\n"}}, {"prompt": "#include <stdio.h>\n\n/*\nuse of omp target + teams \nWithout protection, master threads from two teams cause data races.\nData race pair: a[50]@66:5:W vs. a[50]@66:5:W\n*/\nint main(int argc, char* argv[])\n{\n  int i;\n  int len = 100;\n  double a[len];\n\n  /*Initialize with some values*/\n  for (i=0; i<len; i++)\n    a[i]= ((double)i)/2.0;\n\n#pragma omp target map(tofrom: a[0:len]) \n#pragma omp teams num_teams(2) \n  {\n    a[50]*=2.0;\n  }\n\n  printf (\"a[50]=%f\\n\", a[50]);\n  return 0;\n}\n", "targets": {"65": "  {\n", "66": "    a[50]*=2.0;\n", "67": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  int len = 20000;\n\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[len], b[len];\n\n  for (int i = 0; i < len; i++) {\n    a[i] = i;\n    b[i] = i + 1;\n  }\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len - 64; i++)\n    a[i + 64] = a[i] + b[i];\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n\n  return 0;\n}\n", "targets": {"32": "  for (int i = 0; i < len - 64; i++)\n", "33": "    a[i + 64] = a[i] + b[i];\n", "31": "#pragma omp parallel for simd schedule(dynamic, 64)\n"}}, {"prompt": "#include <stdio.h>\n/*\n * This is a program based on a dataset contributed by \n * Wenhao Wu and Stephen F. Siegel @Univ. of Delaware.\n \n * Race because the write to s is not protected by atomic\n * Data race pair: s@26:7:W vs. s@34:16:R\n */\nint main()\n{\n  int x = 0, s = 0;\n#pragma omp parallel sections shared(x, s) num_threads(2)\n  {\n#pragma omp section\n    {\n      x = 1;\n      s = 1;\n    }\n#pragma omp section\n    {\n      int done = 0;\n      while (!done)\n      {\n#pragma omp atomic read seq_cst\n        done = s;\n      }\n      x = 2;\n    }\n  }\n  printf(\"%d\\n\", x);\n}\n", "targets": {"22": "  {\n", "21": "#pragma omp parallel sections shared(x, s) num_threads(2)\n", "25": "      x = 1;\n", "26": "      s = 1;\n", "23": "#pragma omp section\n", "30": "      int done = 0;\n", "31": "      while (!done)\n", "34": "        done = s;\n", "36": "      x = 2;\n", "28": "#pragma omp section\n", "38": "  }\n"}}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int len=100;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) // Note there will be out of bound access\n      b[i][j]=b[i][j-1];\n\n return 0;     \n}\n  \n", "targets": {"78": "  for (i=1;i<n;i++)\n", "77": "#pragma omp parallel for private(j)\n", "79": "    for (j=0;j<m;j++) // Note there will be out of bound access\n", "80": "      b[i][j]=b[i][j-1];\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <stdlib.h>\n#define N 100\n\nint main(){\n\n  int var[N];\n\n  for(int i=0; i<N; i++){\n    var[i]=0;\n  }\n\n  #pragma omp target map(tofrom:var[0:N]) device(0)\n    #pragma omp parallel for ordered\n    for (int i=1; i<N; i++){\n      #pragma omp ordered\n      {\n        var[i]=var[i-1]+1;\n      }\n    }\n\n  for(int i=0; i<N; i++){\n    if(var[i]!=i){\n      printf(\"Data Race Present\");\n      return 0;\n    }\n  }\n\n  return 0;\n}\n", "targets": {"30": "    for (int i=1; i<N; i++){\n", "31": "      #pragma omp ordered\n", "33": "        var[i]=var[i-1]+1;\n", "34": "      }\n", "35": "    }\n", "29": "    #pragma omp parallel for ordered\n"}}, {"prompt": "#include<stdio.h>\n#include<assert.h>\nvoid f1(int *q)\n{\n  *q = 1;\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  #pragma omp parallel reduction(+:sum) num_threads(10) private(i)\n  {\n     f1(&i);\n     sum+= i; \n  }\n  assert (sum==10);\n  printf(\"sum=%d\\n\", sum);\n  return 0;   \n}\n", "targets": {"66": "  {\n", "65": "  #pragma omp parallel reduction(+:sum) num_threads(10) private(i)\n", "67": "     f1(&i);\n", "68": "     sum+= i; \n", "69": "  }\n"}}, {"prompt": "#include <stdlib.h>\nvoid setup(int N)\n{\n  double * m_pdv_sum = (double* ) malloc (sizeof (double) * N );\n  double * m_nvol = (double* ) malloc (sizeof (double) * N );\n\n#pragma omp parallel for schedule(static)\n  for (int i=0; i < N; ++i ) \n  { \n    m_pdv_sum[ i ] = 0.0;\n    m_nvol[ i ]   = i*2.5;\n  }\n\n  free(m_pdv_sum);\n  free(m_nvol);\n}\n\nint main()\n{\n  int N =1000;\n  setup(N);\n}\n  \n", "targets": {"57": "  for (int i=0; i < N; ++i ) \n", "56": "#pragma omp parallel for schedule(static)\n", "59": "    m_pdv_sum[ i ] = 0.0;\n", "60": "    m_nvol[ i ]   = i*2.5;\n", "61": "  }\n"}}, {"prompt": "#include <stdlib.h>\nint main(int argc, char* argv[])\n{\n  int i,j;\n  int len = 1000;\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int n=len, m=len;\n  double b[len][len];\n\n  for (i=0; i<n; i++)\n    for (j=0; j<m; j++)\n      b[i][j] = 0.5; \n\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=1;j<m;j++)\n      b[i][j]=b[i-1][j-1];\n\n  return 0;\n}\n", "targets": {"67": "  for (i=1;i<n;i++)\n", "66": "#pragma omp parallel for private(j)\n", "68": "    for (j=1;j<m;j++)\n", "69": "      b[i][j]=b[i-1][j-1];\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\ndouble c = 0.2;\nint n = 20, nsteps = 100;\n\nint main()\n{\n  double *b = malloc(2 * n * sizeof(double));\n  double *u[2] = {&b[0], &b[n - 2]}; // oops, should be b[n]\n  for (int i = 1; i < n - 1; i++)\n    u[0][i] = u[1][i] = 1.0 * rand() / RAND_MAX;\n  u[0][0] = u[0][n - 1] = u[1][0] = u[1][n - 1] = 0.5;\n  int p = 0;\n  for (int t = 0; t < nsteps; t++)\n  {\n#pragma omp parallel for\n    for (int i = 1; i < n - 1; i++)\n    {\n      u[1 - p][i] = u[p][i] + c * (u[p][i - 1] + u[p][i + 1] - 2 * u[p][i]);\n    }\n    p = 1 - p;\n  }\n  for (int i = 0; i < n; i++)\n    printf(\"%1.2lf \", u[p][i]);\n  printf(\"\\n\");\n  free(b);\n}", "targets": {"36": "    for (int i = 1; i < n - 1; i++)\n", "35": "#pragma omp parallel for\n", "38": "      u[1 - p][i] = u[p][i] + c * (u[p][i - 1] + u[p][i + 1] - 2 * u[p][i]);\n", "39": "    }\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n\n  if (argc>1)\n    len = atoi(argv[1]);\n\n  int a[len];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+1;\n\n  return 0;\n}\n", "targets": {"67": "  for (i=0;i<len-1;i++)\n", "66": "#pragma omp parallel for\n", "68": "    a[i+1]=a[i]+1;\n"}}, {"prompt": "", "targets": {"64": "     foo();\n", "65": "  }\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint main (int argc, char* argv[])\n{\n  int len=1000;\n  int i; \n\n  int a[1000];\n  a[0] = 2;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n    a[i]=a[i]+a[0];\n\n  printf(\"a[500]=%d\\n\", a[500]);\n  return 0;\n}\n", "targets": {"61": "  for (i=0;i<len;i++)\n", "60": "#pragma omp parallel for\n", "62": "    a[i]=a[i]+a[0];\n"}}, {"prompt": "#include <stdio.h>\n\nint main()\n{\n  int count=0;\n\n#pragma omp parallel shared(count) \n  {\n#pragma omp single\n    count += 1;\n  }\n\n  printf (\"count= %d\\n\", count);\n  return 0;\n}\n", "targets": {"51": "  {\n", "52": "#pragma omp single\n", "53": "    count += 1;\n", "54": "  }\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char* argv[])\n{\n  int var = 0;\n  int i;\n\n  #pragma omp parallel sections\n  {\n    for (i = 0; i < 10; i++) {\n      #pragma omp task shared(var)\n      {\n        var++;\n      }\n    }\n  }\n\n  if (var!=10) printf(\"%d\\n\",var);\n  return 0;\n}\n", "targets": {"26": "  {\n", "25": "  #pragma omp parallel sections\n", "27": "    for (i = 0; i < 10; i++) {\n", "28": "      #pragma omp task shared(var)\n", "32": "    }\n", "33": "  }\n", "29": "      {\n", "30": "        var++;\n"}}, {"prompt": "#include <stdio.h>\n/* This is a program based on a test contributed by Yizi Gu@Rice Univ.\n * Missing the ordered clause\n * Data race pair: x@56:5:W vs. x@56:5:W\n * */\nint main()\n{\n  int x =0;\n#pragma omp parallel for ordered \n  for (int i = 0; i < 100; ++i) {\n    x++;\n  }\n  printf (\"x=%d\\n\",x);\n  return 0;\n} \n", "targets": {"55": "  for (int i = 0; i < 100; ++i) {\n", "56": "    x++;\n", "57": "  }\n", "54": "#pragma omp parallel for ordered \n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp task depend(in: x) if(0)                // 1st taskwait\n  {}\n\n  printf(\"x=%d\\n\",x);\n  printf(\"y=%d\\n\",y);\n  #pragma omp taskwait                                // 2nd taskwait\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n", "targets": {"24": "  #pragma omp task depend(inout: x) shared(x)\n", "25": "  x++;                                                //1st Child Task\n", "27": "  #pragma omp task shared(y)\n", "28": "  y--;                                                // 2nd child task\n", "30": "  #pragma omp task depend(in: x) if(0)                // 1st taskwait\n", "31": "  {}\n", "41": "  #pragma omp single\n", "42": "  foo();\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\n\nint main(){\n  int x = 2;\n\n  #pragma omp task shared(x) mergeable\n  {\n    x++;\n  }\n  #pragma omp taskwait\n\n  printf(\"%d\\n\",x);\n  return 0;\n}\n", "targets": {"23": "  #pragma omp task shared(x) mergeable\n", "24": "  {\n", "25": "    x++;\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n#pragma omp barrier\n    if (tid == 0)\n    {\n      omp_set_lock(&l);\n      x = 0;\n      omp_unset_lock(&l);\n    }\n    else if (tid == 1)\n    {\n      omp_set_lock(&l);\n      omp_unset_lock(&l);\n      x = 1;\n    }\n#pragma omp barrier\n  } // end of parallel construct\n  omp_destroy_lock(&l);\n  printf(\"Done: x=%d\\n\", x);\n}", "targets": {"30": "    int tid = omp_get_thread_num();\n", "31": "#pragma omp barrier\n", "32": "    if (tid == 0)\n", "34": "      omp_set_lock(&l);\n", "35": "      x = 0;\n", "36": "      omp_unset_lock(&l);\n", "37": "    }\n", "38": "    else if (tid == 1)\n", "40": "      omp_set_lock(&l);\n", "41": "      omp_unset_lock(&l);\n", "42": "      x = 1;\n", "43": "    }\n", "44": "#pragma omp barrier\n", "45": "  } // end of parallel construct\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nvoid foo(){\n\n  int x = 0, y = 2;\n\n  #pragma omp task depend(inout: x) shared(x)\n  x++;                                                //1st Child Task\n\n  #pragma omp task shared(y)\n  y--;                                                // 2nd child task\n\n  #pragma omp taskwait depend(in: x)                  // 1st taskwait\n\n  printf(\"x=%d\\n\",x);\n\n  #pragma omp taskwait                                // 2nd taskwait\n\n  printf(\"y=%d\\n\",y);\n}\n\n\nint main(){\n  #pragma omp parallel\n  #pragma omp single\n  foo();\n\n  return 0;\n}\n\n", "targets": {"22": "  #pragma omp task depend(inout: x) shared(x)\n", "23": "  x++;                                                //1st Child Task\n", "25": "  #pragma omp task shared(y)\n", "26": "  y--;                                                // 2nd child task\n", "40": "  #pragma omp single\n", "41": "  foo();\n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n\n  int a[2000];\n\n  for (i=0; i<2000; i++)\n    a[i]=i; \n\n#pragma omp parallel for\n  for (i=0;i<1000;i++)\n    a[2*i+1]=a[i]+1;\n\n  printf(\"a[1001]=%d\\n\", a[1001]);  \n  return 0;\n}\n\n", "targets": {"63": "  for (i=0;i<1000;i++)\n", "62": "#pragma omp parallel for\n", "64": "    a[2*i+1]=a[i]+1;\n"}}, {"prompt": "#include <stdio.h>\n#define N 20\n#define C 8\n\nint main(){\n  int var[C];\n\n  for(int i=0; i<C; i++){\n    var[i] = 0;\n  }\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams num_teams(1) thread_limit(1048) \n  #pragma omp distribute parallel for \n  for (int i=0; i<N; i++){\n    #pragma omp simd\n    for(int i=0; i<C; i++){\n      var[i]++;\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(var[i]!=N) printf(\"%d\\n \",var[i]);\n  }\n\n  return 0;\n}\n", "targets": {"29": "  #pragma omp distribute parallel for \n", "30": "  for (int i=0; i<N; i++){\n", "32": "    for(int i=0; i<C; i++){\n", "31": "    #pragma omp simd\n", "33": "      var[i]++;\n", "34": "    }\n", "35": "  }\n"}}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[])\n{   \n  int i;\n  int len = 1000;\n\n  int a[1000];\n\n  for (i=0; i<len; i++)\n    a[i]= i; \n\n#pragma omp parallel for\n  for (i=0;i< len -1 ;i++)\n    a[i]=a[i+1]+1;\n\n  printf (\"a[500]=%d\\n\", a[500] );\n  return 0;\n} \n", "targets": {"63": "  for (i=0;i< len -1 ;i++)\n", "62": "#pragma omp parallel for\n", "64": "    a[i]=a[i+1]+1;\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, b, c, d;\n\n  #pragma omp parallel\n  #pragma omp single\n  {\n    #pragma omp task depend(out: c)\n      c = 1;\n    #pragma omp task depend(out: a)\n      a = 2;\n    #pragma omp task depend(out: b)\n      b = 3;\n    #pragma omp task depend(in: a) depend(mutexinoutset: c)\n      c += a;\n    #pragma omp task depend(in: b) depend(mutexinoutset: c)\n      c += b;\n    #pragma omp task depend(in: c)\n      d = c;\n  }\n\n  printf(\"%d\\n\",d);\n  return 0;\n}\n", "targets": {"24": "  #pragma omp single\n", "26": "    #pragma omp task depend(out: c)\n", "28": "    #pragma omp task depend(out: a)\n", "30": "    #pragma omp task depend(out: b)\n", "32": "    #pragma omp task depend(in: a) depend(mutexinoutset: c)\n", "34": "    #pragma omp task depend(in: b) depend(mutexinoutset: c)\n", "36": "    #pragma omp task depend(in: c)\n", "38": "  }\n", "27": "      c = 1;\n", "29": "      a = 2;\n", "31": "      b = 3;\n", "33": "      c += a;\n", "35": "      c += b;\n", "37": "      d = c;\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp barrier\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a += i;\n    }\n\n    #pragma omp single\n    printf(\"Sum is %d\\n\", a);\n  }\n\n  return 0;\n}\n", "targets": {"24": "  {\n", "25": "    #pragma omp master\n", "26": "    a = 0;\n", "28": "    #pragma omp barrier\n", "31": "    for (i=0; i<10; i++){\n", "30": "    #pragma omp for reduction(+:a)\n", "32": "      a += i;\n", "33": "    }\n", "35": "    #pragma omp single\n", "36": "    printf(\"Sum is %d\\n\", a);\n", "37": "  }\n"}}, {"prompt": "#include <omp.h>\n#include <assert.h> \nint main()\n{\n  omp_lock_t lck;\n  int i=0;\n  omp_init_lock(&lck);\n#pragma omp parallel sections\n  {\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 1;    \n      omp_unset_lock(&lck);\n    }\n#pragma omp section\n    {\n      omp_set_lock(&lck);\n      i += 2;    \n      omp_unset_lock(&lck);\n    }\n  }\n\n  omp_destroy_lock(&lck);\n  assert (i==3);\n  return 0;\n} \n", "targets": {"59": "  {\n", "58": "#pragma omp parallel sections\n", "62": "      omp_set_lock(&lck);\n", "63": "      i += 1;    \n", "64": "      omp_unset_lock(&lck);\n", "60": "#pragma omp section\n", "68": "      omp_set_lock(&lck);\n", "69": "      i += 2;    \n", "70": "      omp_unset_lock(&lck);\n", "66": "#pragma omp section\n", "72": "  }\n"}}, {"prompt": "", "targets": {"59": "  for (i=0;i<100;i++)\n", "58": "#pragma omp parallel for default(none) shared(a) private(i,j)\n", "60": "    for (j=0;j<100;j++)\n", "61": "      a[i][j]=a[i][j]+1;\n", "64": "  for (i=0;i<100;i++)\n", "63": "#pragma omp parallel for default(shared) private(i,j)\n", "65": "    for (j=0;j<100;j++)\n", "66": "      b[i][j]=b[i][j]+1;\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  int len = 20000;\n\n  if (argc > 1)\n    len = atoi(argv[1]);\n  double a[2 * len], b[len];\n\n  for (int i = 0; i < 2 * len; i++)\n    a[i] = i;\n  for (int i = 0; i < len; i++)\n    b[i] = i + 1;\n\n#pragma omp parallel for simd schedule(dynamic, 64)\n  for (int i = 0; i < len; i++)\n    a[i + 64] = a[i * 2] + b[i];\n\n  printf(\"a[0]=%f, a[%i]=%f, a[%i]=%f\\n\", a[0], len / 2, a[len / 2], len - 1,\n         a[len - 1]);\n\n  return 0;\n}\n", "targets": {"32": "  for (int i = 0; i < len; i++)\n", "33": "    a[i + 64] = a[i * 2] + b[i];\n", "31": "#pragma omp parallel for simd schedule(dynamic, 64)\n"}}, {"prompt": "#include <assert.h> \n#include <unistd.h>\n#include \"signaling.h\"\nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    {\n      delay(10000);\n      i = 1;    \n    }\n#pragma omp task depend (out:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n", "targets": {"58": "#pragma omp single\n", "60": "#pragma omp task depend (out:i)\n", "65": "#pragma omp task depend (out:i)\n", "67": "  }\n", "61": "    {\n", "62": "      delay(10000);\n", "63": "      i = 1;    \n", "66": "    i = 2;    \n"}}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[]) \n{\n  int i,j;\n  int n=100, m=100;\n  double b[n][m];\n#pragma omp parallel for private(j)\n  for (i=1;i<n;i++)\n    for (j=0;j<m;j++) // Note there will be out of bound access\n      b[i][j]=b[i][j-1];\n\n  printf (\"b[50][50]=%f\\n\",b[50][50]);\n\n  return 0;     \n}\n  \n", "targets": {"73": "  for (i=1;i<n;i++)\n", "72": "#pragma omp parallel for private(j)\n", "74": "    for (j=0;j<m;j++) // Note there will be out of bound access\n", "75": "      b[i][j]=b[i][j-1];\n"}}, {"prompt": "#include<stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[len], b[len];\n\n  for (i=0;i<len;i++)\n  {  a[i]=i; b[i]=i;} \n/* static storage for a local variable */\n#pragma omp parallel \n  {\n    static int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = a[i]+i;\n      a[i] = tmp;\n    }\n  }\n\n/* automatic storage for a local variable */\n#pragma omp parallel \n  {\n    int tmp;\n#pragma omp for\n    for (i=0;i<len;i++)\n    {\n      tmp = b[i]+i;\n      b[i] = tmp;\n    }\n  }\n\n  printf(\"a[50]=%d b[50]=%d\\n\", a[50], b[50]);\n \n  return 0;\n}\n", "targets": {"68": "  {\n", "71": "    for (i=0;i<len;i++)\n", "70": "#pragma omp for\n", "73": "      tmp = a[i]+i;\n", "74": "      a[i] = tmp;\n", "75": "    }\n", "76": "  }\n", "80": "  {\n", "83": "    for (i=0;i<len;i++)\n", "82": "#pragma omp for\n", "85": "      tmp = b[i]+i;\n", "86": "      b[i] = tmp;\n", "87": "    }\n", "88": "  }\n"}}, {"prompt": "#include <stdio.h>\nint a[100][100];\nint main()\n{\n  int i, j;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n#pragma omp taskloop\n      for (i = 0; i < 100; i++)\n        for (j = 0; j < 100; j++)\n          a[i][j]+=1; \n    }\n  }\n  printf (\"a[50][50]=%d\\n\", a[50][50]);\n  return 0;\n}\n", "targets": {"64": "  {\n", "65": "#pragma omp single\n", "67": "#pragma omp taskloop\n", "71": "    }\n", "72": "  }\n", "68": "      for (i = 0; i < 100; i++)\n", "69": "        for (j = 0; j < 100; j++)\n", "70": "          a[i][j]+=1; \n"}}, {"prompt": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int len=100;\n  int a[100], b[100];\n\n  for (i=0;i<len;i++)\n  {\n    a[i]=i;\n    b[i]=i+1;\n  }\n\n#pragma omp parallel for simd \n  for (i=0;i<len-1;i++)\n    a[i+1]=a[i]+b[i];\n\n  printf(\"a[50]=%d\\n\",a[50]);\n  return 0;\n}\n", "targets": {"65": "  for (i=0;i<len-1;i++)\n", "64": "#pragma omp parallel for simd \n", "66": "    a[i+1]=a[i]+b[i];\n"}}, {"prompt": "#include <stdlib.h>\ntypedef double real8;\n\nvoid foo(real8 * restrict newSxx, real8 * restrict newSyy, int length)\n{\n  int i;\n\n#pragma omp parallel for private (i) firstprivate (length)\n  for (i = 0; i <= length - 1; i += 1) {\n    newSxx[i] = 0.0;\n    newSyy[i] = 0.0;\n  }\n}\n\nint main()\n{\n  int length=1000;\n  real8* newSxx = malloc (length* sizeof (real8));\n  real8* newSyy = malloc (length* sizeof (real8));\n\n  foo(newSxx, newSyy, length);\n\n  free (newSxx);\n  free (newSyy);\n  return 0;\n}\n\n", "targets": {"62": "  for (i = 0; i <= length - 1; i += 1) {\n", "61": "#pragma omp parallel for private (i) firstprivate (length)\n", "63": "    newSxx[i] = 0.0;\n", "64": "    newSyy[i] = 0.0;\n", "65": "  }\n"}}, {"prompt": "", "targets": {"60": "    for (j = 0; j < N; j++)\n", "59": "#pragma omp parallel for reduction(+:sum)\n", "62": "      sum += a[i][j]*v[j];\n", "63": "    }  \n"}}, {"prompt": "#include <stdio.h>\n#include <math.h>\n\n#define MSIZE 200\nint n=MSIZE, m=MSIZE, mits=1000;\ndouble tol=0.0000000001, relax = 1.0, alpha = 0.0543;\ndouble u[MSIZE][MSIZE], f[MSIZE][MSIZE], uold[MSIZE][MSIZE];\ndouble dx, dy;\n\nvoid\ninitialize ()\n{\n  int i, j, xx, yy;\n\n  dx = 2.0 / (n - 1);\n  dy = 2.0 / (m - 1);\n\n/* Initialize initial condition and RHS */\n//#pragma omp parallel for private(i,j,xx,yy)\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n    {\n      xx = (int) (-1.0 + dx * (i - 1));       /* -1 < x < 1 */\n      yy = (int) (-1.0 + dy * (j - 1));       /* -1 < y < 1 */\n      u[i][j] = 0.0;\n      f[i][j] = -1.0 * alpha * (1.0 - xx * xx) * (1.0 - yy * yy)\n        - 2.0 * (1.0 - xx * xx) - 2.0 * (1.0 - yy * yy);\n\n    }\n}\n\nvoid\njacobi ()\n{\n  double omega;\n  int i, j, k;\n  double error, resid,  ax, ay, b;\n\n  omega = relax;\n/* Initialize coefficients */\n\n  dx = 2.0 / (n - 1); \n  dy = 2.0 / (m - 1);\n\n  ax = 1.0 / (dx * dx);         /* X-direction coef */\n  ay = 1.0 / (dy * dy);         /* Y-direction coef */\n  b = -2.0 / (dx * dx) - 2.0 / (dy * dy) - alpha;       /* Central coeff */\n\n  error = 10.0 * tol;\n  k = 1;\n\n  while (k <= mits)\n    {\n      error = 0.0;\n\n/* Copy new solution into old */\n#pragma omp parallel\n      {\n#pragma omp for private(i,j)\n        for (i = 0; i < n; i++)\n          for (j = 0; j < m; j++)\n            uold[i][j] = u[i][j];\n#pragma omp for private(i,j,resid) reduction(+:error) nowait\n        for (i = 1; i < (n - 1); i++)\n          for (j = 1; j < (m - 1); j++)\n            {\n              resid = (ax * (uold[i - 1][j] + uold[i + 1][j])\n                       + ay * (uold[i][j - 1] + uold[i][j + 1]) +\n                       b * uold[i][j] - f[i][j]) / b;\n\n              u[i][j] = uold[i][j] - omega * resid;\n              error = error + resid * resid;\n            }\n      }\n/*  omp end parallel */\n\n/* Error check */\n\n     k = k + 1;\n      error = sqrt (error) / (n * m);\n    }                           /*  End iteration loop */\n\n  printf (\"Total Number of Iterations:%d\\n\", k);\n  printf (\"Residual:%E\\n\", error);\n}\n\nint main()\n{\n  initialize();\n  jacobi();\n  return 0;\n}\n", "targets": {"108": "      {\n", "110": "        for (i = 0; i < n; i++)\n", "109": "#pragma omp for private(i,j)\n", "111": "          for (j = 0; j < m; j++)\n", "112": "            uold[i][j] = u[i][j];\n", "114": "        for (i = 1; i < (n - 1); i++)\n", "113": "#pragma omp for private(i,j,resid) reduction(+:error) nowait\n", "115": "          for (j = 1; j < (m - 1); j++)\n", "117": "              resid = (ax * (uold[i - 1][j] + uold[i + 1][j])\n", "118": "                       + ay * (uold[i][j - 1] + uold[i][j + 1]) +\n", "119": "                       b * uold[i][j] - f[i][j]) / b;\n", "121": "              u[i][j] = uold[i][j] - omega * resid;\n", "122": "              error = error + resid * resid;\n", "123": "            }\n", "124": "      }\n"}}, {"prompt": "#include <assert.h> \nint main()\n{\n  int i=0;\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend (out:i)\n    i = 1;    \n#pragma omp task depend (in:i)\n    i = 2;    \n  }\n\n  assert (i==2);\n  return 0;\n} \n", "targets": {"56": "#pragma omp single\n", "58": "#pragma omp task depend (out:i)\n", "60": "#pragma omp task depend (in:i)\n", "62": "  }\n", "59": "    i = 1;    \n", "61": "    i = 2;    \n"}}, {"prompt": "#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char* argv[])\n{\n  int i;\n  int tmp;\n  int len=100;\n  int a[100];\n  for (i=0;i<len;i++)\n    a[i]=i;\n\n#pragma omp parallel for\n  for (i=0;i<len;i++)\n  {\n    tmp =a[i]+i;\n    a[i] = tmp;\n  }\n\n  printf(\"a[50]=%d\\n\", a[50]);\n  return 0;\n}\n", "targets": {"63": "  for (i=0;i<len;i++)\n", "62": "#pragma omp parallel for\n", "65": "    tmp =a[i]+i;\n", "66": "    a[i] = tmp;\n", "67": "  }\n"}}, {"prompt": "#include <stdlib.h>  \n#include <stdio.h>\nint main(int argc, char* argv[])  \n{\n  int i;\n  int len=100;\n\n  int numNodes=len, numNodes2=0; \n  int x[100]; \n\n  // initialize x[]\n  for (i=0; i< len; i++)\n  {\n    if (i%2==0)\n      x[i]=5;\n    else\n      x[i]= -5;\n  }\n\n#pragma omp parallel for\n  for (i=numNodes-1 ; i>-1 ; --i) {\n    if (x[i]<=0) {\n      numNodes2-- ;\n    }\n  }\n  printf (\"numNodes2 = %d\\n\", numNodes2);\n  return 0;\n} \n", "targets": {"72": "  for (i=numNodes-1 ; i>-1 ; --i) {\n", "71": "#pragma omp parallel for\n", "73": "    if (x[i]<=0) {\n", "74": "      numNodes2-- ;\n", "75": "    }\n", "76": "  }\n"}}, {"prompt": "#include<stdio.h>\n#include<assert.h>\n\nvoid f1(int *q)\n{\n#pragma omp critical\n  *q = 1;\n#pragma omp flush\n}\n\nint main()\n{ \n  int i=0, sum=0; \n  \n  #pragma omp parallel reduction(+:sum) num_threads(10) \n  {\n     f1(&i);\n     sum+=i;\n  }\n  assert (sum==10);\n  printf(\"sum=%d\\n\", sum);\n  return 0;   \n}\n", "targets": {"69": "  {\n", "68": "  #pragma omp parallel reduction(+:sum) num_threads(10) \n", "70": "     f1(&i);\n", "71": "     sum+=i;\n", "72": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#define N 100\n\nint var = 0;\n\nint main(){\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute\n  for (int i=0; i<N; i++){\n    #pragma omp atomic update\n    var++;\n  }\n  printf(\"%d\\n \",var);\n  return 0;\n}\n", "targets": {"23": "  for (int i=0; i<N; i++){\n", "25": "    var++;\n", "26": "  }\n", "22": "  #pragma omp teams distribute\n"}}, {"prompt": "", "targets": {"57": "  for (i=0;i<100;i++)\n", "56": "#pragma omp parallel for collapse(2)\n", "58": "    for (j=0;j<100;j++)\n", "59": "      a[i][j]=a[i][j]+1;\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nstatic double x[20];\n#pragma omp threadprivate(x)\n\nint main(){\n  int i;\n  double j,k;\n\n  #pragma omp parallel for default(shared)\n  for (i = 0; i < 20; i++){\n    x[i] = -1.0;\n    if(omp_get_thread_num()==0){\n      j = x[0];\n    }\n    if(omp_get_thread_num()==0){\n      k = i+0.05;\n    }\n  }\n\n  printf (\"%f %f\\n\", j, k);\n\n  return 0;\n}\n\n", "targets": {"25": "  for (i = 0; i < 20; i++){\n", "24": "  #pragma omp parallel for default(shared)\n", "26": "    x[i] = -1.0;\n", "27": "    if(omp_get_thread_num()==0){\n", "28": "      j = x[0];\n", "29": "    }\n", "30": "    if(omp_get_thread_num()==0){\n", "31": "      k = i+0.05;\n", "32": "    }\n", "33": "  }\n"}}, {"prompt": "#include<stdio.h>\n\n/*  argument pass-by-reference */\nvoid f1(int* q)\n{\n  *q += 1;\n}\n\nint main()\n{ \n  int i=0; \n  #pragma omp parallel \n  {\n     f1(&i);\n  }\n  printf (\"i=%d\\n\",i);\n  return 0;   \n}\n", "targets": {"66": "  {\n", "67": "     f1(&i);\n", "68": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <assert.h>\nint sum0=0, sum1=0;\n//#pragma omp threadprivate(sum0)\n\nvoid foo (int i)\n{\n  sum0=sum0+i;\n}\n\nint main()\n{\n  int i, sum=0;\n#pragma omp parallel\n  {\n#pragma omp for\n    for (i=1;i<=1000;i++)\n    {\n       foo (i);\n    }   \n#pragma omp critical\n    {\n      sum= sum+sum0;\n    } \n  }  \n/*  reference calculation */\n  for (i=1;i<=1000;i++)\n  {\n    sum1=sum1+i;\n  }\n  printf(\"sum=%d; sum1=%d\\n\",sum,sum1);\n//  assert(sum==sum1);\n  return 0;\n}\n\n", "targets": {"68": "  {\n", "70": "    for (i=1;i<=1000;i++)\n", "69": "#pragma omp for\n", "72": "       foo (i);\n", "73": "    }   \n", "74": "#pragma omp critical\n", "76": "      sum= sum+sum0;\n", "77": "    } \n", "78": "  }  \n"}}, {"prompt": "", "targets": {"55": "  for (i=0;i<100;i++)\n", "54": "#pragma omp parallel for\n", "56": "    a[i]=a[i]+1;\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nvoid foo() {\n  int a = 0;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n#pragma omp taskwait\n    }\n\n#pragma omp task depend(inout : a) shared(a)\n    {\n#pragma omp task depend(inout : a) shared(a)\n      a++;\n#pragma omp taskwait\n    }\n  }\n\n  printf(\"a=%d\\n\", a);\n}\n\nint main() {\n  foo();\n\n  return 0;\n}\n", "targets": {"26": "#pragma omp single\n", "28": "#pragma omp task depend(inout : a) shared(a)\n", "35": "#pragma omp task depend(inout : a) shared(a)\n", "41": "  }\n", "30": "#pragma omp task depend(inout : a) shared(a)\n", "31": "      a++;\n", "29": "    {\n", "32": "#pragma omp taskwait\n", "37": "#pragma omp task depend(inout : a) shared(a)\n", "38": "      a++;\n", "36": "    {\n", "39": "#pragma omp taskwait\n"}}, {"prompt": "", "targets": {"55": "  for (i=0;i<n;i++)\n", "54": "#pragma omp parallel for firstprivate (g)\n", "57": "    a[i] = a[i]+g;\n", "58": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 64\n\nfloat a;\nfloat x[C];\nfloat y[C];\n\nint main(){\n  for(int i=0; i<C; i++){\n    a=5;\n    x[i]=0;\n    y[i]=3;\n  }\n\n  #pragma omp target map(to:y[0:C],a) map(tofrom:x[0:C]) device(0)\n  {\n    for(int i=0; i<C; i++){\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = a * x[i];\n      }\n      #pragma omp task depend(inout:x[i])\n      {\n        x[i] = x[i] + y[i];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(x[i]!=3){\n      printf(\"Data Race Detected\\n\");\n      return 0;\n    }\n  }\n\n  #pragma omp taskwait\n  return 0;\n}\n", "targets": {"33": "      #pragma omp task depend(inout:x[i])\n", "34": "      {\n", "35": "        x[i] = a * x[i];\n", "37": "      #pragma omp task depend(inout:x[i])\n", "38": "      {\n", "39": "        x[i] = x[i] + y[i];\n"}}, {"prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define C 100\n\nint *a;\nint *b;\nint *c;\n\nint main(){\n  a = malloc(C*sizeof(int));\n  b = malloc(C*C*sizeof(int));\n  c = malloc(C*sizeof(int));\n\n  for(int i=0; i<C; i++){\n    for(int j=0; j<C; j++){\n      b[j+i*C]=1;\n    }\n    a[i]=1;\n    c[i]=0;\n  }\n\n  #pragma omp target map(to:a[0:C],b[0:C*C]) map(tofrom:c[0:C]) device(0)\n  {\n    #pragma omp teams distribute parallel for\n    for(int i=0; i<C; i++){\n      for(int j=0; j<C; j++){\n        c[i]+=b[j+i*C]*a[j];\n      }\n    }\n  }\n\n  for(int i=0; i<C; i++){\n    if(c[i]!=C){\n      printf(\"Data Race\\n\");\n      return 1;\n    }\n  }\n\n  free(a);\n  free(b);\n  free(c);\n\n  return 0;\n}\n", "targets": {"39": "    for(int i=0; i<C; i++){\n", "38": "    #pragma omp teams distribute parallel for\n", "43": "    }\n", "40": "      for(int j=0; j<C; j++){\n", "41": "        c[i]+=b[j+i*C]*a[j];\n", "42": "      }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n  int a, i;\n\n  #pragma omp parallel shared(a) private(i)\n  {\n    #pragma omp master\n    a = 0;\n\n    #pragma omp for reduction(+:a)\n    for (i=0; i<10; i++){\n      a = a + i;\n    }\n\n    #pragma omp single\n    printf(\"Sum is %d\\n\", a);\n  }\n\n  return 0;\n}\n", "targets": {"23": "  {\n", "24": "    #pragma omp master\n", "25": "    a = 0;\n", "28": "    for (i=0; i<10; i++){\n", "27": "    #pragma omp for reduction(+:a)\n", "29": "      a = a + i;\n", "30": "    }\n", "32": "    #pragma omp single\n", "33": "    printf(\"Sum is %d\\n\", a);\n", "34": "  }\n"}}, {"prompt": "#include <stdio.h>\n#define MYLEN 100\nint a[MYLEN];\n\nvoid gen_task(int& i)\n{\n#pragma omp task\n  {\n    a[i]= i+1;\n  }\n}\n\nint main()\n{\n  int i=0;\n#pragma omp parallel\n  {\n#pragma omp single\n    {\n      for (i=0; i<MYLEN; i++)\n      {\n        gen_task(i);\n      }\n    }\n  }\n  \n  /* correctness checking */\n  for (i=0; i<MYLEN; i++)\n  {\n    //assert (a[i]==i+1);\n    if (a[i]!= i+1)\n    {\n      printf(\"warning: a[%d] = %d, not expected %d\\n\", i, a[i], i+1);\n    }\n  }\n  return 0;\n}\n\n", "targets": {"62": "#pragma omp task\n", "64": "    a[i]= i+1;\n", "66": "}\n", "63": "  {\n", "72": "  {\n", "73": "#pragma omp single\n", "75": "      for (i=0; i<MYLEN; i++)\n", "77": "        gen_task(i);\n", "78": "      }\n", "79": "    }\n", "80": "  }\n"}}, {"prompt": "#include <stdio.h>\n\nint cap = 10, size = 0, packages = 1000;\nunsigned r = 0;\n\nint main()\n{\n#pragma omp parallel sections shared(size, cap) firstprivate(r, packages) num_threads(2)\n  {\n#pragma omp section\n    while (packages)\n    {\n#pragma omp critical\n      {\n        if (size < cap)\n        {\n          size++; // produce\n          packages--; // produced a package\n          printf(\"Produced! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1000; i++)\n        r = (r + 1) % 10;\n    }\n#pragma omp section\n    while (packages)\n    {\n#pragma omp critical\n      {\n        if (size > 0)\n        {\n          size--; // consume\n          packages--; // consumed a package\n          printf(\"Consumed! size=%d\\n\", size);\n          fflush(stdout);\n        }\n      }\n      for (int i = 0; i < 1500; i++)\n        r = (r + 1) % 10;\n    }\n  }\n}\n", "targets": {"25": "  {\n", "24": "#pragma omp parallel sections shared(size, cap) firstprivate(r, packages) num_threads(2)\n", "27": "    while (packages)\n", "29": "#pragma omp critical\n", "31": "        if (size < cap)\n", "33": "          size++; // produce\n", "34": "          packages--; // produced a package\n", "35": "          printf(\"Produced! size=%d\\n\", size);\n", "36": "          fflush(stdout);\n", "37": "        }\n", "38": "      }\n", "39": "      for (int i = 0; i < 1000; i++)\n", "40": "        r = (r + 1) % 10;\n", "26": "#pragma omp section\n", "43": "    while (packages)\n", "45": "#pragma omp critical\n", "47": "        if (size > 0)\n", "49": "          size--; // consume\n", "50": "          packages--; // consumed a package\n", "51": "          printf(\"Consumed! size=%d\\n\", size);\n", "52": "          fflush(stdout);\n", "53": "        }\n", "54": "      }\n", "55": "      for (int i = 0; i < 1500; i++)\n", "56": "        r = (r + 1) % 10;\n", "42": "#pragma omp section\n", "58": "  }\n"}}, {"prompt": "#include <stdio.h>\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n\n/*\nuse of omp target + teams + distribute + parallel for\n*/\nint main(int argc, char* argv[])\n{\n  int i, i2;\n  int len = 2560;\n  double sum =0.0, sum2=0.0;\n  double a[len], b[len];\n  /*Initialize with some values*/\n  for (i=0; i<len; i++)\n  {\n    a[i]= ((double)i)/2.0;\n    b[i]= ((double)i)/3.0;\n  }\n\n#pragma omp target map(to: a[0:len], b[0:len]) map(tofrom: sum)\n#pragma omp teams num_teams(10) thread_limit(256) reduction (+:sum) \n#pragma omp distribute\n  for (i2=0; i2< len; i2+=256)  \n#pragma omp parallel for reduction (+:sum)\n    for (i=i2;i< min(i2+256, len); i++)\n      sum += a[i]*b[i];\n\n/* CPU reference computation */  \n#pragma omp parallel for reduction (+:sum2)\n    for (i=0;i< len; i++)\n      sum2 += a[i]*b[i];\n  printf (\"sum=%f sum2=%f\\n\", sum, sum2);\n  return 0;\n}\n", "targets": {"67": "#pragma omp distribute\n", "66": "#pragma omp teams num_teams(10) thread_limit(256) reduction (+:sum) \n", "68": "  for (i2=0; i2< len; i2+=256)  \n", "69": "#pragma omp parallel for reduction (+:sum)\n", "70": "    for (i=i2;i< min(i2+256, len); i++)\n", "71": "      sum += a[i]*b[i];\n", "75": "    for (i=0;i< len; i++)\n", "74": "#pragma omp parallel for reduction (+:sum2)\n", "76": "      sum2 += a[i]*b[i];\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n\nint main(){\n\n  int x = 0, y;\n\n  #pragma omp parallel num_threads(2)\n  {\n  int thrd = omp_get_thread_num();\n  if (thrd == 0) {\n    #pragma omp critical\n    { x = 10; }\n\n    #pragma omp flush(x)\n\n    #pragma omp atomic write\n    y = 1;\n  } else {\n      int tmp = 0;\n      while (tmp == 0) {\n      #pragma omp atomic read acquire\n      tmp = y;\n      }\n    #pragma omp critical\n    { if (x!=10) printf(\"x = %d\\n\", x); }\n  }\n  }\n  return 0;\n}\n", "targets": {"23": "  {\n", "24": "  int thrd = omp_get_thread_num();\n", "25": "  if (thrd == 0) {\n", "26": "    #pragma omp critical\n", "27": "    { x = 10; }\n", "29": "    #pragma omp flush(x)\n", "32": "    y = 1;\n", "33": "  } else {\n", "34": "      int tmp = 0;\n", "35": "      while (tmp == 0) {\n", "37": "      tmp = y;\n", "39": "    #pragma omp critical\n", "40": "    { if (x!=10) printf(\"x = %d\\n\", x); }\n", "42": "  }\n"}}, {"prompt": "#include <stdio.h>\n#include <omp.h>\n#include <assert.h>\n\nomp_lock_t l0, l1;\nint x = 1;\n\nint main()\n{\n  omp_init_lock(&l0);\n  omp_init_lock(&l1);\n#pragma omp parallel num_threads(2)\n  {\n    int tid = omp_get_thread_num();\n    if (tid == 0)\n      omp_set_lock(&l0);\n    else if (tid == 1)\n      omp_set_lock(&l1);\n#pragma omp barrier\n    if (tid == 0)\n      x = 0;\n    if (tid == 0)\n    {\n      omp_unset_lock(&l0);\n      omp_set_lock(&l0);\n    }\n    else if (tid == 1)\n    {\n      omp_unset_lock(&l1);\n      omp_set_lock(&l1);\n    }\n    if (tid == 1)\n      x = 1;\n#pragma omp barrier\n    if (tid == 0)\n      omp_unset_lock(&l1);\n    else if (tid == 1)\n      omp_unset_lock(&l0);\n  } // end of parallel construct\n  omp_destroy_lock(&l0);\n  omp_destroy_lock(&l1);\n  printf(\"Done: x=%d\\n\", x);\n}\n", "targets": {"32": "    int tid = omp_get_thread_num();\n", "33": "    if (tid == 0)\n", "34": "      omp_set_lock(&l0);\n", "35": "    else if (tid == 1)\n", "36": "      omp_set_lock(&l1);\n", "37": "#pragma omp barrier\n", "38": "    if (tid == 0)\n", "39": "      x = 0;\n", "40": "    if (tid == 0)\n", "42": "      omp_unset_lock(&l0);\n", "43": "      omp_set_lock(&l0);\n", "44": "    }\n", "45": "    else if (tid == 1)\n", "47": "      omp_unset_lock(&l1);\n", "48": "      omp_set_lock(&l1);\n", "49": "    }\n", "50": "    if (tid == 1)\n", "51": "      x = 1;\n", "52": "#pragma omp barrier\n", "53": "    if (tid == 0)\n", "54": "      omp_unset_lock(&l1);\n", "55": "    else if (tid == 1)\n", "56": "      omp_unset_lock(&l0);\n", "57": "  } // end of parallel construct\n"}}, {"prompt": "#include <omp.h>\n#include <stdio.h>\n\nint main(){\n\n  int var=0,i;\n\n  #pragma omp target map(tofrom:var) device(0)\n  #pragma omp teams distribute parallel for\n  for (int i=0; i<100; i++){\n    var++;\n  }\n\n  printf(\"%d\\n\",var);\n  return 0;\n}\n", "targets": {"25": "  for (int i=0; i<100; i++){\n", "24": "  #pragma omp teams distribute parallel for\n", "27": "  }\n", "26": "    var++;\n"}}, {"prompt": "", "targets": {"61": "  for (i=0;i< len;i++)\n", "60": "#pragma omp parallel for\n", "62": "    a[i]=a[i]+1;\n"}}]